import scipy.optimize as optimizeimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport seaborn as snsimport copyimport nupackfrom  matplotlib.colors import LinearSegmentedColormapimport matplotlib.patches as mpatchesimport matplotlib.path as mpathfrom matplotlib import gridspecimport matplotlibmatplotlib.rc('font', **{'size' : 14})linestyles = ['-', '--', ':', '-.']colors = (['#1E88E5', '#FFC107', '#D81B60', '#004D40', '#501ACA', '#65C598',            '#4C1F49', '#A64ADE', '#339010'] + ['#0B3B65', '#8C6902', '#7D0E36', '#03B99A', '#8F6AE2']) * 10gray_colors = ['#ADAFB3', '#757575', '#4E4E4E', '#232323', '#E4E4E4'] * 10rev_colors = ['#A64ADE', '#4C1F49', '#65C598', '#501ACA', '#004D40', '#D81B60', '#FFC107','#1E88E5']blue_colors = ['aquamarine', 'lightseagreen', 'teal', 'aqua', 'darkblue', 'deepskyblue',                'steelblue', 'dodgerblue', 'royalblue', 'blue', 'slateblue', 'blueviolet', 'c',               'seagreen', 'mediumseagreen', 'midnightblue', 'mediumspringgreen'] * 3red_colors = ['lightcoral', 'brown', 'red', 'salmon', 'coral', 'lightsalmon', 'chocolate',              'sienna', 'sandybrown', 'peru', 'darkorange', 'gold', 'y']times = range(0, 480 + 1, 5)times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)occlusions = [0, 10, 14, 21, 28]#%% Plot the colorsn = len(colors[:14])ncols = 2nrows = n // ncolsfig, ax = plt.subplots(figsize=(9, 8))# Get height and widthX, Y = fig.get_dpi() * fig.get_size_inches()h = Y / (nrows + 1)w = X / ncolsfor i, name in enumerate(colors[:n]):    row = i % nrows    col = i // nrows    y = Y - (row * h) - h    xi_line = w * (col + 0.05)    xf_line = w * (col + 0.25)    xi_text = w * (col + 0.3)    ax.text(xi_text, y, name, fontsize=(h * 0.5),            horizontalalignment='left',            verticalalignment='center')    ax.hlines(y + h * 0.1, xi_line, xf_line,              color=colors[i], linewidth=(h * 0.6))ax.set_xlim(0, X)ax.set_ylim(0, Y)ax.set_axis_off()fig.subplots_adjust(left=0, right=1,                    top=1, bottom=0,                    hspace=0, wspace=0)plt.show()#%% Random walks #XXX#%% Simulate random walksimport timeds = np.arange(1, 29)try:    trials_length = np.zeros((28, 1000000))    for e, d in enumerate(range(1, 29)):        trials_length[e, :] = np.load('randwalk_results/randwalk_len' + str(d) + '_ntrials1000000.npy')except:    def rand_walk(init_pos, d, reflect=True, p=0.5):  # not sure if this should be p or q        num_steps = 0        pos = init_pos        num_times_reflected = 0        while pos < d:            step = 2 * (rand_nums.pop() > p) - 1            pos += step            num_steps += 1            if pos < 0:                num_times_reflected += 1                if reflect:                    pos = 0                else:                    return(False, num_steps, num_times_reflected)            if pos == d:                return(True, num_steps, num_times_reflected)        num_trials = 10000    init_pos = 0    reflect = True    p = 0.5        if not reflect:        num_trials *= 10        ds = np.arange(1, 29)    num_ds = len(ds)        trials_success = np.zeros((num_ds, num_trials))    trials_length = np.zeros((num_ds, num_trials))    trials_num_reflect = np.zeros((num_ds, num_trials))    start = time.time()    for d_e, d in enumerate(ds):        print('Starting d =', d, ' and time elapsed =', time.time() - start)        rand_nums = list(np.random.random(10000000))        rand_num_counter = 0        for e in range(num_trials):            trials_success[d_e, e], trials_length[d_e, e], trials_num_reflect[d_e, e] = rand_walk(                init_pos, d, reflect=reflect, p=p)#%% First passage time probabilityplt.figure()plt.hist(trials_length[-15], 100, color=colors[4], alpha=0.5, density=True, label=29 - 15, zorder=100)plt.hist(trials_length[-8], 100, color=colors[3], alpha=0.5, density=True, label=29 - 8, zorder=50)plt.hist(trials_length[-1], 100, color=colors[1], alpha=0.5, density=True, label=29 - 1)plt.xlim([-100, 3000])plt.xlabel('First passage time')plt.ylabel('Probability')plt.legend(title='Random walk\n      length')plt.show()#%% Show random walk length histogramsplt.figure()plt.hist(trials_length[10],100, alpha=0.1, density=True, label=10)plt.plot(np.exp(-np.arange(1000) / np.std(trials_length[10])) / np.std(trials_length[10])) # std is a better estimate of the slope than meanplt.hist(trials_length[15],100, alpha=0.1, density=True, label=15)plt.plot(np.exp(-np.arange(2000) / np.std(trials_length[15])) / np.std(trials_length[15]))plt.hist(trials_length[25],100, alpha=0.1, density=True, label=25)plt.plot(np.exp(-np.arange(5000) / np.std(trials_length[25])) / np.std(trials_length[25]))plt.yscale('log')plt.xlabel('Steps taken to complete random walk')plt.ylabel('Probability')plt.legend(title='Random walk length')plt.show()#%% Plots for Fig. 1 #XXX#%%RNA_probe_suffix = '043'  #'024'  # '043'data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed.xlsx')import datetimeif type(data.Time[0]) == datetime.time:    times = []    for i in data.Time:        times.append(60 * i.hour + i.minute)    data.Time = timescol_rename = {}for col in data.columns:    if col[:2] == '35' or col[:2] == '42':        col_rename[col] = col[:5] + col[9:]data.rename(col_rename, axis=1, inplace=True)times = data.Time.to_numpy()num_replicates = 3colors_series_blue = ['#D2E7FB', '#A8D5FB', '#7FC2FD', '#3AA1FB', '#3685C9', '#1C5F9C', '#046361'] + [colors[2]] + colors[6:]colors_series_green = ['#DBFDE5', '#A5F1BB', '#5DFF8C', '#11D84B', '#0A9834', '#056521', '#046361']+ [colors[2]] + colors[6:]min_data = np.min(data.iloc[0][1:])max_data = np.max(data.iloc[-1][1:])#%%def fit_data(time_series, fit_type='rab', xdata=times, yerr=None, min_max_fluorescence=None,              fluor_max=max_data):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        if min_max_fluorescence is None:        min_max_fluorescence = 5000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])        # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)all_data = dict()data_mean = dict()data_std = dict()fit_rs = dict()fit_r_errs = dict()fit_preds = dict()for well in data.columns[1:]:  # Ignore the 'Time' column    if well[-2] != '.':        all_data[well] = np.zeros((num_replicates, len(times)))        all_data[well][0, :] = data[well]    else:        all_data[well[:-2]][int(well[-1]), :] = data[well]    for condition in all_data.keys():    data_mean[condition] = np.mean(all_data[condition], 0)    data_std[condition] = np.std(all_data[condition], 0)        fit_params, covariance, fit_pred = fit_data(        data_mean[condition], fit_type='rb')#, yerr=data_std[condition])    # fit_rs[condition] = np.exp(fit_params[0])    # fit_r_errs[condition] = np.sqrt(np.exp(fit_params[0])**2 * covariance[0, 0])    fit_preds[condition] = fit_pred        # Calculate error using stdev rather than just the error of the fits    replicate_fitrs = []    for r in range(num_replicates):        fit_params, covariance, fit_pred = fit_data(            all_data[condition][r, :],             fit_type='rb')        replicate_fitrs += [np.exp(fit_params[0])]    fit_rs[condition] = np.mean(replicate_fitrs)    fit_r_errs[condition] = np.std(replicate_fitrs)#%% Organize data# import matplotlib# font = {'family' : 'Helvetica',#         'weight' : 'normal',#         'size'   : 12}# matplotlib.rc('font', **font)color_dict = {0: '#FFC107',              7: '#D2E7FB',              11: '#A8D5FB',              14: '#7FC2FD',              18: '#3AA1FB',              21: '#3685C9',              24: '#1C5F9C',              28: '#0B3B65',               35: '#0B2D65',               42: '#06145F',              'mut': '#501ACA', #'gray', #'#D81B60',              'NTC': 'black'              }color_palette = matplotlib.cm.get_cmap('afmhot')for key in color_dict.keys():    if type(key) == int:        color_dict[key] = color_palette((46 - (key + 4)) / 50)color_dict[0] = colors[0]all_fit_rs_in_hours = dict()all_fit_r_errs_in_hours = dict()# =============================================================================# Read in data from unimolecular expts# =============================================================================PLD_data = pd.read_excel('RNAProbe17_data.xlsx', index_col=0)col_names =  PLD_data.columnstime_points =  PLD_data.indexnum_cols = len(col_names)num_timepoints = len(time_points)# Combine the replicates into a new arraynum_replicates = 3num_unique_cols = num_cols // num_replicates  # // to make it an integermean_data = np.zeros((num_timepoints, num_unique_cols))std_data = np.zeros((num_timepoints, num_unique_cols))all_replicate_data = np.zeros((num_timepoints, num_unique_cols, num_replicates))replicate_data = np.zeros((num_timepoints, num_replicates))unique_col_names = []for unique_col_index in range(num_unique_cols):      col_index = unique_col_index * num_replicates    unique_col_names += [col_names[col_index]]    for r in range(num_replicates):        replicate_data[:, r] =  PLD_data[col_names[col_index + r]]        all_replicate_data[:, unique_col_index, r] = replicate_data[:, r]    mean_data[:, unique_col_index] = np.mean(replicate_data, 1)    std_data[:, unique_col_index] = np.std(replicate_data, 1)    # separate between cr1 and cr2num_cr1 = np.sum([i[2] == '1' for i in unique_col_names])num_cr2 = np.sum([i[2] == '2' for i in unique_col_names])num_crs = [None, num_cr1, num_cr2]separate_mean_data = dict()separate_std_data = dict()separate_mean_data['cr1'] = mean_data[:, :num_cr1] separate_mean_data['cr2'] = mean_data[:, num_cr1:] separate_std_data['cr1'] = std_data[:, :num_cr1] separate_std_data['cr2'] = std_data[:, num_cr1:] unique_col_names_crs = [None, unique_col_names[:num_cr1], unique_col_names[num_cr1:]]# break up plots to be clearersplits = [None,           [[0, 1, 2, 3, 4, 5, 6, 13],            [#0,             7, 8, 9, 10, 11, 12, 13],  # remove 12 to remove Dmut           [0, 13, 14, 15, 16, 17]],           [[0, 1, 2, 3, 4, 5, 6, 7],           [0, 8, 9, 10, 11, 12, 13, 7]]]occ_len_labels = [0, None, None, None, None, None, None, 0, 7, 14, 21, 28, 'mut', 'NTC']cr = 1split = splits[cr][1]all_fit_rs_in_hours['unimolecular'] = dict()all_fit_r_errs_in_hours['unimolecular'] = dict()for plot_index, plot_data in enumerate(['RNA', 'DNA']):    all_fit_rs_in_hours[plot_data] = dict()    all_fit_r_errs_in_hours[plot_data] = dict()    columns_to_plot = []    for well in data.columns:        if 'No occluder' in well or 'NOC' in well:  # the first is used in 024, the second in 043            columns_to_plot += [well]    for well in data.columns:        if ('mut' not in well and (plot_data in well or '&' in well)) and not (                '28nt DNA' in well or '24nt DNA' in well or                 'PAM' in well                # or '35' in well or '42' in well                ):            columns_to_plot += [well]    for well in data.columns:        if 'NTC' in well or ('mut' in well and plot_data in well):            columns_to_plot += [well]        for e in split:    if e != 12:  # remove "mut"         col_name = unique_col_names_crs[cr][e]        rep_data = np.vstack([PLD_data[col_name],                           PLD_data[col_name + '.1'],                            PLD_data[col_name + '.2']])            fit_params, covariance, fit_pred = fit_data(            mean_data[:, e], xdata=np.array(PLD_data.index, dtype=float), fit_type='rb', fluor_max=25000)        all_fit_rs_in_hours['unimolecular'][occ_len_labels[e]] = np.exp(fit_params[0]) * 60        all_fit_r_errs_in_hours['unimolecular'][occ_len_labels[e]] = np.sqrt(np.exp(fit_params[0])**2 * covariance[0, 0]) * 60for plot_data in ['RNA', 'DNA']:    all_fit_rs_in_hours[plot_data] = dict()    all_fit_r_errs_in_hours[plot_data] = dict()    columns_to_plot = []    for well in data.columns:        if 'No occluder' in well or 'NOC' in well:  # the first is used in 024, the second in 043            columns_to_plot += [well]    for well in data.columns:        if ('mut' not in well and (plot_data in well or '&' in well)) and not (                '28nt DNA' in well or '24nt DNA' in well or                 'PAM' in well                # or '35' in well or '42' in well                ):            columns_to_plot += [well]    for well in data.columns:        if 'NTC' in well or ('mut' in well and plot_data in well):            columns_to_plot += [well]            index_to_use = 0    for well in columns_to_plot:        if 'NTC' in well:            color_dict_index = 'NTC'        elif 'No occluder' in well or 'NOC' in well: #or 'mut' in well:            color_dict_index = 0        else:            if 'mut' in well:                color_dict_index = 'mut'            else:                color_dict_index = int(well[:np.where([i == 'n' for i in well])[0][0]])        color = color_dict[color_dict_index]        if index_to_use % num_replicates == 0:            all_fit_rs_in_hours[plot_data][color_dict_index] = fit_rs[well] * 60            all_fit_r_errs_in_hours[plot_data][color_dict_index] = fit_r_errs[well] * 60        index_to_use += 1    #%% Make Fig. 1Avfig = Falsedata_linestyle = ''  # '--'data_linewidth = 2.data_marker = '.'  # ''data_marker_size = 3  # 3data_alpha = 1.  # 0.3fit_linestyle = '-'  # '-'fit_linewidth = .5  # 4.fit_alpha = 0.8color_lightening_for_fit = 1.  # 1. to have no effectpe_stroke_linewidth = 3  # set to 0. to have no effectzorder_data=0zorder_fit=10if vfig:    fig = plt.figure(figsize=(4, 8.4))  # (4, 6.4)    gs = fig.add_gridspec(3, 1, wspace=0.15, hspace=0.3)  #hspace=0.5else:    fig = plt.figure(figsize=(10, 2))    gs = fig.add_gridspec(1, 3, wspace=0.15, hspace=0.15)axs_full = gs.subplots(sharey=True)ax = axs_full.flatfor e in [7,8,9,10,11,13]: #split, removing Dmut    col_name = unique_col_names_crs[cr][e]    ax[0].plot(time_points,              PLD_data[col_name] / np.max(PLD_data.max()),              color=color_dict[occ_len_labels[e]],              linestyle=data_linestyle, linewidth=data_linewidth,             marker=data_marker, markersize=data_marker_size,             alpha=data_alpha,             zorder=10,             # label=occ_len_labels[e]             )    for r in [1, 2]:        ax[0].plot(time_points,                  PLD_data[col_name + '.' + str(r)] / np.max(PLD_data.max()),                  color=color_dict[occ_len_labels[e]],                 linestyle=data_linestyle, linewidth=data_linewidth,                 zorder=10,                 marker=data_marker, markersize=data_marker_size, alpha=data_alpha                 )    fit_params, covariance, fit_pred = fit_data(        mean_data[:, e], xdata=np.array(PLD_data.index, dtype=float), fit_type='rb', fluor_max=25000)    all_fit_rs_in_hours['unimolecular'][occ_len_labels[e]] = np.exp(fit_params[0]) * 60    all_fit_r_errs_in_hours['unimolecular'][occ_len_labels[e]] = np.sqrt(np.exp(fit_params[0])**2 * covariance[0, 0]) * 60    ax[0].plot(time_points,              fit_pred / np.max(PLD_data.max()),              fit_linestyle,             # color=lighten_color(color_dict[occ_len_labels[e]], color_lightening_for_fit),              # path_effects=[pe.Stroke(linewidth=pe_stroke_linewidth, foreground='k'), pe.Normal()],             linewidth=fit_linewidth,             color='k',              alpha=fit_alpha,             zorder=zorder_fit,             # label=occ_len_labels[e]             )# for label in color_dict.keys():#     plt.plot([-np.inf] * 2, [np.inf] * 2, label=label, color=color_dict[label])# leg = plt.legend(bbox_to_anchor=(1.05, 1), fontsize=13, title='Occlusion\n   length')# for legobj in leg.legendHandles:#     legobj.set_linewidth(2.5)  # 2.#     legobj.set_linestyle('-')  # 2.ax[0].set_xticks([0, 60, 120, 180], ['', '', '', ''])ax[0].set_yticks([0, 0.5, 1.])# plt.ylabel('Normalized fluorescence')# ax[0].set_xlabel('Time (hr)')ax[0].set_title('Unimolecular RNA')# plt.show()for plot_index, plot_data in enumerate(['RNA', 'DNA']):    all_fit_rs_in_hours[plot_data] = dict()    all_fit_r_errs_in_hours[plot_data] = dict()    columns_to_plot = []    for well in data.columns:        if 'No occluder' in well or 'NOC' in well:  # the first is used in 024, the second in 043            columns_to_plot += [well]    for well in data.columns:        if ('mut' not in well and (plot_data in well or '&' in well)) and not (                '28nt DNA' in well or '24nt DNA' in well or                 '24nt RNA' in well or  # cut 24nt RNA since it's not in DNA or in unimolecular                'PAM' in well                or '35' in well or '42' in well  # cut since these don't add much                ):            columns_to_plot += [well]    for well in data.columns:        if ('NTC' in well #or ('mut' in well and plot_data in well)            ):            columns_to_plot += [well]          index_to_use = 0    for well in columns_to_plot:        if 'NTC' in well:            color_dict_index = 'NTC'        elif 'No occluder' in well or 'NOC' in well: #or 'mut' in well:            color_dict_index = 0        else:            if 'mut' in well:                color_dict_index = 'mut'            else:                color_dict_index = int(well[:np.where([i == 'n' for i in well])[0][0]])        color = color_dict[color_dict_index]        label = ''        ax[plot_index + 1].plot(times,                                 data[well] / np.max(data.max()),                                 label=label, color=color,                                linestyle=data_linestyle, linewidth=data_linewidth,                                marker=data_marker, markersize=data_marker_size,                                alpha=data_alpha,                                zorder=zorder_data,                                )        if index_to_use % num_replicates == 2:            ax[plot_index + 1].plot(times, fit_preds[well[:-2]] / np.max(data.max()),                      # color=lighten_color(color, color_lightening_for_fit),                     # path_effects=[pe.Stroke(linewidth=pe_stroke_linewidth, foreground='k'), pe.Normal()],                     linewidth=fit_linewidth,                     linestyle=fit_linestyle,                      color='k',                      alpha=fit_alpha,                     zorder=zorder_fit)            all_fit_rs_in_hours[plot_data][color_dict_index] = fit_rs[well[:-2]] * 60            all_fit_r_errs_in_hours[plot_data][color_dict_index] = fit_r_errs[well[:-2]] * 60        index_to_use += 1        ax[plot_index + 1].set_xticks([0, 60, 120, 180], ['', '', '', ''])    ax[plot_index + 1].set_yticks([0, 0.5, 1.])    ax[plot_index + 1].set_title(plot_data + ' occluders')if vfig:    ax[1].set_ylabel('Normalized fluorescence')    ax[2].set_xticks([0, 60, 120, 180], [0, 1, 2, 3])    ax[2].set_xlabel('Time (h)')else:    ax[0].set_ylabel('Normalized fluorescence')    for axs in ax:        axs.set_xticks([0, 60, 120, 180], [0, 1, 2, 3])        axs.set_xlabel('Time (h)')if vfig:    ax_legend = 0    leg_bbox = (1.05, 0.6)    leg_ncol = 1    leg_title = 'Occlusion\n   length'    leg2_bbox = (0.4, 0.6)  # (0.4, 0.4)    leg2_ax = 1  # 2else:    ax_legend = 2    leg_bbox = (1.05, 0.7) #(1.05, 1.2)    leg_ncol = 1  #6    leg_title = 'Occlusion\nlength (nt)'    leg2_bbox = (1.05, 1.2) #(1.05, 0.2) #(1.05, 0.5)    leg2_ax = 2for label in color_dict.keys():  # [0, 11, 18, 28, 7, 14, 21, 'NTC']:  #    if label not in [24, 35, 42, 'mut']:  # since we cut these        ax[ax_legend].plot([-np.inf] * 2, [np.inf] * 2, label=label, color=color_dict[label])leg = ax[ax_legend].legend(bbox_to_anchor=leg_bbox, fontsize=12, title=leg_title,                   ncol=leg_ncol)for legobj in leg.legendHandles:    legobj.set_linewidth(2.5)  # 2.    legobj.set_linestyle('-')  # 2.ax[ax_legend].add_artist(leg)    l1, = plt.plot([np.inf, np.inf], [np.inf, np.inf], color='k',                 linewidth=2.5, linestyle=data_linestyle,                marker=data_marker, markersize=10,                label='Data')l2, = plt.plot([np.inf, np.inf], [np.inf, np.inf], color='k',                 linewidth=2.5, linestyle=fit_linestyle,                label='Fit')leg2 = ax[leg2_ax].legend(handles=[l1, l2],                            bbox_to_anchor=leg2_bbox, fontsize=12,                            framealpha=0.4)plt.show()#%% Plot correlationfor with_error_bars in [True]:    for log_scale in [True]:        plt.figure(figsize=(3.6, 3.2))        ax = plt.gca()        ax.plot([0, 10], [0, 10], '--', color='gray')                DNA_RNA_matching_occ_lengths = [occ_length for occ_length in                 set(all_fit_rs_in_hours['DNA'].keys()).intersection(                    all_fit_rs_in_hours['RNA'].keys())]        for e, occ_length in enumerate(DNA_RNA_matching_occ_lengths):            if occ_length != 'NTC': #and occ_length != 'mut': #and occ_length != 0:                ax.plot(all_fit_rs_in_hours['DNA'][occ_length],                         all_fit_rs_in_hours['RNA'][occ_length],                          'o',                         color=color_dict[occ_length],                          markersize=15, markeredgewidth=0.75, markeredgecolor='k')                if with_error_bars:                    ax.errorbar(all_fit_rs_in_hours['DNA'][occ_length],                                  all_fit_rs_in_hours['RNA'][occ_length],                                  xerr=all_fit_r_errs_in_hours['DNA'][occ_length],                                 yerr=all_fit_r_errs_in_hours['RNA'][occ_length],                                 color='k',                                  elinewidth=2)                ax.set_xlabel('Activity with DNA occluder (h' + r'$^{-1}$' + ')', fontsize=12)        ax.set_ylabel('Activity with RNA occluder (h' + r'$^{-1}$' + ')', fontsize=12)        ax.set_yticks([0, 0.5, 1, 1.5, 2])                DNA_uni_matching_occ_lengths = [occ_length for occ_length in                 set(all_fit_rs_in_hours['DNA'].keys()).intersection(                    all_fit_rs_in_hours['unimolecular'].keys())]            for e, occ_length in enumerate(DNA_uni_matching_occ_lengths):            if occ_length != 'NTC': #and occ_length != 'mut': #and occ_length != 0:                ax.plot(all_fit_rs_in_hours['DNA'][occ_length],                         all_fit_rs_in_hours['unimolecular'][occ_length],                          '^',                         color=color_dict[occ_length],                          markersize=15, markeredgewidth=0.75, markeredgecolor='k')                if with_error_bars:                    ax.errorbar(all_fit_rs_in_hours['DNA'][occ_length],                                  all_fit_rs_in_hours['unimolecular'][occ_length],                                  xerr=all_fit_r_errs_in_hours['DNA'][occ_length],                                 yerr=all_fit_r_errs_in_hours['unimolecular'][occ_length],                                 color='k',                                  elinewidth=2)                ax.plot([np.inf]*2, [np.inf]*2, '^', markersize=9,                color='gray', label='Unimolecular')        ax.plot([np.inf]*2, [np.inf]*2, 'o', markersize=9,                 color='gray', label='RNA oligo')                first_legend = ax.legend(title='RNA occluder type',                                  loc='upper left', fontsize=11, title_fontsize=11)        ax.add_artist(first_legend)        if log_scale:            ax.set_yscale('log')            ax.set_xscale('log')            ax.set_ylim([0.055, 4.2]) #2.2])            ax.set_xlim([0.055, 4.2]) #2.2])        else:            ax.set_ylim([-0.3, 3.4])            ax.set_xlim([-0.03, 1.1])            ax.set_yticks([0, 1, 2, 3])                    l1, = plt.plot([np.inf, np.inf], [np.inf, np.inf], color='gray',                         marker='^', markersize=10,                        linestyle='',                        label=r'$R=$' + '0.993')        l2, = plt.plot([np.inf, np.inf], [np.inf, np.inf], color='gray',                         marker='o', markersize=10,                        linestyle='',                        label=r'$R=$' + '0.995')        leg2 = plt.gca().legend(handles=[l1, l2],                                loc='lower right',                                title='Pearson correlation',                                 fontsize=13,                                title_fontsize=11,                                framealpha=0.4)        plt.show()    print('R-value of DNA/uni in log-space is', np.corrcoef(    np.log([all_fit_rs_in_hours['DNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths]),     np.log([all_fit_rs_in_hours['unimolecular'][occ_length] for occ_length in DNA_uni_matching_occ_lengths])    )[0, 1])print('R-value of DNA/uni in linear-space is', np.corrcoef(    ([all_fit_rs_in_hours['DNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths]),     ([all_fit_rs_in_hours['unimolecular'][occ_length] for occ_length in DNA_uni_matching_occ_lengths])    )[0, 1])print('R-value of DNA/RNA in log-space is', np.corrcoef(    np.log([all_fit_rs_in_hours['DNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths]),     np.log([all_fit_rs_in_hours['RNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths])    )[0, 1])print('R-value of DNA/RNA in linear-space is', np.corrcoef(    ([all_fit_rs_in_hours['DNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths]),     ([all_fit_rs_in_hours['RNA'][occ_length] for occ_length in DNA_uni_matching_occ_lengths])    )[0, 1])#%% Calculation for dimer FEsdef get_dimer_landscape_FE(seqs, return_all_dimer_FEs=False):            if len(seqs) == 1:        seqs = seqs * 2  # assume we mean to calculate the FE of the homodimer    if len(seqs) > 2:        print('The code is currently only set up to handle up to 2 sequences')        return(0.)    nupack_model = nupack.Model(material='rna', kelvin=310.15#, ensemble='nostacking'                            )    nupack_seqs = []    for e, seq in enumerate(seqs):        nupack_seqs += [nupack.Strand(seq, name='seq' + str(e+1))]    cset1 = nupack.ComplexSet(strands=nupack_seqs, complexes=nupack.SetSpec(max_size=2))    complex_analysis_result = nupack.complex_analysis(cset1, model=nupack_model,                                             compute=['pfunc'])  # , 'mfe'    dimer_names = [i.name for i in cset1 if '+' in i.name]  # can also substitute complex_analysis_result.keys() for cset1     homodimer_1_name = [i for i in dimer_names if i.count('seq1')==2][0]    homodimer_2_name = [i for i in dimer_names if i.count('seq2')==2][0]    heterodimer_name = [i for i in dimer_names if 'seq1' in i and 'seq2' in i][0]        homodimer_1_FE = complex_analysis_result[homodimer_1_name][2]  # complex_analysis_result['(seq1+seq1)'][2]   # [1] is the partition function; [2] is the free energy    homodimer_2_FE = complex_analysis_result[homodimer_2_name][2]  # complex_analysis_result['(seq2+seq2)'][2]    heterodimer_FE = complex_analysis_result[heterodimer_name][2]  # complex_analysis_result['(seq2+seq1)'][2] #or can also be '(seq1+seq2)'        if return_all_dimer_FEs == False:        return(heterodimer_FE)    return(heterodimer_FE, homodimer_1_FE, homodimer_2_FE)occ_to_fit = 'RNA'num_nts_occluded_list = np.array([condition for condition in all_fit_rs_in_hours[occ_to_fit].keys()                         if condition != 'mut' and condition != 'NTC' #and condition != 0                         and condition <= 28])P_rand_seq = 'AUAACAGAAAGGCAGAGGAAGAGUGGGU' + 'CAAAUAAUACAUAUAACGAGCAGAAGGAGAAACAC'seqs_5in_full = ['ACCCACTCTTCCTCTGCCTTTCTGTTAT'[-i:] for i in range(1, len('ACCCACTCTTCCTCTGCCTTTCTGTTAT'))]kBT = 0.0019872  * (273.15 + 30)dG_5in_full = np.array(    [get_dimer_landscape_FE([P_rand_seq, seq], return_all_dimer_FEs=False)    for seq in seqs_5in_full])dG_5in_full_approx = dG_5in_full[-1] * (np.arange(1,28)/28)#%% Load data collected from both directions # The data do not exactly match previous results since these are new data collected on a different dayRNA_probe_suffix_2 = '024'  #'024'  # '043'data_2 = pd.read_excel('RNAProbe' + RNA_probe_suffix_2 + '_indexed.xlsx')import datetimeif type(data_2.Time[0]) == datetime.time:    times_2 = []    for i in data_2.Time:        times_2.append(60 * i.hour + i.minute)    data_2.Time = times_2col_rename = {}for col in data_2.columns:    if col[:2] == '35' or col[:2] == '42':        col_rename[col] = col[:5] + col[9:]data_2.rename(col_rename, axis=1, inplace=True)if RNA_probe_suffix_2 == '024':    times_2 = np.arange(0, 4 * 60 + 1, 5)elif RNA_probe_suffix_2 == '043':    times_2 = data_2.Time.to_numpy()num_replicates_2 = 3min_data_2 = np.min(data_2.iloc[0][1:])max_data_2 = np.max(data_2.iloc[-1][1:])all_data_2 = dict()data_mean_2 = dict()data_std_2 = dict()fit_rs_2 = dict()fit_r_errs_2 = dict()fit_preds_2 = dict()all_fit_rs_in_hours_2 = {3: dict(), 5: dict()}all_fit_r_errs_in_hours_2 = {3: dict(), 5: dict()}for well in data_2.columns[1:]:  # Ignore the 'Time' column    if well[-2] != '.':        all_data_2[well] = np.zeros((num_replicates_2, len(times_2)))        all_data_2[well][0, :] = data_2[well]    else:        all_data_2[well[:-2]][int(well[-1]), :] = data_2[well]    for condition in all_data_2.keys():    data_mean_2[condition] = np.mean(all_data_2[condition], 0)    data_std_2[condition] = np.std(all_data_2[condition], 0)        fit_params, covariance, fit_pred = fit_data(        data_mean_2[condition],         fit_type='rb',        xdata=times_2,         min_max_fluorescence={'024':16000, '043': 5000}[RNA_probe_suffix_2],         fluor_max=max_data_2,        )#, yerr=data_std_2[condition])    fit_rs_2[condition] = np.exp(fit_params[0])    fit_r_errs_2[condition] = np.sqrt(np.exp(fit_params[0])**2 * covariance[0, 0])    fit_preds_2[condition] = fit_pred        if 'mut' in condition:        all_fit_rs_in_hours_2[3]['mut'] = fit_rs_2[condition] * 60        all_fit_r_errs_in_hours_2[3]['mut'] = fit_r_errs_2[condition] * 60        all_fit_rs_in_hours_2[5]['mut'] = fit_rs_2[condition] * 60        all_fit_r_errs_in_hours_2[5]['mut'] = fit_r_errs_2[condition] * 60    else:        if '3' in condition:  # 3 & 5 are never in the occluder length, so they always refer to the direction            if condition[1] == 'n':                occ_len = int(condition[:1])            else:                occ_len = int(condition[:2])            all_fit_rs_in_hours_2[3][occ_len] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[3][occ_len] = fit_r_errs_2[condition] * 60        if '5' in condition:  # 3 & 5 are never in the occluder length, so they always refer to the direction            if condition[1] == 'n':                occ_len = int(condition[:1])            else:                occ_len = int(condition[:2])            all_fit_rs_in_hours_2[5][occ_len] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[5][occ_len] = fit_r_errs_2[condition] * 60        if condition == 'No occluder':            all_fit_rs_in_hours_2[3][0] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[3][0] = fit_r_errs_2[condition] * 60            all_fit_rs_in_hours_2[5][0] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[5][0] = fit_r_errs_2[condition] * 60        if condition == 'NTC':            all_fit_rs_in_hours_2[3]['NTC'] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[3]['NTC'] = fit_r_errs_2[condition] * 60            all_fit_rs_in_hours_2[5]['NTC'] = fit_rs_2[condition] * 60            all_fit_r_errs_in_hours_2[5]['NTC'] = fit_r_errs_2[condition] * 60#%% Compare occlusions from either directionnum_nts_occluded_list_2 = [0, 7, 11, 14, 18, 21, 24, 28]x_for_fit = np.linspace(0, max(num_nts_occluded_list), 101)plt.figure()plt.scatter([0], [all_fit_rs_in_hours_2[3]['NTC']],          color=color_dict['NTC'], s=100)plt.plot(x_for_fit,          [all_fit_rs_in_hours_2[3]['NTC']] * len(x_for_fit),          '-',         linewidth=5,         alpha=0.5,         color=color_dict['NTC'])for dir_to_fit in [3, 5]:    for oligo_len in num_nts_occluded_list_2:        plt.plot([oligo_len], [all_fit_rs_in_hours_2[dir_to_fit][oligo_len]],                  {3:'o', 5:'s'}[dir_to_fit],                 color=color_dict[oligo_len], markersize=10, alpha=0.5)    plt.errorbar(num_nts_occluded_list_2,                   [all_fit_rs_in_hours_2[dir_to_fit][i] for i in num_nts_occluded_list_2],                   [all_fit_r_errs_in_hours_2[dir_to_fit][i] for i in num_nts_occluded_list_2],                   ls='none',                  color='k',)    plt.plot([np.inf, np.inf], [np.inf, np.inf],              {3:'o', 5:'s'}[dir_to_fit],             color='k', label=str(dir_to_fit) + "' occluder"             )    if dir_to_fit == 5:        toehold_lengths = [28 - i for i in num_nts_occluded_list_2]    else:        toehold_lengths = [0] * len(num_nts_occluded_list_2)        prediction_type = ['old', 'kstar', 'ku'][2]if prediction_type == 'old':    num_steps_allowed_from_3 = 100    num_extra_steps_allowed_for_5 = 100elif prediction_type == 'kstar':  # Did not fit these properly    num_steps_allowed_from_3 = 400    num_extra_steps_allowed_for_5 = 1200elif prediction_type == 'ku':    num_steps_allowed_from_3 = 33     num_extra_steps_allowed_for_5 = (np.exp(1.7) - 1) * num_steps_allowed_from_3    fe_param = 3.4new_pred = dict()for dir_to_fit in [3, 5]:    new_pred[dir_to_fit] = dict()    for d in num_nts_occluded_list_2:        if prediction_type == 'old':            new_pred[dir_to_fit][d] = 1 if d == 0 else (                np.mean((trials_length[int(d) - 1, :] < num_steps_allowed_from_3 +                          num_extra_steps_allowed_for_5*(dir_to_fit == 3 and d!=28)), -1))        elif prediction_type == 'kstar':            new_pred[dir_to_fit][d] = 1 if d == 0 else (                np.mean(np.exp(-trials_length[int(d) - 1, :] / (                    (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(dir_to_fit == 3 and d!=28)))),                         -1))        elif prediction_type == 'ku':            new_pred[dir_to_fit][d] = 1 if d == 0 else (                1/(1 + np.exp(d / fe_param) / (                    num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(dir_to_fit == 3 and d!=28))))    for dir_to_fit in [3, 5]:    plt.plot(num_nts_occluded_list_2,               [all_fit_rs_in_hours_2[dir_to_fit][0] * new_pred[dir_to_fit][d] for d in num_nts_occluded_list_2],              '--', label=str(dir_to_fit) + "' occluder model",              color={3: 'gray', 5: 'k'}[dir_to_fit])plt.xlabel('Number of nts occluded')plt.ylabel('Activity (h' + r'$^{-1}$' + ')')plt.xticks([0, 7, 14, 21, 28])plt.yscale('log')plt.yticks([1e-2, 1e-1, 1e0, 1e1])plt.ylim([3e-3, 1.2e1])plt.legend()plt.show()#%% Plot predictionsplot_eq = Trueplot_ku = Trueplot_kast = Falseocc_to_fit = 'RNA'num_nts_occluded_list = [0, 7, 11, 14, 18, 21, 24, 28]simulated_trials_success_prob = np.exp(-trials_length / (100/1.4))        plt.figure(figsize=(5.3,4))  # 6,4 is defaultx_for_fit = np.linspace(0, max(num_nts_occluded_list), 101)equil_param = 30.equil_param_better = 44 # 41 for dG_5in_full, 44 for dG_5in_full_approxif plot_eq:    plt.plot(range(28),              fit_rs['NOC'] * 60 * (1 + np.exp(                 -np.array([0] + list(dG_5in_full_approx)) / kBT - equil_param_better))**(-1),               '--', label='Equilibrium',               color=colors[5 if (plot_ku or plot_kast) else 3])strand_displacement_x_data = [0] + list(np.arange(3, 29))if plot_kast:    plt.plot(strand_displacement_x_data,               fit_rs['NOC'] * 60 *               np.array([1.] + [np.mean((simulated_trials_success_prob[int(d) - 1, :]),                       -1) for d in strand_displacement_x_data[1:]]),              '--', label=r'$k^\ast$ model',              color=colors[3])if plot_ku:    plt.plot(strand_displacement_x_data,               fit_rs['NOC'] * 60 *               np.array([1.] + [1/(1 + np.exp(d / 3.4) / 30)                                for d in strand_displacement_x_data[1:]]),              '--',               label=r'$k_u$ model' if plot_kast else 'Strand\ndisplacement',              color=colors[7 if plot_kast else 3],              )plt.scatter([0], [fit_rs['NTC'] * 60],          color=color_dict['NTC'], s=100)plt.plot(x_for_fit,          [fit_rs['NTC'] * 60] * len(x_for_fit),          '-',         linewidth=5,         alpha=0.5,         color=color_dict['NTC'])plt.plot([0], [fit_rs['NOC'] * 60], 'o', color=color_dict[0], markersize=10, alpha=1.)for oligo_len in list(num_nts_occluded_list[1:]):    plt.plot([oligo_len], [fit_rs[str(oligo_len) + 'nt ' + occ_to_fit] * 60], 'o',             color=color_dict[oligo_len], markersize=10, alpha=1.)plt.errorbar(num_nts_occluded_list,               [fit_rs[str(i) + 'nt ' + occ_to_fit] * 60 if i > 0 else fit_rs['NOC'] * 60 for i in num_nts_occluded_list],               [fit_r_errs[str(i) + 'nt ' + occ_to_fit] * 60 if i > 0 else fit_r_errs['NOC'] * 60 for i in num_nts_occluded_list],               ls='none',              color='k',)plt.xlabel('Number of nts occluded')plt.ylabel('Activity (h' + r'$^{-1}$' + ')')plt.yscale('log')plt.ylim([fit_rs['NTC'] * 60 / 2,           fit_rs['NOC'] * 60 * 2])plt.yticks([1e-2, 1e-1, 1e0])plt.xticks([0, 7, 14, 21] + [28] * (occ_to_fit != 'DNA'))if sum([plot_ku, plot_kast, plot_eq])>1:    plt.legend(fontsize=11,                title='Model', title_fontsize=14,               loc=(0.03, 0.2)               )if plot_eq:    plt.annotate('',                   xytext=(14.8, np.exp(-20.134 / kBT + equil_param)),  # tail of arrow                  xy=(17, np.exp(-20.134 / kBT + equil_param)),  # head of arrow                  arrowprops=dict(color=colors[5 if (plot_ku or plot_kast) else 3],                                   shrink=0., width=2, headwidth=12, alpha=0.5),                  )    plt.annotate('',                   xytext=(14.1, np.exp(-20.134 / kBT + equil_param)),  # tail of arrow                  xy=(11.9, np.exp(-20.134 / kBT + equil_param)),  # head of arrow                  arrowprops=dict(color=colors[5 if (plot_ku or plot_kast) else 3],                                   shrink=0., width=2, headwidth=12, alpha=0.5),                  )if plot_ku:    plt.annotate('',                   xytext=(17.2, 0.19),  # tail of arrow                  xy=(18.5, 0.34),  # head of arrow                  arrowprops=dict(color=colors[3], shrink=0., width=2, headwidth=12, alpha=0.5),                  )    plt.annotate('',                   xytext=(16.85, 0.16),  # tail of arrow                  xy=(15.6, 0.09),  # head of arrow                  arrowprops=dict(color=colors[3], shrink=0., width=2, headwidth=12, alpha=0.5),                  )plt.show()#%% Plots for Fig. 2, ED Fig. 2 A-J, ED Fig 3 B-H, ED Fig. 4 B-F, #XXX#%% Load raw dataRNA_probe_suffix = '033' RNA_probe_prefix = '' xl = pd.ExcelFile('RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx')xl.sheet_names# Load the data. # Each of these has 4608 rows = 192 x 24# Each has 98 columns = 480/5 + 1 (for time=0) + 1 (for chamber ID)raw_data_ROX = pd.read_excel(  # The control fluorescence    RNA_probe_prefix + 'RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx',    sheet_name='Raw Data Passive Reference ROX')raw_data_FAM = pd.read_excel(  # The signal fluorescence    RNA_probe_prefix + 'RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx',    sheet_name='Raw Data for Probe SNPtype-FAM')raw_data_ROX_bkgd = pd.read_excel(  # The control fluorescence background    RNA_probe_prefix + 'RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx',    sheet_name='Bkgd Data Passive Reference ROX')raw_data_FAM_bkgd = pd.read_excel(  # The signal fluorescence background    RNA_probe_prefix + 'RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx',    sheet_name='Bkgd Data for Probe SNPtype-FAM')raw_data_FAM_amp = pd.read_excel(  # Unclear what this is    RNA_probe_prefix + 'RNAProbe' + RNA_probe_suffix + '_raw_data.xlsx',    sheet_name='Amplification Curves SNPtypeFAM')for data_name in ['FAM', 'ROX', 'FAM_bkgd', 'ROX_bkgd', 'FAM_amp']:    if data_name == 'FAM':        raw_data_to_plot = raw_data_FAM    elif data_name == 'ROX':        raw_data_to_plot = raw_data_ROX    elif data_name == 'FAM_bkgd':        raw_data_to_plot = raw_data_FAM_bkgd    elif data_name == 'ROX_bkgd':        raw_data_to_plot = raw_data_ROX_bkgd    elif data_name == 'FAM_amp':        raw_data_to_plot_linear = raw_data_FAM_amp        # log since you don't see anything in linear space        raw_data_to_plot = raw_data_to_plot[range(1, 98)].apply(            np.log)        raw_data_to_plot['Chamber ID'] = raw_data_to_plot_linear['Chamber ID']        plt.figure()    for e, i in enumerate([int(i) for i in np.linspace(0, 96, 6) + 1]):        plt.hist(raw_data_to_plot[i], 101, label=i,                  color=colors[e], alpha=0.5)    plt.xlabel('Normalized fluorescence')    plt.ylabel('Frequency')    plt.legend(title='Timepoint')    plt.title(data_name)    plt.show()    if np.all(raw_data_FAM['Chamber ID'] == raw_data_ROX['Chamber ID']):    raw_data_FAM_over_ROX = raw_data_FAM[range(1, 98)] / raw_data_ROX[range(1, 98)]    raw_data_FAM_over_ROX['Chamber ID'] = raw_data_FAM['Chamber ID']    plt.figure()    for e, i in enumerate([int(i) for i in np.linspace(0, 96, 6) + 1]):        plt.hist(raw_data_FAM_over_ROX[i], 101, label=i,                  color=colors[e], alpha=0.5)    plt.xlabel('Normalized fluorescence')    plt.ylabel('Frequency')    plt.legend(title='Timepoint')    plt.title('FAM / ROX')    plt.show()#%% Define functions to change raw data into actual datasample_names = [    '28nt_step01_start67_end94', '28nt_step02_start64_end91', '28nt_step03_start61_end88',     '28nt_step04_start58_end85', '28nt_step05_start55_end82', '28nt_step06_start52_end79',     '28nt_step07_start49_end76', '28nt_step08_start46_end73', '28nt_step09_start43_end70',     '28nt_step10_start40_end67', '28nt_step11_start37_end64', '28nt_step12_start34_end61',    '28nt_step13_start31_end58', '28nt_step14_start28_end55', '28nt_step15_start25_end52',     '28nt_step16_start22_end49', '28nt_step17_start19_end46', '28nt_step18_start16_end43',     '28nt_step19_start13_end40', '28nt_step20_start10_end37', '28nt_step21_start07_end34',     '28nt_step22_start04_end31', '28nt_step23_start01_end28', 'NOC__step99_start99_end99',    '21nt_step01_start75_end95', '21nt_step02_start72_end92', '21nt_step03_start69_end89',     '21nt_step04_start66_end86', '21nt_step05_start63_end83', '21nt_step06_start60_end80',     '21nt_step07_start57_end77', '21nt_step08_start54_end74', '21nt_step09_start51_end71',     '21nt_step10_start48_end68', '21nt_step11_start45_end65', '21nt_step12_start42_end62',    '21nt_step13_start39_end59', '21nt_step14_start36_end56', '21nt_step15_start33_end53',     '21nt_step16_start30_end50', '21nt_step17_start27_end47', '21nt_step18_start24_end44',     '21nt_step19_start21_end41', '21nt_step20_start18_end38', '21nt_step21_start15_end35',     '21nt_step22_start12_end32', '21nt_step23_start09_end29', '21nt_step24_start06_end26',    '14nt_step01_start79_end92', '14nt_step02_start76_end89', '14nt_step03_start73_end86',     '14nt_step04_start70_end83', '14nt_step05_start67_end80', '14nt_step06_start64_end77',     '14nt_step07_start61_end74', '14nt_step08_start58_end71', '14nt_step09_start55_end68',     '14nt_step10_start52_end65', '14nt_step11_start49_end62', '14nt_step12_start46_end59',    '14nt_step13_start43_end56', '14nt_step14_start40_end53', '14nt_step15_start37_end50',     '14nt_step16_start34_end47', '14nt_step17_start31_end44', '14nt_step18_start28_end41',     '14nt_step19_start25_end38', '14nt_step20_start22_end35', '14nt_step21_start19_end32',     '14nt_step22_start16_end29', '14nt_step23_start13_end26', '14nt_step24_start10_end23',    '10nt_step01_start68_end77', '10nt_step02_start65_end74', '10nt_step03_start62_end71',     '10nt_step04_start59_end68', '10nt_step05_start56_end65', '10nt_step06_start53_end62',     '10nt_step07_start50_end59', '10nt_step08_start47_end56', '10nt_step09_start44_end53',     '10nt_step10_start41_end50', '10nt_step11_start38_end47', '10nt_step12_start35_end44',    '10nt_step13_start32_end41', '10nt_step14_start29_end38', '10nt_step15_start26_end35',     '10nt_step16_start23_end32', '10nt_step17_start20_end29', '10nt_step18_start17_end26',     '14nt_step25_start07_end20', '14nt_step26_start04_end17', '21nt_step25_start03_end23',     '21nt_step26_start00_end20', 'NOC__step99_start99_end99', 'NOC__step99_start99_end99']     # step99 etc is just filler text for the no occluder controls    sample_names_dict = {}for i in range(len(sample_names) * 2):    which_target = (i % 24) >= 12    which_sample_name = (i%12) + 12 * ((i - 12*which_target) // 24)        target_names = ['Tar1_', 'Tar2_']    sample_names_dict['S' + "{:03d}".format(i+1)] = target_names[which_target] + sample_names[which_sample_name]    sample_names_dict_inv = {v: k for k, v in sample_names_dict.items()}assay_names = [    'crRNA1, r1', 'crRNA5, r1','crRNA9, r1','crRNA1, r2','crRNA5, r2', 'crRNA9, r2',    'crRNA2, r1','crRNA6, r1','crRNA10, r1','crRNA2, r2','crRNA6, r2','crRNA10, r2',    'crRNA3, r1','crRNA7, r1','crRNA_rand, r1','crRNA3, r2','crRNA7, r2','crRNA_rand, r2',    'crRNA4, r1','crRNA8, r1','NPC, r1','crRNA4, r2','crRNA8, r2','NPC, r2']  # NPC = no probe controlassay_names_dict = {}for i in range(len(assay_names)):    assay_names_dict['A' + "{:02d}".format(i+1)] = assay_names[i]assay_names_dict_inv = {v: k for k, v in assay_names_dict.items()}# Break up Chamber ID into 'Assay_ID', 'Sample_ID', 'Assay', 'Sample'def name_data(df):    df_named_dict = {        'Assay_ID': df['Chamber ID'].map(lambda x: x[-3:]),        'Sample_ID': df['Chamber ID'].map(lambda x: x[:-4])        }    named_df = pd.DataFrame(df_named_dict)    named_df['Assay'] = named_df['Assay_ID'].map(lambda x: assay_names_dict[x])    named_df['Sample'] = named_df['Sample_ID'].map(lambda x: sample_names_dict[x])        for e, i in enumerate(times):        named_df[i] = df[e + 1]            return(named_df)#%% Normalize data and save it# Check that all Chamber IDs are in the same order so this is fine:if (raw_data_FAM['Chamber ID'].equals(raw_data_FAM_bkgd['Chamber ID']) and     raw_data_FAM['Chamber ID'].equals(raw_data_ROX['Chamber ID']) and    raw_data_FAM['Chamber ID'].equals(raw_data_ROX_bkgd['Chamber ID'])):    print('True: all Chamber IDs are in the right order')    plt.figure()    for e, i in enumerate([int(i) for i in np.linspace(0, 96, 6) + 1]):        plt.plot(raw_data_ROX[e+1] - raw_data_ROX_bkgd[e+1],                  raw_data_FAM[e+1] - raw_data_FAM_bkgd[e+1], '.', label=i, alpha=0.1)    plt.xlabel('ROX - ROX_bkgd')    plt.ylabel('FAM - FAM_bkgd')    plt.show()        normalized_FAM = (        raw_data_FAM[range(1, 98)]        - raw_data_FAM_bkgd[range(1, 98)]        ) / (        raw_data_ROX[range(1, 98)]         - raw_data_ROX_bkgd[range(1, 98)]        )    normalized_FAM['Chamber ID'] = raw_data_FAM['Chamber ID']    normalized_FAM_named = name_data(normalized_FAM)    save_df = False    if save_df:        normalized_FAM_named.to_csv(            'RNAProbe' + RNA_probe_suffix + '_named.txt', index=False, sep="\t")else:     print("ERROR IN NORMALIZING DATA")#%% Load normalized datadata = pd.read_csv('RNAProbe' + RNA_probe_suffix + '_named.txt',                   delimiter='\t')assays = np.unique(data.Assay)  # Assays are the different crRNAs# NPC = no crRNA control; crRNA1-10 are targets; crRNA_rand has no target# r1 = replicate 1; r2 = replicate 2samples = np.unique(data.Sample)  # Samples are the different occluders# target1 and target2 are the two different shuffles of the target order# NOC is labeled as occluding nts 99-99 (Just arbitrarily)# Example of how to read:    #5' UCAAACCAUACAUAUAACACUCUUUAUUCUCCUUAACUUUUCAA...  3' is an RNA target    # 10nt_step18_start20_end29 corresponds to the oligo that's complementary to     # 5' UCUUUAUUCU 3' . Meaning that the oligo itself is 5' AGAAUAAAGA 3'. # Some "starts" are at 0 meaning that they start at the first nucleotide. # ie nt index is 0-indexed.#%% Add columns to clear up dataframedef get_occlusion_length(sample_name):    occLen = sample_name[5:7]    if occLen == 'NO':        return(0)    else:        return(int(occLen))data['crRNA'] = data.Assay.map(lambda x: x[:-4])data['replicate'] = data.Assay.map(lambda x: int(x[-1]))data['targetOrder'] = data.Sample.map(lambda x: int(x[3]))  # which shuffle of targetsdata['occLength'] = data.Sample.map(get_occlusion_length)data['step'] = data.Sample.map(lambda x: int(x[14:16]))data['start'] = data.Sample.map(lambda x: int(x[22:24]))data['end'] = data.Sample.map(lambda x: int(x[28:30]))data_as_numpy = data[times_str].to_numpy()data_as_list = [data_as_numpy[i] for i in range(data_as_numpy.shape[0])]data['timeSeries'] = data_as_liststarts_per_occ = dict()for occ in occlusions:    starts_per_occ[occ] = np.unique(data[data['occLength'] == occ].start)crRNAs = np.unique(data['crRNA'])#%% Define function to fit datadef fit_data(time_series, fit_type='rab', xdata=times_float):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    def fit_fxn_exp_rs(t, log_r, start_time):         a = np.min(data['0'])        b = np.max(data['480'])        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = np.min(data['0'])        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))            min_max_fluorescence = 0.4         if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, np.max(data['480'])]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, np.max(data['480'])])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, np.min(data['0']), np.max(data['480'])]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, np.max(data['480'])])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, np.max(data['480'])]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, np.max(data['480'])])        # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        #sigma=?        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)#%% Add fits to the dataframelen_data_to_fit = 50fit_type = 'rb'data['fitParams'] = data.timeSeries.map(lambda x: fit_data(    x[:len_data_to_fit], fit_type=fit_type, xdata=times_float[:len_data_to_fit])[0])data['covariance'] = data.timeSeries.map(lambda x: fit_data(    x[:len_data_to_fit], fit_type=fit_type, xdata=times_float[:len_data_to_fit])[1])data['fitPred'] = data.timeSeries.map(lambda x: fit_data(    x[:len_data_to_fit], fit_type=fit_type, xdata=times_float[:len_data_to_fit])[2])def get_r(fit_params):    return(np.exp(fit_params[0]))_ = get_r([0.])data['rFit'] = data.apply(lambda x: get_r(fit_params=x['fitParams']), axis=1)def get_r_err(fit_params, cov):    return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]))_ = get_r_err([0.], np.array([[0,0],[0,0]]))data['rFitErr'] = data.apply(lambda x: get_r_err(    fit_params=x['fitParams'], cov=x['covariance']), axis=1)#%% Normalize the speed of reporter cleavage by the controls, to account for variation in concentrations within each chamberr_assayID_map = dict()  # for each assay_id, gives the fitted r value for sample S192# For each Sample_ID, get the ratio of r fit for that sample ID to r fit to the no-occluder controls. # Ordinarily, these would be 'S036', 'S048', 'S179', 'S180', 'S191', 'S192'# But for crRNA1 & crRNA10, all samples are no-occluder controlsplt.figure()for e_assay, assay_id in enumerate([i for i in assay_names_dict.keys() if assay_names_dict[i][:6] == 'crRNA1']):    # no_occ_assay_data = data[(data['Assay_ID'] == assay_id)# & (data['occLength'] == 0)]    no_occ_assay_timeseries = data[(data['Assay_ID'] == assay_id)# & (data['occLength'] == 0)                                   ].timeSeries.to_numpy()    mean_no_occ_assay = np.mean(no_occ_assay_timeseries)    # Fitting again on mean of data appears to give very similar results to taking mean of fits    fit_params_no_occ_assay, cov_no_occ_assay, fit_pred_no_occ_assay = fit_data(        mean_no_occ_assay[:len_data_to_fit], fit_type=fit_type, xdata=times_float[:len_data_to_fit])    r_assayID_map[assay_id] = np.exp(fit_params_no_occ_assay[0])        for e, timeseries in enumerate(no_occ_assay_timeseries):        plt.plot(times_float, timeseries,                  color=colors[e_assay+1],                 label=assay_names_dict[assay_id] * (e==0),                 alpha=0.01 * (1 + 10 *('10' in assay_names_dict[assay_id])),                 zorder=np.random.random())#, color=colors[e])    plt.plot(times_float[:len_data_to_fit], fit_pred_no_occ_assay, color='k', linestyle='--')for e_assay, assay_id in enumerate(['A21', 'A24']):    no_crRNA_neg_control_timeseries = data[(data['Assay_ID'] == assay_id)# & (data['occLength'] == 0)                                   ].timeSeries.to_numpy()    for e, timeseries in enumerate(no_crRNA_neg_control_timeseries):        plt.plot(times_float, timeseries,                  color=gray_colors[e_assay],                 label=('No crRNA r' + str(e_assay + 1)) * (e==0),                 alpha=0.01,                 zorder=np.random.random())plt.xlabel('Time (min)')#plt.title('No occlusion controls')leg = plt.legend(bbox_to_anchor=(1.05, 1))for legobj in leg.legendHandles:    legobj.set_alpha(1)plt.show()    # r_ratio is only defined for the positive controls. It is the ratio of each r value (i.e. for each sampleID)# to the mean across all sampleIDs. def get_r_ratio(fit_params, assay_id):    if assay_id in r_assayID_map.keys():        return(np.exp(fit_params[0]) / r_assayID_map[assay_id])      return(1.)data['rRatio'] = data.apply(lambda x: get_r_ratio(    fit_params = x['fitParams'], assay_id = x['Assay_ID']),     axis=1)def get_r_ratio_err(fit_params, cov, assay_id):    if assay_id in r_assayID_map.keys():        return(get_r_err(fit_params, cov) / r_assayID_map[assay_id])    # cov_no_occ_assay doesn't matter since we're just normalizing by some number    return(0.)data['rRatioErr'] = data.apply(lambda x: get_r_ratio_err(    fit_params = x['fitParams'], cov=x['covariance'], assay_id = x['Assay_ID']),     axis=1)# Now, to account for variation in target concentrations, take each r value and normalize it# by the mean of rRatio across the 4 positive controls.norm_r_mean_sampleID_map = dict()  # for each sampleID, gives the mean of the crRNA1 and crRNA10 values, for use in normalizationnorm_r_std_sampleID_map = dict()  # gives the std of the values we normalize by, to tell how robust this normalization isfor sample_id in np.unique(data.Sample_ID):    data_to_normalize_by = []    for crRNA_to_norm in ['crRNA1', 'crRNA10']:        for replicate_to_norm in [1, 2]:            data_to_normalize_by += [data[                (data['Sample_ID'] == sample_id) &                 (data['crRNA'] == crRNA_to_norm) &                 (data['replicate'] == replicate_to_norm)                ].rRatio]              # needs to be rRatio that we normalize by, rather than r, since r is quite different for crRNA1 & crRNA10    norm_r_mean_sampleID_map[sample_id] = np.mean(data_to_normalize_by)    norm_r_std_sampleID_map[sample_id] = np.std(data_to_normalize_by)plt.figure()plt.hist([norm_r_std_sampleID_map[sample_id] / norm_r_mean_sampleID_map[sample_id]           for sample_id in norm_r_std_sampleID_map])plt.xlabel('std / mean of normalization terms')plt.ylabel('Counts')plt.show()def get_r_norm(fit_params, sample_id):    return(np.exp(fit_params[0]) / norm_r_mean_sampleID_map[sample_id])data['rNorm'] = data.apply(lambda x: get_r_norm(    fit_params = x['fitParams'], sample_id = x['Sample_ID']),     axis=1)  # This value captures that different crRNAs are more or less activated, while normalizing the result # such that slightly different experimental conditions (e.g. chamber concentrations) are accounted fordef get_r_norm_err(fit_params, cov, sample_id):    return(get_r_err(fit_params, cov) / norm_r_mean_sampleID_map[sample_id])data['rNormErr'] = data.apply(lambda x: get_r_norm_err(    fit_params = x['fitParams'], cov=x['covariance'], sample_id = x['Sample_ID']),     axis=1)  # Show how controls change after correctionplt.figure()jitter = 0.2data_pos = [0, 1, 3, 4, 6, 7, 9, 10]for e_v, datapoints in enumerate([data[(data.Assay_ID == 'A01') | (data.Assay_ID == 'A04')].rFit,                                  data[(data.Assay_ID == 'A01') | (data.Assay_ID == 'A04')].rNorm,                                  data[(data.Assay_ID == 'A09') | (data.Assay_ID == 'A09')].rFit,                                  data[(data.Assay_ID == 'A12') | (data.Assay_ID == 'A12')].rNorm,                                  # data[(data.Assay_ID == 'A21') | (data.Assay_ID == 'A24')].rFit,                                  # data[(data.Assay_ID == 'A21') | (data.Assay_ID == 'A24')].rNorm                                  ]):    for d in datapoints:        plt.scatter(np.array([data_pos[e_v]])                    + (np.random.random() * jitter*2) - jitter                    ,                     d / np.mean(datapoints),                     # marker=['o', 's'][e_v%2],                    color=[colors[4], colors[1]][e_v%2], #colors[2 * (e_v//2)],                     s=20,                     alpha=0.2,                    )for i in range(2):    plt.plot([np.inf]*2, [np.inf]*2,            color=[colors[4], colors[1]][i],#'k',            marker='o', #['o', 's'][i],            markersize=10,            linestyle='',            label=['Uncorrected', 'Corrected'][i],            # alpha=0.5            )plt.legend()plt.ylabel('Activity spread')# plt.yscale('log')plt.xticks([0.5, 3.5#, 6.5            ], ['crRNA1', 'crRNA10'#, 'No crRNA'                ])plt.show()for e_control_data, control_data_to_plot in enumerate(        [data[(data.Assay_ID == 'A01') | (data.Assay_ID == 'A04')],          data[(data.Assay_ID == 'A09') | (data.Assay_ID == 'A12')]]):    plt.figure()    rFit_data = control_data_to_plot.rFit * 60    rNorm_data = control_data_to_plot.rNorm * 60    max_rFit = np.max(rFit_data)    min_rFit = np.min(rFit_data)    delta_rFit = (max_rFit - min_rFit) / 20    control_data_bins = np.linspace(min_rFit - delta_rFit, np.max(rFit_data) + 2 * delta_rFit, 21)        control_activity_log10 = [1, 2][e_control_data]    print(np.std(rFit_data))    plt.hist(rFit_data, bins=control_data_bins, color=colors[4], alpha=0.5,             label=('Uncorrected\n' + r'$\sigma =$' +                     str(np.round(np.std(rFit_data) * 10**control_activity_log10, 1)) +                     r'$\times 10^{{-{:1n}}}$'.format(control_activity_log10) +                     ' hr' + r'$^{-1}$'))    plt.hist(rNorm_data, bins=control_data_bins, color=colors[1], alpha=0.5,             label=('Corrected\n' + r'$\sigma =$' +                     str(np.round(np.std(rNorm_data) * 10**control_activity_log10, 1)) +                     r'$\times 10^{{-{:1n}}}$'.format(control_activity_log10) +                     ' hr' + r'$^{-1}$'))    plt.xlabel('Activity (hr' + r'$^{-1}$' + ')')    plt.ylabel('Count')    plt.title(['crRNA1', 'crRNA10'][e_control_data])    plt.legend(fontsize=12)    plt.show()# Plot the 2 technical replicates against one anotherplt.figure()for key in assay_names_dict_inv.keys():    if key[-1] == '1':        other_rep_assay_id = assay_names_dict_inv[key[:-1] + '2']        data_to_plot_rep_1 = data[(data.Assay_ID == assay_names_dict_inv[key])]        data_to_plot_rep_2 = data[(data.Assay_ID == other_rep_assay_id)]        for sample_id in sample_names_dict.keys():            plt.plot(data_to_plot_rep_1[(data_to_plot_rep_1.Sample_ID == sample_id)].rFit * 60,                     data_to_plot_rep_2[(data_to_plot_rep_2.Sample_ID == sample_id)].rFit * 60,                     '.',                     alpha=1., #0.1,                     color='k')plt.plot([1e-2, 1e1], [1e-2, 1e1], color='gray', linestyle='--', linewidth=3, zorder=-1000)plt.xlabel('Replicate 1 activity (hr' + r'$^{-1}$' + ')')plt.ylabel('Replicate 2 activity (hr' + r'$^{-1}$' + ')')plt.xscale('log')plt.yscale('log')plt.show()plt.figure()for e_control_data, (control_data_to_plot1, control_data_to_plot10) in enumerate(        [[data[(data.Assay_ID == 'A01')], data[(data.Assay_ID == 'A09')]],          [data[(data.Assay_ID == 'A01')], data[(data.Assay_ID == 'A12')]]]):    for sample_id in sample_names_dict.keys():            plt.plot(control_data_to_plot1[(control_data_to_plot1.Sample_ID == sample_id)].rFit * 60,                     control_data_to_plot10[(control_data_to_plot10.Sample_ID == sample_id)].rFit * 60,                     '.',                     alpha=1., #0.1,                     color=colors[4],                      label='Uncorrected' * (sample_id=='S192' and e_control_data==0))            plt.plot(control_data_to_plot1[(control_data_to_plot1.Sample_ID == sample_id)].rNorm * 60,                     control_data_to_plot10[(control_data_to_plot10.Sample_ID == sample_id)].rNorm * 60,                     '.',                     alpha=1., #0.1,                     color=colors[1],                     label='Corrected' * (sample_id=='S192' and e_control_data==0))plt.xlabel('crRNA1 activity (hr' + r'$^{-1}$' + ')')plt.ylabel('crRNA10 activity (hr' + r'$^{-1}$' + ')')plt.legend()plt.show()# We can also take these normalized r values and further normalize each to the 0-occlusion data of the individual crRNAdef get_mean_no_occ(assay_id):    no_occ_assay_rNorms = data[(data['Assay_ID'] == assay_id) & (data['occLength'] == 0)                                   ].rNorm.to_numpy()    mean_no_occ_assay = np.exp(np.mean(np.log(no_occ_assay_rNorms)))    return(mean_no_occ_assay)def get_mean_no_occ_no_norm(assay_id):    no_occ_assay_rs = data[(data['Assay_ID'] == assay_id) & (data['occLength'] == 0)                                   ].rFit.to_numpy()    mean_no_occ_assay = np.exp(np.mean(np.log(no_occ_assay_rs)))    return(mean_no_occ_assay)def get_r_ratio_norm(rNorm, assay_id#, sample_id                     ):  # the ratio of r to the 0-occlusion instances of that crRNA    mean_no_occ_assay = get_mean_no_occ(assay_id)    return(rNorm / mean_no_occ_assay)data['rRatioNorm'] = data.apply(lambda x: get_r_ratio_norm(    rNorm = x['rNorm'], assay_id=x['Assay_ID']#, sample_id = x['Sample_ID']    ), axis=1)def get_r_ratio_norm_err(rNormErr, assay_id#, sample_id                     ):  # the ratio of r to the 0-occlusion instances of that crRNA        mean_no_occ_assay = get_mean_no_occ(assay_id)    return(rNormErr / mean_no_occ_assay)data['rRatioNormErr'] = data.apply(lambda x: get_r_ratio_norm_err(    rNormErr = x['rNormErr'], assay_id=x['Assay_ID']#, sample_id = x['Sample_ID']    ), axis=1)# Correlate target order 1 & 2target_order_ratio_uncorrected = []target_order_ratio_corrected = []target_order_1_rFits = []target_order_2_rFits = []target_order_1_rNorms = []target_order_2_rNorms = []for sample_name in sample_names_dict_inv.keys():    if sample_name[3] == '1':        other_order_sample_id = sample_names_dict_inv['Tar2' + sample_name[4:]]        data_to_plot_order_1 = data[(data.Sample_ID == sample_names_dict_inv[sample_name])]        data_to_plot_order_2 = data[(data.Sample_ID == other_order_sample_id)]        for assay_id in assay_names_dict.keys():            rFit1 = float(data_to_plot_order_1[(data_to_plot_order_1.Assay_ID == assay_id)].rFit)            rFit2 = float(data_to_plot_order_2[(data_to_plot_order_2.Assay_ID == assay_id)].rFit)            rNorm1 = float(data_to_plot_order_1[(data_to_plot_order_1.Assay_ID == assay_id)].rNorm)            rNorm2 = float(data_to_plot_order_2[(data_to_plot_order_2.Assay_ID == assay_id)].rNorm)            target_order_1_rFits += [rFit1 * 60]            target_order_2_rFits += [rFit2 * 60]            target_order_1_rNorms += [rNorm1 * 60]            target_order_2_rNorms += [rNorm2 * 60]            if assay_names_dict[assay_id] not in ['crRNA_rand, r1', 'crRNA_rand, r2', 'NPC, r1', 'NPC, r2']:                target_order_ratio_uncorrected += [rFit1 / rFit2]                target_order_ratio_corrected += [rNorm1 / rNorm2]plt.figure()for e, (target_order_1_data, target_order_2_data) in enumerate(        [[target_order_1_rFits, target_order_2_rFits],         [target_order_1_rNorms, target_order_2_rNorms]]):    if e == 0:        plt.plot(target_order_1_data, target_order_2_data,                  '.',                  alpha=0.14,                  color=colors[4],                   label='Uncorrected' * (assay_id=='A24' and other_order_sample_id == 'S190'))    if e == 1:        plt.plot(target_order_1_data, target_order_2_data,                  '.',                  alpha=0.07,                  color=colors[1],                   label='Corrected' * (assay_id=='A24' and other_order_sample_id == 'S190'))plt.plot([1e-2, 1e1], [1e-2, 1e1], color='gray', linestyle='--', linewidth=3, zorder=-1000)plt.xlabel('Target order 1 activity (hr' + r'$^{-1}$' + ')')plt.ylabel('Target order 2 activity (hr' + r'$^{-1}$' + ')')plt.xscale('log')plt.yscale('log')leg = plt.legend()for legobj in leg.legendHandles:    legobj.set_alpha(1)    legobj.set_markersize(10)plt.show()plt.figure()delta_rFit = (max(target_order_ratio_uncorrected) - min(target_order_ratio_uncorrected)              ) / 20order_data_bins = np.linspace(min(target_order_ratio_uncorrected) - delta_rFit,                               max(target_order_ratio_uncorrected) + 2 * delta_rFit,                               21)control_activity_log10 = 1plt.hist(target_order_ratio_uncorrected, bins=order_data_bins, color=colors[4], alpha=0.5,         label=('Uncorrected\n' + r'$\sigma =$' +                 str(np.round(np.std(target_order_ratio_uncorrected) * 10**control_activity_log10, 1)) +                 r'$\times 10^{{-{:1n}}}$'.format(control_activity_log10)))control_activity_log10 = 2plt.hist(target_order_ratio_corrected, bins=order_data_bins, color=colors[1], alpha=0.5,         label=('Corrected\n' + r'$\sigma =$' +                 str(np.round(np.std(target_order_ratio_corrected) * 10**control_activity_log10, 1)) +                 r'$\times 10^{{-{:1n}}}$'.format(control_activity_log10)))plt.xlabel('Ratio of target order activities')plt.ylabel('Count')plt.legend()plt.show()#%%# Add sequence informationdef get_seq(crRNA):    if crRNA == 'crRNA1':        seq = 'ACUCACAAUAAAUCUCACCAUUAAUUUCCAUCUCUCUUCUCCAAUAUAUCCUUCAUCCUAAUAUUCAAUUUUCCAUUCUUACAACUAAAACAUUCA'    elif crRNA == 'crRNA2':        seq = 'CACUCAUCUAACAAAUACCUUCAACUACUAUUUCUCCCUUCUAAACAUCUAAAUCUGCUUCCUCUCAUAUAUCACAUUAUUAAUCCUCACCAACCU'    elif crRNA == 'crRNA3':        seq = 'AAUACUUCAUCACUACAAUCACUUCUACACCAUUUCAUAUCUCUACCUUAUAAUAACCUCACUAUACUCACUUUCACAAACAAUCCUAUACAACAU'    elif crRNA == 'crRNA4':        seq = 'CAAUCUCUAAACCUCUCCAUCAAAUAUCUCACACGUUGCCAUCAAAGAACUCCCCACACAUGAUCAAAAUUAACCUAUUAUUCAACACCUUUCCUC'    elif crRNA == 'crRNA5':        seq = 'CUAUAAACCUCAAUUUCCACAUUUCACUACAUUUUCUCAAACCUACUAAUUAUUCUACUAAUCUUUCCAAACACCUAAUCACCUAAAUCACACCUU'    elif crRNA == 'crRNA6':        seq = 'CUUAUAUCCAACCAAUCAUAAAACAACUCAUACUGUCACCGCCUAGAUCACCCAACCGAAUGUUUCACCAAGUUUACUCUACUCCACACUAUCCUU'    elif crRNA == 'crRNA7':        seq = 'AAACACAAUUAUCAACUCUCAUUUUCUUCUUUUCCAACAUUCAUACAAUUCAUUCCUUUUAUCCAUUCACCUACACUUAAUACUUACCUCUCUAUU'    elif crRNA == 'crRNA8':        seq = 'UCAAACCAUACAUAUAACACUCUUUAUUCUCCUUAACUUUUCAACAGCACGCCAAAUCCAGUCACUCCAACUUUCUUAUCCACAAAAUCUUCUUCU'    elif crRNA == 'crRNA9':        seq = 'AACUACUUAUUCCUCAUUCUUUGACAUAUCCAAUUUAAAACAAGCCCACCUCUCGAGACACACUUACUAACCAUCAACCAAACUAACAUAUCAACA'    elif crRNA == 'crRNA10':        seq = 'CUAAUAACACACUCUUCCAUAUUAACCACAUACUACUCCAUUUACUAUAUUACCAUCCACUCUUAUCAUCUACCUCACACCAUAAUUCCUAUAACA'    else:        seq = 'O' * 96    return(seq)data['seq'] = data.apply(lambda x: get_seq(    crRNA = x['crRNA']),     axis=1)  #%% Add information about TMSD to fit TMSD model later (specifically, get d & h for each oligo)def get_displacement_length(occ_len, occ_start):    return(np.sum([i in range(34, 34 + 28) for i in range(occ_start, occ_start + occ_len)]))data['dispLen'] = data.apply(lambda x: get_displacement_length(    occ_len = x['occLength'], occ_start = x['start']),     axis=1)  def get_displacement_lengthM65p(occ_len, occ_start):    return(np.sum([i in range(40, 34 + 28) for i in range(occ_start, occ_start + occ_len)]))data['dispLenM65p'] = data.apply(lambda x: get_displacement_lengthM65p(    occ_len = x['occLength'], occ_start = x['start']),     axis=1)  def get_displacement_length_CG(occ_len, occ_start, seq):    return(np.sum([(i in range(34, 34 + 28)) and (seq[i] in ['C', 'G'])                    for i in range(occ_start, occ_start + occ_len)]))data['dispLen_CG'] = data.apply(lambda x: get_displacement_length_CG(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_displacement_length_AU(occ_len, occ_start, seq):    return(np.sum([(i in range(34, 34 + 28)) and (seq[i] in ['A', 'U'])                     for i in range(occ_start, occ_start + occ_len)]))data['dispLen_AU'] = data.apply(lambda x: get_displacement_length_AU(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_toehold_length(occ_len, occ_start):    toehold_start = 34 + 28    occ_end = occ_start + occ_len    if occ_end > toehold_start:        return(0.)    if occ_end < 34:        return(28.)    return(toehold_start - occ_end)data['toeholdLen'] = data.apply(lambda x: get_toehold_length(    occ_len = x['occLength'], occ_start = x['start']),     axis=1)  def get_toehold_length_CG(occ_len, occ_start, seq):    toehold_start = 34 + 28    occ_end = occ_start + occ_len    return(np.sum([seq[i] in ['C', 'G']                    for i in range(occ_end, toehold_start)]))data['toeholdLen_CG'] = data.apply(lambda x: get_toehold_length_CG(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_toehold_length_AU(occ_len, occ_start, seq):    toehold_start = 34 + 28    occ_end = occ_start + occ_len    return(np.sum([seq[i] in ['A', 'U']                    for i in range(occ_end, toehold_start)]))data['toeholdLen_AU'] = data.apply(lambda x: get_toehold_length_AU(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_toehold_length_other_end(occ_len, occ_start):  # we don't actually think Cas13 binds on this end    toehold_start = 34.    if occ_start < toehold_start:        return(0.)    if occ_start > 34 + 28:        return(28.)    return(occ_start - toehold_start)data['toeholdLenOtherEnd'] = data.apply(lambda x: get_toehold_length_other_end(    occ_len = x['occLength'], occ_start = x['start']),     axis=1)  def get_occ_toehold_length(occ_len, occ_start):    if occ_start + occ_len <= 34:        return(0.)    if occ_start > 34.:        return(0.)    return(34. - occ_start)data['occToeholdLen'] = data.apply(lambda x: get_occ_toehold_length(    occ_len = x['occLength'], occ_start = x['start']),     axis=1)  def get_occ_toehold_length_CG(occ_len, occ_start, seq):    if occ_start + occ_len <= 34:        return(0.)    if occ_start > 34.:        return(0.)    return(np.sum([seq[i] in ['C', 'G']                    for i in range(occ_start, 34)]))data['occToeholdLen_CG'] = data.apply(lambda x: get_occ_toehold_length_CG(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_occ_toehold_length_AU(occ_len, occ_start, seq):    if occ_start + occ_len <= 34:        return(0.)    if occ_start > 34.:        return(0.)    return(np.sum([seq[i] in ['A', 'U']                    for i in range(occ_start, 34)]))data['occToeholdLen_AU'] = data.apply(lambda x: get_occ_toehold_length_AU(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_seq_at_tmsd_start(occ_len, occ_start, seq):    if occ_start + occ_len <= 34:        return('O')    elif occ_start + occ_len > 34 + 28:        return(seq[34 + 28])    else:        return(seq[occ_start + occ_len])data['seqTMSDStart'] = data.apply(lambda x: get_seq_at_tmsd_start(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)  def get_seq_at_tmsd_end(occ_len, occ_start, seq):    if occ_start + occ_len <= 34:        return('O')    elif occ_start > 34 + 28:        return('O')    elif occ_start > 34:        return(seq[occ_start])    else:        return(seq[34])data['seqTMSDEnd'] = data.apply(lambda x: get_seq_at_tmsd_end(    occ_len = x['occLength'], occ_start = x['start'], seq=x['seq']),     axis=1)#%% Plot data overviewplt.figure(figsize=(4,6))for e_o, occ_length in enumerate([10, 14, 21, 28][::-1]):    for e_s, start in enumerate(starts_per_occ[occ_length]):        for crRNA in ['crRNA' + str(i) for i in range(2, 10)]:  # to remove the controls            data_subset = data[                (data['occLength'] == occ_length) &                 (data['start'] == start) &                 (data['crRNA'] == crRNA)                ].rRatioNorm                plt.plot([start - 34] * len(data_subset), data_subset, 'o', color=colors[range(1, 5)[::-1][e_o]],                     markersize=4, alpha=0.6)    for e_o, occ_length in enumerate([10, 14, 21, 28]):    plt.plot([np.inf]*2, [np.inf]*2, 'o', color=colors[range(1,5)[e_o]], label=occ_length,              zorder = 100 * (4-e_o), markersize=8)        plt.plot([0,0], [0,2.4], '--', color='gray')plt.plot([28]*2, [0,2.4], '--k', color='gray')plt.xlabel('Occluder start relative to protospacer (nt)', fontsize=16)plt.ylabel('Normalized activity', fontsize=17)plt.tick_params(axis='both', labelsize=16) # Set tick labels font size to 8plt.yscale('log')plt.gca().set_ylim(top=2.4)plt.xticks([-28, -14, 0, 14, 28, 42])plt.legend(bbox_to_anchor=(1.05, 1), title='Occlusion\nlength (nt)', fontsize=15, title_fontsize=14)plt.show()#%% Plot negative controlsplt.figure()for e_c, crRNA in enumerate(['NPC', 'crRNA_rand']):    for e_o, occ_length in enumerate([10, 14, 21, 28]):        for e_s, start in enumerate(starts_per_occ[occ_length]):            data_subset = data[                (data['start'] == start) &                 (data['crRNA'] == crRNA) &                 (data['occLength'] == occ_length)                ].rNorm                    plt.plot([start - 34] * len(data_subset), data_subset * 60, 'o',                      color=['k', 'gray'][e_c],                     marker=['o', 's', '^', '*'][e_o],                     markersize=4, alpha=0.6)    occ_legend = []for e_o, occ_length in enumerate([10, 14, 21, 28]):    occ_legend_item, = plt.plot([np.inf]*2, [np.inf]*2, 'k', linestyle='',                                 marker=['o', 's', '^', '*'][e_o], label=occ_length)    occ_legend += [occ_legend_item]    legend_2 = plt.gca().legend(handles=occ_legend, bbox_to_anchor=(0.815,0.58),                             title='Occlusion\nlength (nt)', fontsize=9, title_fontsize=9)plt.gca().add_artist(legend_2)plt.xlabel('Occluder start relative to protospacer (nt)', fontsize=16)plt.ylabel('Activity (h' + r'$^{-1}$' + ')', fontsize=17)plt.tick_params(axis='both', labelsize=16) # Set tick labels font size to 8plt.xticks([-28, -14, 0, 14, 28, 42])legend_1_labels = []for e_c, crRNA in enumerate(['NPC', 'crRNA_rand']):    legend_1_labels += [mpatches.Patch(color=['k', 'gray'][e_c],                  label=['No crRNA', 'Random crRNA'][e_c])]legend_1 = plt.legend(handles=legend_1_labels, bbox_to_anchor=(0.4, 0.8), fontsize=10)plt.gca().add_artist(legend_1)plt.show()        #%%plot_data = Falseplot_fit = True  # only applies if plot_data=Trueplot_rs = Falseplot_r_ratios = Falseplot_norm_r_ratios = Falseplot_norm_r_ratios_allRepsAndOrders = Falseplot_norm_rs = Falseplot_norm_rs_allRepsAndOrders = Trueplot_norm_r_ratios_allRepsAndOrders_heatmap = Trueplot_norm_rs_allRepsAndOrders_heatmap = Truetarget_orders_to_plot = [1, 2]  # 1, 2replicates_to_plot = [1, 2]  # 1, 2for occ_len_and_starts_to_plot_define in [        [[28, 'all'], [21, [6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72]]],  # only for the correlation plot        [[28, 'all'], [21, [3,  6,  9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69]]],  # only for the correlation plot        [[10, 'all'], [14, 'all'], [21, 'all'], [28, 'all']],  # only for the overview plot and crRNA4 plot        [[10, 'all']],         [[14, 'all']],         [[21, 'all']],         [[28, 'all']]        ]:        if len(occ_len_and_starts_to_plot_define)== 4:        crRNAs_to_plots = [['crRNA2', 'crRNA3', 'crRNA4', 'crRNA5', 'crRNA6', 'crRNA7', 'crRNA8', 'crRNA9'],                           # ['crRNA1', 'crRNA10', 'NPC', 'crRNA_rand'],                           ['crRNA4']                          ]    else:        crRNAs_to_plots = [[                            'crRNA2', 'crRNA3', 'crRNA4', 'crRNA5', 'crRNA6', 'crRNA7', 'crRNA8', 'crRNA9',                           ]]        for crRNAs_to_plot in crRNAs_to_plots:        heatmap_ylabel_suffices = ['',                                    'occluding nts 1-28', #'; starting at 1',                                    'occluding nts 3-23', #'; starting at 3',                                     'occluding nts 6-26', #'; starting at 6',                                     # '; starting at 0',                                     # '; starting at 9'                                    # '; starting at 1',                                    # '; starting at ?'                                   ]                inv_frac_starts_to_plot = 1  # only applies when starts_to_plot_define is 'all'.        # If this is 3, plot every three starts; if 1, plot every start; if 2, plot every other start, etc.                occ_len_and_starts_to_plot = []        for occ_len, starts_to_plot in occ_len_and_starts_to_plot_define:            if starts_to_plot == 'all':                occ_len_and_starts_to_plot += [[                    occ_len, list(starts_per_occ[occ_len][::inv_frac_starts_to_plot])]]            else:                occ_len_and_starts_to_plot += [[occ_len, starts_to_plot]]                occ_lengths_to_plot = np.unique([i[0] for i in occ_len_and_starts_to_plot])                        plot_title = ''  # the conditions common to all elements of the plot        plot_title_noRepsOrOrder = ''        if len(occ_lengths_to_plot) == 1:            plot_title += str(occ_lengths_to_plot[0]) + ' nt occlusion; '        if len(crRNAs_to_plot) == 1:            plot_title += str(crRNAs_to_plot[0]) + '; '        if plot_title:            plot_title_noRepsOrOrder = plot_title[:-2]  # remove last semicolon        if len(target_orders_to_plot) == 1:            plot_title += 'Target order ' + str(target_orders_to_plot[0]) + '; '        if len(replicates_to_plot) == 1:            plot_title += 'Replicate ' + str(replicates_to_plot[0]) + '; '        plot_title = plot_title[:-2]  # remove last semicolon                        def hatch_fxn(occ_length, crRNA_index):            hatches = ['', '//', '-', '\\', '.', '/', '*', '///', 'O', '|', '+', '--', 'o', '---']            if crRNA_index * 4 > len(hatches) - 4:                return('')            hatches = hatches[crRNA_index * 4:]            if occ_length == 0:                return(hatches[0])            if occ_length == 28:                return(hatches[1])            if occ_length == 21:                return(hatches[2])            if occ_length == 14:                return(hatches[3])            if occ_length == 10:                return(hatches[3])                labels_to_plot = []        colors_to_plot = []        linestyles_to_plot = []        labels_to_plot_noRepsOrOrder = []        colors_to_plot_noRepsOrOrder = []        hatches_to_plot_noRepsOrOrder = []        labels_to_plot_noRepsOrOrder_heatmap = []        labels_to_plot_noRepsOrOrder_heatmap_shorter = []                time_series_to_plot = []        fit_preds_to_plot = []        rs_to_plot = []        r_errs_to_plot = []        r_ratios_to_plot = []        r_ratio_norms_to_plot = []        r_ratio_norms_to_plot_noRepsOrOrder = []        r_norms_to_plot = []        r_norms_to_plot_noRepsOrOrder = []                r_norms_to_plot_noRepsOrOrder_heatmap = np.zeros((            len(crRNAs_to_plot) * len(occ_len_and_starts_to_plot),             max([len(i[1]) for i in occ_len_and_starts_to_plot])))        r_ratio_norms_to_plot_noRepsOrOrder_heatmap = copy.deepcopy(            r_norms_to_plot_noRepsOrOrder_heatmap)  # same size array        r_norms_to_plot_noRepsOrOrder_heatmap_err = copy.deepcopy(            r_norms_to_plot_noRepsOrOrder_heatmap)  # same size array        r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err = copy.deepcopy(            r_norms_to_plot_noRepsOrOrder_heatmap)  # same size array        tmsd_len_noRepsOrOrder_heatmap = copy.deepcopy(            r_norms_to_plot_noRepsOrOrder_heatmap)  # same size array        all_r_norms_to_plot = np.zeros((            len(crRNAs_to_plot) * len(occ_len_and_starts_to_plot),             max([len(i[1]) for i in occ_len_and_starts_to_plot]),             4))        all_r_ratio_norms_to_plot = np.zeros((            len(crRNAs_to_plot) * len(occ_len_and_starts_to_plot),             max([len(i[1]) for i in occ_len_and_starts_to_plot]),             4))                color_index = 0        npc_color_index = 0  # so we plot NPC control in grayscale        heatmap_y_index = 0        for crRNA_index, crRNA_to_plot in enumerate(crRNAs_to_plot):            occ_length_to_plot_counter = -1  # we add 1 immediately            for occ_length_to_plot, starts_to_plot in occ_len_and_starts_to_plot:                occ_length_to_plot_counter += 1                color_index_noRepsOrOrder = 0                npc_color_index_noRepsOrOrder = 0                for start_index, start in enumerate(starts_to_plot):                    if crRNA_to_plot not in ['NPC', 'crRNA_rand']:                        if color_index < len(colors):                            color = colors[color_index]                        else:                            color='k'                        colors_to_plot_noRepsOrOrder += [colors[color_index_noRepsOrOrder]]                        color_index += 1                        color_index_noRepsOrOrder += 1                    else:                        if npc_color_index < len(gray_colors):                            color = gray_colors[npc_color_index]                        else:                            color = 'k'                        colors_to_plot_noRepsOrOrder += [gray_colors[npc_color_index_noRepsOrOrder]]                        npc_color_index += 1                        npc_color_index_noRepsOrOrder += 1                    for target_order_to_plot in target_orders_to_plot:                        for replicate_to_plot in replicates_to_plot:                                                        label = ''                            if len(crRNAs_to_plot) > 1:                                label += str(crRNA_to_plot) + '; '                            if len(occ_lengths_to_plot) > 1:                                label += 'occ' + str(occ_length_to_plot) + '; '                                                            label_to_plot_noRepsOrOrder_heatmap = (                                label[:-2] + heatmap_ylabel_suffices[occ_length_to_plot_counter])                            label_to_plot_noRepsOrOrder_heatmap_shorter = label[:-2]                                                        label += 's' + str(start) + '; '                            label_noRepsOrOrder = label[:-2]                            if len(target_orders_to_plot) > 1:                                label += 't' + str(target_order_to_plot) + '; '                            if len(replicates_to_plot) > 1:                                label += 'r' + str(replicate_to_plot) + '; '                            label = label[:-2]  # remove last semicolon                                                        labels_to_plot += [label]                            colors_to_plot += [color]                            linestyles_to_plot += [linestyles[                                # (2 * crRNA_index if len(target_orders_to_plot)==1 else 0) +                                 replicate_to_plot - 1 + 2 * (target_order_to_plot - 1)                                ]]                                    data_subset = data[                                (data['targetOrder'] == target_order_to_plot) &                                 (data['crRNA'] == crRNA_to_plot) &                                (data['replicate'] == replicate_to_plot) &                                (data['occLength'] == occ_length_to_plot) &                                 (data['start'] == start)                                ]                                                        time_series = data_subset.timeSeries                            for e, s in enumerate(time_series):                                if e == 0:  # it's annoying to see multiple plots of occlusion 0 and they all look the same                                    time_series_to_plot += [s]                                    fit_preds = data_subset.fitPred                            for e, s in enumerate(fit_preds):                                if e == 0:  # it's annoying to see multiple plots of occlusion 0 and they all look the same                                    fit_preds_to_plot += [s]                                    fit_params = data_subset.fitParams                            fit_covs = data_subset.covariance                            for e, s in enumerate(fit_params):                                if e == 0:  # it's annoying to see multiple plots of occlusion 0 and they all look the same                                    rs_to_plot += [np.exp(s[0])]                                    for e_err, s_err in enumerate(fit_covs):                                        if e_err == 0:  # it's annoying to see multiple plots of occlusion 0 and they all look the same                                            r_errs_to_plot += [np.sqrt(np.exp(s[0])**2 * s_err[0, 0])]                                              # Used to have [np.exp(s[0]) * s_err[0, 0]]                                                              r_ratios = data_subset.rRatio                            for e, s in enumerate(r_ratios):                                if e == 0:                                    r_ratios_to_plot += [s]                                    r_ratio_norms = data_subset.rRatioNorm                            for e, s in enumerate(r_ratio_norms):                                if e == 0:                                    r_ratio_norms_to_plot += [s]                                    r_norms = data_subset.rNorm                            for e, s in enumerate(r_norms):                                if e == 0:                                    r_norms_to_plot += [s]                                                                                            labels_to_plot_noRepsOrOrder += [label_noRepsOrOrder]                    hatches_to_plot_noRepsOrOrder += [hatch_fxn(occ_length_to_plot, crRNA_index)]                            data_subset_noRepsOrOrder = data[  # across both replicates & both target_orders                         (data['crRNA'] == crRNA_to_plot) &                        (data['occLength'] == occ_length_to_plot) &                         (data['start'] == start)                        ]                                        all_r_ratio_norms = data_subset_noRepsOrOrder.rRatioNorm                    r_ratio_norms_to_plot_noRepsOrOrder += [                        (np.mean(all_r_ratio_norms), #np.std(all_r_ratio_norms)                         np.sqrt(np.std(all_r_ratio_norms)**2 + np.mean(  # mean is what standard error prop gives                             [x**2 for x in data_subset_noRepsOrOrder.rRatioNormErr]))                         )]                                        all_r_norms = data_subset_noRepsOrOrder.rNorm                    r_norms_to_plot_noRepsOrOrder += [                        (np.mean(all_r_norms), #np.std(all_r_norms)                         np.sqrt(np.std(all_r_norms)**2 + np.mean(                             [x**2 for x in data_subset_noRepsOrOrder.rNormErr]))                         )]                                        all_r_ratio_norms_to_plot[                        heatmap_y_index, start_index, :] = list(all_r_ratio_norms)                    r_ratio_norms_to_plot_noRepsOrOrder_heatmap[                        heatmap_y_index, start_index] = np.mean(all_r_ratio_norms)                    r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err[                        heatmap_y_index, start_index] = (                            np.sqrt(np.std(all_r_ratio_norms)**2 + np.mean(                                [x**2 for x in data_subset_noRepsOrOrder.rRatioNormErr]))                            )                                        all_r_norms_to_plot[                        heatmap_y_index, start_index, :] = list(all_r_norms)                    r_norms_to_plot_noRepsOrOrder_heatmap[                        heatmap_y_index, start_index] = np.mean(all_r_norms)                    r_norms_to_plot_noRepsOrOrder_heatmap_err[                        heatmap_y_index, start_index] = (                            np.sqrt(np.std(all_r_norms)**2 + np.mean(                                [x**2 for x in data_subset_noRepsOrOrder.rNormErr]))                            )                    tmsd_len_noRepsOrOrder_heatmap[                        heatmap_y_index, start_index] = np.mean(data_subset_noRepsOrOrder.dispLen)  # all the same                        labels_to_plot_noRepsOrOrder_heatmap += [label_to_plot_noRepsOrOrder_heatmap]                labels_to_plot_noRepsOrOrder_heatmap_shorter += [label_to_plot_noRepsOrOrder_heatmap_shorter]                heatmap_y_index += 1                        if plot_data:            plt.figure()            for time_series, linestyle, color, label, fit_pred in zip(                    time_series_to_plot, linestyles_to_plot, colors_to_plot, labels_to_plot, fit_preds_to_plot):                plt.plot(times[:len_data_to_fit],                          time_series[:len_data_to_fit],                           linestyle=linestyle,                          color=color,                          label=label)                if plot_fit:                    plt.plot(times[:len_data_to_fit],                              fit_pred,                               linestyle=linestyle,                              color=color,                              label='',                               alpha=0.5)            plt.plot()            plt.title(plot_title)            plt.xlabel('Time (min)')            plt.ylabel('Normalized fluorescence (a.u.)')            plt.legend(bbox_to_anchor=(1.05, 1), ncol=1 + (len(labels_to_plot))//15)            plt.show()                        if plot_norm_rs_allRepsAndOrders:                        plt.figure()            gray_color_idx = 0            color_idx = len([i for i in labels_to_plot_noRepsOrOrder_heatmap_shorter if                              'NPC' not in i and 'crRNA_rand' not in i]) - 1            for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    color = gray_colors[gray_color_idx]                    gray_color_idx += 1                else:                    color = colors[color_idx]                    color_idx -= 1                if crRNA_label in ['occ10', 'occ14', 'occ21', 'occ28']:                    crRNA_label = crRNA_label[-2:]                    legend_title = ' Occlusion\nlength (nt)'                else:                    legend_title = ''                        starts_for_plot = [i - 34 for i in                                    occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]]                for r in range(4):                    plt.plot(starts_for_plot,                              all_r_ratio_norms_to_plot[e][:len(starts_for_plot)][:, r],                              '.',                             color=color)                                    plt.errorbar(starts_for_plot,                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][:len(starts_for_plot)],                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err[e][:len(starts_for_plot)],                         label=crRNA_label,                         color=color)            plt.axvspan(0, 28, color=colors[8], alpha=0.1)            plt.legend(bbox_to_anchor=(1.05, 1), title=legend_title)            plt.xlabel('Oligo start relative to protospacer')            plt.xticks([-34, -17, 0, 17, 34])            plt.ylabel('Normalized activity')            plt.title(plot_title)            plt.show()                                    plt.figure()            gray_color_idx = 0            color_idx = len([i for i in labels_to_plot_noRepsOrOrder_heatmap_shorter if                              'NPC' not in i and 'crRNA_rand' not in i]) - 1            for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    color = gray_colors[gray_color_idx]                    gray_color_idx += 1                else:                    color = colors[color_idx]                    color_idx -= 1                if crRNA_label in ['occ10', 'occ14', 'occ21', 'occ28']:                    crRNA_label = crRNA_label[-2:]                    legend_title = ' Occlusion\nlength (nt)'                else:                    legend_title = ''                        starts_for_plot = [i - 34 for i in                                    occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]]                for r in range(4):                    plt.plot(starts_for_plot,                              all_r_ratio_norms_to_plot[e][:len(starts_for_plot)][:, r],                              '.',                             color=color)                                    plt.errorbar(starts_for_plot,                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][:len(starts_for_plot)],                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err[e][:len(starts_for_plot)],                         label=crRNA_label,                         color=color)            if len(occ_len_and_starts_to_plot_define) > 1:                plt.plot([0]*2, [0, 1.5], '--', color='gray')                plt.plot([28]*2, [0, 1.5], '--', color='gray')            else:                plt.axvspan(28 - occ_len, 28, color=colors[8], alpha=0.1)                plt.axvspan(-occ_len, 0, color=colors[11], alpha=0.06)                plt.axvspan(0, 28-occ_len, color=colors[9], alpha=0.06)            plt.legend(bbox_to_anchor=(1.05, 1), title=legend_title)            plt.xlabel('Occluder start position relative to protospacer (nt)')            plt.xticks([-34, -17, 0, 17, 34])            # plt.xlim([-35, 16])            plt.ylabel('Normalized activity')            plt.title(plot_title)            plt.gca().set_ylim(bottom=0)            plt.yticks([0, 0.5, 1, 1.5])            plt.show()                                if plot_norm_r_ratios_allRepsAndOrders_heatmap:            if len(occ_len_and_starts_to_plot) == 1:                linear_cmap_white_gray = LinearSegmentedColormap.from_list('rg', ['w', gray_colors[0]], N=256)                 linear_cmap_green_blue_white = matplotlib.colormaps['BuGn_r']#(np.linspace(0, 1, 256))                linear_cmap_green_blue_white_gray=LinearSegmentedColormap.from_list(                'rg',                list(linear_cmap_green_blue_white(np.linspace(0, 1, 256))) + list(linear_cmap_white_gray(np.linspace(0, 1, 256))),                N=512)                            plt.figure(figsize=(6, 8/3.83333))                plt.imshow(r_ratio_norms_to_plot_noRepsOrOrder_heatmap,                            cmap=linear_cmap_green_blue_white_gray,                            norm=matplotlib.colors.Normalize(0., 2.),                            aspect='auto'                            )                                    plt.xlabel('Occluder start relative to protospacer', fontsize=12)                xticks_for_heatmap = [i - 34 for i in occ_len_and_starts_to_plot[np.argmax(                    [len(i[1]) for i in occ_len_and_starts_to_plot])][1]][1:][::5]                                plt.xticks(range(len(occ_len_and_starts_to_plot[np.argmax(                    [len(i[1]) for i in occ_len_and_starts_to_plot])][1]))[1:][::5],                            xticks_for_heatmap,                           fontsize=10)                plt.yticks(range(len(labels_to_plot_noRepsOrOrder_heatmap)),                            [i[-1] for i in labels_to_plot_noRepsOrOrder_heatmap],                            fontsize=10)                plt.ylabel('crRNA', fontsize=12)                cbar = plt.colorbar(                         ticks = [0, 0.5, 1., 1.5, 2.],                         fraction=0.055 * (                             r_ratio_norms_to_plot_noRepsOrOrder_heatmap.shape[0] /                              r_ratio_norms_to_plot_noRepsOrOrder_heatmap.shape[1]),   # make the colorbar not too tall                         pad=0.04,  # horizontal space between heatmap and colorbar                         anchor=(0.0, 0.4)  # shift colorbar down a bit from its default ((0.0, 0.5))                         )                cbar.set_label('Activity normalized\nto no occluder', size=12)                cbar.ax.tick_params(labelsize=10)                plt.title(str(occ_len_and_starts_to_plot[0][0]) + '-mer occluders',                          fontsize=14)                     plt.show()                                        if len(occ_len_and_starts_to_plot_define) > 1:                plt.figure(figsize=(3.2, 4.))                for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                    starts_for_plot = occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]                    if crRNA_label[:7] == labels_to_plot_noRepsOrOrder_heatmap_shorter[0][:7]:                        label = crRNA_label[-2:]                    else:                        label = ''                    plt.plot([i - 34 for i in starts_for_plot],                              r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][:len(starts_for_plot)],                              marker='o',                             # marker = {10:'s', 14:'o', 21:'^', 28:'d'}[int(crRNA_label[-2:])],                             linestyle='',                             markersize=4,                             alpha=0.7,                             color=colors[{10: 1, 14: 2, 21: 3, 28: 4}[int(crRNA_label[-2:])]],                             label=label)                            plt.axvspan(0, 28, color=colors[8], alpha=0.1)                plt.xlabel('Oligo start relative to protospacer')                plt.xticks([-28, -14, 0, 14, 28, 42])                            plt.ylabel('Normalized activity')                plt.yscale('log')                leg = plt.legend(bbox_to_anchor=(1.05, 1), title=' Occlusion\n length (nt)')                for legobj in leg.legendHandles:                    if len(legobj.get_label()) <= 2:  # ie if it's an occlusion length                        # legobj.set_color('k')  # 2.                        legobj.set_markersize(8)                plt.show()                                        fig, ax = plt.subplots()            gray_color_idx = 0            color_idx = len([i for i in labels_to_plot_noRepsOrOrder_heatmap_shorter if                              'NPC' not in i and 'crRNA_rand' not in i]) - 1            for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    color = gray_colors[gray_color_idx]                    gray_color_idx += 1                else:                    color = colors[color_idx]                    color_idx -= 1                starts_for_plot = occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]                tmsd_len = tmsd_len_noRepsOrOrder_heatmap[e][:len(starts_for_plot)]                tmsd_len_g0 = np.where(tmsd_len > 0)[0]                ratio_53 = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 5' end vs 3' end                ratio_53_err = np.zeros(len(tmsd_len_g0) // 2)                ratio_35 = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 3' end vs 5' end                ratio_35_err = np.zeros(len(tmsd_len_g0) // 2)                 for e2 in range(len(tmsd_len_g0)//2):                    ratio_53[e2] = r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][tmsd_len_g0[e2]] / (                        r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]])                    ratio_53_err[e2] = ratio_53[e2] * np.sqrt(                        (r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err[e][tmsd_len_g0[e2]] /                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][tmsd_len_g0[e2]])**2 +                         (r_ratio_norms_to_plot_noRepsOrOrder_heatmap_err[e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]] /                          r_ratio_norms_to_plot_noRepsOrOrder_heatmap[e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]])**2                         )                    ratio_35[e2] = 1/ratio_53[e2]                    ratio_35_err[e2] = ratio_35[e2] / ratio_53[e2] * ratio_53_err[e2]                plt.errorbar(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]],                         ratio_35,                          ratio_35_err,                         label=crRNA_label,                         color=color)            plt.plot([np.min(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]]), np.max(tmsd_len)],                      [1, 1], '--', color='gray')            plt.legend(bbox_to_anchor=(1.05, 1))            # plt.ylim([np.min(r_norms_to_plot_noRepsOrOrder_heatmap) / 1.2,             #                     np.max(r_norms_to_plot_noRepsOrOrder_heatmap)*1.1])            plt.xlabel('Number of protospacer nucleotides occluded')            plt.ylabel("Ratio of activities\noccluding 3' end to 5'")            plt.title(plot_title)            plt.yscale('log')            plt.ylim([0.1 * 0.95, 10*1.05])            plt.show()                                            if len(occ_len_and_starts_to_plot) > 1:                # Make pairwise correlation plots for each occlusion length                for e1, occ_len_1 in enumerate([i[0] for i in occ_len_and_starts_to_plot[:1]]):  # only consider correlations with 28-mers                    for e2_prelim, occ_len_2 in enumerate([i[0] for i in occ_len_and_starts_to_plot[e1 + 1:]]):                        e2 = e1 + e2_prelim + 1                                                corr_coef = np.corrcoef(                            np.concatenate([                                r_ratio_norms_to_plot_noRepsOrOrder_heatmap[                                    crRNA_index * len(occ_len_and_starts_to_plot) + e1] for                                crRNA_index in range(len(crRNAs_to_plot))]),                             np.concatenate([                                r_ratio_norms_to_plot_noRepsOrOrder_heatmap[                                    crRNA_index * len(occ_len_and_starts_to_plot) + e2] for                                crRNA_index in range(len(crRNAs_to_plot))]))[0, 1]                                                plt.figure()                        for crRNA_index, crRNA_to_plot in enumerate(crRNAs_to_plot):                            idx = crRNA_index * len(occ_len_and_starts_to_plot)                            plt.plot(                                r_ratio_norms_to_plot_noRepsOrOrder_heatmap[idx + e1],                                 r_ratio_norms_to_plot_noRepsOrOrder_heatmap[idx + e2],                                 '.',                                color=colors[crRNA_index],                                label=crRNA_to_plot,                                )                            plt.xlabel('Normalized activity\n' + str(occ_len_1) + '-mer occluder\n' + heatmap_ylabel_suffices[e1])                            plt.ylabel('Normalized activity\n' + str(occ_len_2) + '-mer occluder\n' + heatmap_ylabel_suffices[e2])                        plt.plot([0, 1.5], [0, 1.5], '--', color='gray')                        plt.title(plot_title_noRepsOrOrder)                        # plt.ylim([0., 2.])                        plt.legend(bbox_to_anchor=(1.05, 1))                        plt.text(0, 1.35, 'R=' + str(np.round(corr_coef, 2)), fontsize=16)                        plt.show()                        print('Correlation between ' +                               'occ' + str(occ_len_1) + heatmap_ylabel_suffices[e1] +                               ' and ' +                               'occ' + str(occ_len_2) + heatmap_ylabel_suffices[e2] +                               ' = ' + str(corr_coef))                                                if plot_norm_rs_allRepsAndOrders_heatmap:            plt.figure()            gray_color_idx = 0            color_idx = len([i for i in labels_to_plot_noRepsOrOrder_heatmap_shorter if                              'NPC' not in i and 'crRNA_rand' not in i]) - 1            marker_counter = -1            for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                marker_counter += 1                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    color = gray_colors[gray_color_idx]                    gray_color_idx += 1                else:                    color = colors[color_idx]                    color_idx -= 1                starts_for_plot = occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    for r in range(4):                        plt.plot([i - 34 for i in starts_for_plot],                                  all_r_norms_to_plot[e][:len(starts_for_plot)][:, r] * 60,                                  ['o', 's', '^', '*'][{'10': 0, '14': 1, '21': 2, '28': 3}[crRNA_label[-2:]]],                                 # label=crRNA_label * (r==0),                                 alpha=0.5,                                  color=('k' if 'NPC' in crRNA_label else 'gray'))                                        else:                    for r in range(4):                        plt.plot([i - 34 for i in starts_for_plot],                                  all_r_norms_to_plot[e][:len(starts_for_plot)][:, r] * 60,                                  '.',                                 # label=crRNA_label * (r==0),                                 color=color)                    plt.errorbar([i - 34 for i in starts_for_plot],                              r_norms_to_plot_noRepsOrOrder_heatmap[e][:len(starts_for_plot)] * 60,                              r_norms_to_plot_noRepsOrOrder_heatmap_err[e][:len(starts_for_plot)] * 60,                             label=crRNA_label,                             color=color)                        if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                for occlen in ['10', '14', '21', '28']:                    plt.plot([np.inf]*2, [np.inf]*2,                              marker=['o', 's', '^', '*'][{'10': 0, '14': 1, '21': 2, '28': 3}[occlen]],                             linestyle='',                             color='k', label=occlen)                first_legend = plt.legend(title=' Occlusion\nlength (nt)',                                          bbox_to_anchor=(1.05, 1))                ax = plt.gca().add_artist(first_legend)                lines = []                lines += plt.plot([np.inf]*2, [np.inf]*2, color='k', label='No crRNA', linewidth=4)                lines += plt.plot([np.inf]*2, [np.inf]*2, color='gray', label='Random crRNA', linewidth=4)                plt.legend(handles=lines, bbox_to_anchor=(1.05, 0.4), handlelength=1)            else:                plt.legend(bbox_to_anchor=(1.05, 1))            plt.axvspan(0, 62-34, color=colors[8], alpha=0.1)            plt.xlabel('Start position')            plt.ylabel('Activity (hr' + r'$^{-1}$' + ')')            plt.xticks([-34, -17, 0, 17, 34])            plt.title(plot_title)            plt.show()                                    plt.figure()            gray_color_idx = 0            color_idx = len([i for i in labels_to_plot_noRepsOrOrder_heatmap_shorter if                              'NPC' not in i and 'crRNA_rand' not in i]) - 1            marker_counter = -1            for e, crRNA_label in enumerate(labels_to_plot_noRepsOrOrder_heatmap_shorter):                marker_counter += 1                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    color = gray_colors[gray_color_idx]                    gray_color_idx += 1                else:                    color = colors[color_idx]                    color_idx -= 1                starts_for_plot = occ_len_and_starts_to_plot[e % len(occ_len_and_starts_to_plot)][1]                if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                    for r in range(4):                        plt.plot([i - 34 for i in starts_for_plot],                                  all_r_norms_to_plot[e][:len(starts_for_plot)][:, r] * 60,                                  ['o', 's', '^', '*'][{'10': 0, '14': 1, '21': 2, '28': 3}[crRNA_label[-2:]]],                                 # label=crRNA_label * (r==0),                                 alpha=0.5,                                  color=('k' if 'NPC' in crRNA_label else 'gray'))                                        else:                    for r in range(4):                        plt.plot([i - 34 for i in starts_for_plot],                                  all_r_norms_to_plot[e][:len(starts_for_plot)][:, r] * 60,                                  '.',                                 # label=crRNA_label * (r==0),                                 color=color)                    plt.errorbar([i - 34 for i in starts_for_plot],                              r_norms_to_plot_noRepsOrOrder_heatmap[e][:len(starts_for_plot)] * 60,                              r_norms_to_plot_noRepsOrOrder_heatmap_err[e][:len(starts_for_plot)] * 60,                             label=crRNA_label,                             color=color)                        if 'NPC' in crRNA_label or 'crRNA_rand' in crRNA_label:                for occlen in ['10', '14', '21', '28']:                    plt.plot([np.inf]*2, [np.inf]*2,                              marker=['o', 's', '^', '*'][{'10': 0, '14': 1, '21': 2, '28': 3}[occlen]],                             linestyle='',                             color='k', label=occlen)                first_legend = plt.legend(title=' Occlusion\nlength (nt)',                                          bbox_to_anchor=(1.05, 1))                ax = plt.gca().add_artist(first_legend)                lines = []                lines += plt.plot([np.inf]*2, [np.inf]*2, color='k', label='No crRNA', linewidth=4)                lines += plt.plot([np.inf]*2, [np.inf]*2, color='gray', label='Random crRNA', linewidth=4)                plt.legend(handles=lines, bbox_to_anchor=(1.05, 0.4), handlelength=1)            else:                plt.legend(bbox_to_anchor=(1.05, 1))            plt.axvspan(28 - occ_len, 28, color=colors[8], alpha=0.1)            plt.axvspan(-occ_len, 0, color=colors[11], alpha=0.06)            plt.axvspan(0, 28-occ_len, color=colors[9], alpha=0.06)            plt.xlabel('Start position')            plt.ylabel('Activity (hr' + r'$^{-1}$' + ')')            plt.xticks([-34, -17, 0, 17, 34])            plt.title(plot_title)            plt.gca().set_ylim(bottom=0)            plt.show()        #%% Compare to seed and switch regionsfrom matplotlib import cmseed_start = 20 - 15+1#9seed_end = 20 - 5+1 #15trials_length = np.zeros((28, 1000000))for e, d in enumerate(range(1, 29)):    trials_length[e, :] = np.load('randwalk_results/' +                                   'randwalk_len' + str(d) + '_ntrials1000000.npy')prediction_type = ['old', 'kstar', 'ku'][2]if prediction_type == 'old':    num_steps_allowed_from_3 = 300  # 400    num_extra_steps_allowed_for_5 = 300  # 1200elif prediction_type == 'kstar':    num_steps_allowed_from_3 = 400    num_extra_steps_allowed_for_5 = 1200elif prediction_type == 'ku':    num_steps_allowed_from_3 = 250 #200  # 200  # 800    num_extra_steps_allowed_for_5 = (np.exp(1.7) - 1) * num_steps_allowed_from_3 # 1.5 * num_steps_allowed_from_3 #600    fe_param = 3.4 # 3.4  # 3.4  # 2.7tmsd_len_dict_longer = dict()for occ_len in [28, 21, 14]:    tmsd_len_dict_longer[occ_len] = []    for start in starts_per_occ[occ_len]:        d = get_displacement_length(occ_len, start)        tmsd_len_dict_longer[occ_len] += [d]    new_pred = dict()for oligo_len in [28, 21, 14]:    if prediction_type == 'old':        new_pred[oligo_len] = [            1 if d == 0 else            (np.mean((trials_length[int(d) - 1, :] < num_steps_allowed_from_3 +                       num_extra_steps_allowed_for_5*(start > 34)), -1))            for d, start in zip(tmsd_len_dict_longer[oligo_len], starts_per_occ[oligo_len])]    elif prediction_type == 'kstar':        new_pred[oligo_len] = [            1 if d == 0 else            (np.mean(np.exp(-trials_length[int(d) - 1, :] / ((num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34)))),                     -1))            for d, start in zip(tmsd_len_dict_longer[oligo_len], starts_per_occ[oligo_len])]    elif prediction_type == 'ku':        new_pred[oligo_len] = [            1 if d == 0 else            (1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34))))            for d, start in zip(tmsd_len_dict_longer[oligo_len], starts_per_occ[oligo_len])]plt.figure()for e_o, occ_len in enumerate([14, 21, 28]):    starts_for_plot = [i - 34 for i in starts_per_occ[occ_len]]    plt.xlabel('Oligo start relative to protospacer')    plt.xticks([-34, -17, 0, 17, 34])    plt.ylabel('Predicted activity')        num_nts_of_seed_occ = np.array([sum([        1 for i in range(occ_len) if start + i in range(seed_start, seed_end+1)])         for start in starts_for_plot])    lower_upper_step_size = 3    lower_upper_steps = range(        0, ((seed_end + 1 - seed_start)//lower_upper_step_size + 1) * lower_upper_step_size + 1,         lower_upper_step_size)    for lower, upper in zip(lower_upper_steps[:-1], lower_upper_steps[1:]):        masked_pred = np.ma.masked_where(            (num_nts_of_seed_occ < lower-lower_upper_step_size+1) |             (num_nts_of_seed_occ >= upper),            new_pred[occ_len])        plt.plot(starts_for_plot,                 masked_pred,                 linestyle=['-', '--', ':'][2 - e_o],                 # label=occ_len,                 color=cm.viridis_r(lower / lower_upper_steps[-2]))    plt.scatter(starts_for_plot,              new_pred[occ_len],              c=cm.viridis_r([i / (seed_end + 1 - seed_start) for i in num_nts_of_seed_occ])             )    plt.plot([np.inf]*2, [np.inf]*2,              linestyle=['-', '--', ':'][2 - e_o],             color='k',             label=occ_len)plt.legend(title='Occlusion\nlength (nt)')plt.colorbar(cm.ScalarMappable(cmap='viridis_r'),              label='Fraction of seed or switch occluded')plt.show()#%%ADAPT_predictions = [3.3930794,3.486284912,3.456494212,3.309807003,3.267868519,3.083308578,3.186887324,3.440009534,3.026731312,3.261483669]no_occ_results_with_norm = np.zeros((10, 2))no_occ_results_no_norm = np.zeros((10, 2))for crRNA_e, crRNA in enumerate(range(1, 11)):    for replicate_e, replicate in enumerate([1, 2]):        assay = 'crRNA' + str(crRNA) + ', r' + str(replicate)        no_occ_results_with_norm[crRNA_e, replicate_e] = get_mean_no_occ(assay_names_dict_inv[assay])        no_occ_results_no_norm[crRNA_e, replicate_e] = get_mean_no_occ_no_norm(assay_names_dict_inv[assay])plt.figure()plt.bar(range(1, 11),         np.mean(no_occ_results_with_norm, 1),        yerr=np.std(no_occ_results_with_norm, 1),        color=colors[:10]        )plt.xticks(range(1, 11), range(1, 11),             # rotation=45, ha='right'            )plt.ylabel('Normalized speed of reporter cleavage')plt.xlabel('crRNA index')plt.title(plot_title)# if max(rs_to_plot) / min(rs_to_plot) > 20:#     plt.yscale('log')plt.show()for norm in [True]:    if norm:         no_occ_results = no_occ_results_with_norm    else:        no_occ_results = no_occ_results_no_norm    fig, ax = plt.subplots()    ADAPT_predictions_plot = [i - 4 for i in ADAPT_predictions]    mean_no_occ_results = np.mean(no_occ_results, 1)    std_no_occ_results = np.std(no_occ_results, 1)    ax.errorbar(ADAPT_predictions_plot, mean_no_occ_results, std_no_occ_results, ls='none', color='k')    ax.scatter(ADAPT_predictions_plot, mean_no_occ_results, c=colors[:len(ADAPT_predictions_plot)])    plt.xlabel('ADAPT prediction')    plt.ylabel('Measured activity (' + 'not '*(1 - norm) + 'normalized)')    for i, txt in enumerate(range(1, 11)):        ax.annotate(txt, (ADAPT_predictions_plot[i] + 0.005, mean_no_occ_results[i] + 0.0005))    plt.show()#%% Show how longer occlusions lead to less activity#show a scatter plot of that more occlusion leads to less activity (like 1c but with more data)# Try both rRatioNorm and rNormdef flatten(l): #From StackExchange    #Flatten a list -- given a list of sublists, concatenate the sublists into one long list    return([item for sublist in l for item in sublist])expt_data = data[    (data['crRNA'] != 'NPC') & (data['crRNA'] != 'crRNA_rand') &    (data['crRNA'] != 'crRNA1') & (data['crRNA'] != 'crRNA10') &     (data['targetOrder'] == 1) & (data['replicate'] == 1)]occ_lengths = [10, 14, 21, 28]start_5p_data = dict()start_3p_data = dict()start_middle_data = dict()for occ_len in occ_lengths:    start_5p_data[occ_len] = expt_data[        (data['occLength'] == occ_len) &         ((data['start'] == 34) | (data['start'] == 34 - 1) | (data['start'] == 34 - 2))        ]    start_3p_data[occ_len] = expt_data[        (data['occLength'] == occ_len) &         ((data['start'] == 34+28 - occ_len) | (data['start'] == 34+28 - occ_len - 1) | (data['start'] == 34+28 - occ_len - 2))        ]    start_middle_data[occ_len] = expt_data[        (data['occLength'] == occ_len) &         ((data['start'] == 34+14 - int(occ_len/2)) |          (data['start'] == 34+14 - int(occ_len/2) - 1) |          (data['start'] == 34+14 - int(occ_len/2) - 2))        ]len_data = len(start_5p_data[occ_len])start_5p_data_sns = pd.DataFrame({    'rRatioNorm': flatten([start_5p_data[occ_len].rRatioNorm.to_list() for occ_len in occ_lengths]),     'occ_len': flatten([[occ_len]*len_data for occ_len in occ_lengths])})start_3p_data_sns = pd.DataFrame({    'rRatioNorm': flatten([start_3p_data[occ_len].rRatioNorm.to_list() for occ_len in occ_lengths]),     'occ_len': flatten([[occ_len]*len_data for occ_len in occ_lengths])})start_middle_data_sns = pd.DataFrame({    'rRatioNorm': flatten([start_middle_data[occ_len].rRatioNorm.to_list() for occ_len in occ_lengths]),     'occ_len': flatten([[occ_len]*len_data for occ_len in occ_lengths])})sns_data = [start_5p_data_sns, start_middle_data_sns, start_3p_data_sns]plt.figure()for e, data_type in enumerate([start_5p_data, start_middle_data, start_3p_data]):    for occ_len in occ_lengths:        sns.swarmplot(data=sns_data[e], x='occ_len', y='rRatioNorm',                    color=colors[e], size=5, alpha=0.2, zorder=1)for e, data_type in enumerate([start_5p_data, start_middle_data, start_3p_data]):    plt.errorbar(range(4),                  [np.mean(data_type[occ_len].rRatioNorm) for occ_len in occ_lengths],                 [np.std(data_type[occ_len].rRatioNorm) / np.sqrt(len_data) for occ_len in occ_lengths],                 color=colors[e],                 marker='o', markersize=10,                 label=["5' end", "Middle", "3' end"][e],                 alpha=0.4,                 zorder=100)plt.xticks(range(4), [10, 14, 21, 28])plt.legend(title='Occluder\nalignment')#, loc='upper right')#bbox_to_anchor=(1.05, 1))plt.xlabel('Number of nucleotides occluded')plt.ylabel('Normalized activity')plt.show()#%%tmsd_len_dict = {    14: np.array([ 0.,  0.,  0.,  0.,  0.,  0.,  2.,  5.,  8., 11., 14., 14., 14.,        14., 14., 13.]),    21: np.array([ 0.,  0.,  0.,  0.,  0.,  2.,  5.,  8., 11., 14., 17., 20., 21.,        21., 20., 17., 14.]),    28: np.array([ 0.,  0.,  1.,  4.,  7., 10., 13., 16., 19., 22., 25., 28., 25.,        22., 19., 16., 13.]),    }data_slice_allstarts_dict =  {    14: np.ones((26,8)) * (np.arange(26).reshape((-1,1)) *3 + 4),    21: np.ones((26,8)) * np.arange(26).reshape((-1,1)) *3,    28: np.ones((23,8)) * (np.arange(23).reshape((-1,1)) *3 + 1),    }tmsd_len_g0_dict = {    14: np.array([10, 11, 12, 13, 14, 15]),    21: np.array([ 9, 10, 11, 12, 13, 14, 15, 16]),    28: np.array([ 6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16]),    }len_pred_data_dict = {21: 17, 28: 17, 14: 16}crRNAs_to_test = ['crRNA' + str(i) for i in range(2,10)]data_slice_allrNorms_dict = {}data_slice_allrNormErrs_dict = {}all_ratio_35_dict = {}ratio_35_dict = {}ratio_35_err_dict = {}for occ_len in [14, 21, 28]:    data_slice = data[        # (data['targetOrder'] == 1) &         # (data['replicate'] == 1) &        # ((data['crRNA'] == 'crRNA3') | (data['crRNA'] == 'crRNA4')) &        ([i in crRNAs_to_test for i in data['crRNA']]) &        # ((data['occLength'] == 28) | (data['occLength'] == 21)) &        (data['occLength'] == occ_len) &        (data['start'] <= np.max(data_slice_allstarts_dict[occ_len]))        ]    num_starts, num_crRNAs = data_slice_allstarts_dict[occ_len].shape    data_slice_allrNorms_dict[occ_len] = np.zeros((num_starts, num_crRNAs))    data_slice_allrNormErrs_dict[occ_len] = np.zeros((num_starts, num_crRNAs))        for e, start in enumerate(data_slice_allstarts_dict[occ_len][:, 0]):        for e2, crRNA in enumerate(crRNAs_to_test):            data_start_crRNA = data_slice[(data_slice['start'] == start) & (data_slice['crRNA'] == crRNA)]                data_slice_allrNorms_dict[occ_len][e, e2] = np.mean(data_start_crRNA.rRatioNorm)  #rRatioNorm  #rNorm            data_slice_allrNormErrs_dict[occ_len][e, e2] = np.std(data_start_crRNA.rRatioNorm)  #rRatioNorm  #rNorm    data_slice_rNorm = data_slice_allrNorms_dict[occ_len]    data_slice_rNormErr = data_slice_allrNormErrs_dict[occ_len]        ratio_35 = {}    ratio_35_err = {}    ratio_53 = {}    ratio_53_err = {}    for e, crRNA in enumerate(crRNAs_to_test):        tmsd_len_g0 = tmsd_len_g0_dict[occ_len]        ratio_53[crRNA] = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 5' end vs 3' end        ratio_53_err[crRNA] = np.zeros(len(tmsd_len_g0) // 2)        ratio_35[crRNA] = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 3' end vs 5' end        ratio_35_err[crRNA] = np.zeros(len(tmsd_len_g0) // 2)         ratio_53[crRNA + '_pred'] = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 5' end vs 3' end        ratio_35[crRNA + '_pred'] = np.zeros(len(tmsd_len_g0) // 2) #ratio of activity when you occlude same number of nts at 5' end vs 3' end        for e2 in range(len(tmsd_len_g0)//2):            ratio_53[crRNA][e2] = data_slice_rNorm[:, e][tmsd_len_g0[e2]] / (                data_slice_rNorm[:, e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]])            ratio_53_err[crRNA][e2] = ratio_53[crRNA][e2] * np.sqrt(                (data_slice_rNormErr[:, e][tmsd_len_g0[e2]] /                  data_slice_rNorm[:, e][tmsd_len_g0[e2]])**2 +                 (data_slice_rNormErr[:, e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]] /                  data_slice_rNorm[:, e][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]])**2                 )            ratio_35[crRNA][e2] = 1/ratio_53[crRNA][e2]            ratio_35_err[crRNA][e2] = ratio_35[crRNA][e2] / ratio_53[crRNA][e2] * ratio_53_err[crRNA][e2]                all_ratio_35_dict[occ_len] = flatten([list(ratio_35[crRNA]) for crRNA in crRNAs_to_test])    ratio_35_dict[occ_len] = ratio_35    ratio_35_err_dict[occ_len] = ratio_35_err    #%% Use simulation to get predicitonprediction_type = ['old', 'kstar', 'ku', 'eq', 'both'][2]if prediction_type == 'old':    num_steps_allowed_from_3 = 300  # 400    num_extra_steps_allowed_for_5 = 300  # 1200elif prediction_type == 'kstar':    num_steps_allowed_from_3 = 300 #400    num_extra_steps_allowed_for_5 = 450 #1200elif prediction_type == 'ku':    num_steps_allowed_from_3 = 250 #200  # 200  # 800    num_extra_steps_allowed_for_5 = (np.exp(1.7) - 1) * num_steps_allowed_from_3 # 1.5 * num_steps_allowed_from_3 #600    fe_param = 3.4 # 3.4  # 3.4  # 2.7elif prediction_type == 'eq':    num_steps_allowed_from_3 = 1e19  # 1e21 looks better  # 1e19    num_extra_steps_allowed_for_5 = 0    fe_param = 1/(1.97378414 / 0.60241968)elif prediction_type == 'both':    num_steps_allowed_from_3 = 1e5 #200  # 200  # 800    num_extra_steps_allowed_for_5 = (np.exp(1.7) - 1) * num_steps_allowed_from_3 # 1.5 * num_steps_allowed_from_3 #600    fe_param = 3.4 # 3.4  # 3.4  # 2.7new_pred = dict()for oligo_len in [28, 21, 14]:    if prediction_type == 'old':        new_pred[oligo_len] = [            1 if d == 0 else            (np.mean((trials_length[int(d) - 1, :] < num_steps_allowed_from_3 +                       num_extra_steps_allowed_for_5*(start > 34)), -1))            for d, start in zip(tmsd_len_dict[oligo_len],                                 data_slice_allstarts_dict[oligo_len][:len(tmsd_len_dict[oligo_len]), 0])]    elif prediction_type == 'kstar':        new_pred[oligo_len] = [            1 if d == 0 else            (np.mean(np.exp(-trials_length[int(d) - 1, :] / ((num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34)))),                     -1))            for d, start in zip(tmsd_len_dict[oligo_len],                                 data_slice_allstarts_dict[oligo_len][:len(tmsd_len_dict[oligo_len]), 0])]    elif prediction_type == 'ku':        new_pred[oligo_len] = [            1 if d == 0 else            (1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34))))            for d, start in zip(tmsd_len_dict[oligo_len],                                 data_slice_allstarts_dict[oligo_len][:len(tmsd_len_dict[oligo_len]), 0])]    elif prediction_type == 'eq':        new_pred[oligo_len] = [            1 if d == 0 else            (1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34))))            for d, start in zip(tmsd_len_dict[oligo_len],                                 data_slice_allstarts_dict[oligo_len][:len(tmsd_len_dict[oligo_len]), 0])]    elif prediction_type == 'both':        new_pred[oligo_len] = [            1 if d == 0 else            # (1 / (1 + np.exp(d / fe_param) * np.mean(trials_length[int(d) - 1, :], -1) / (            #     num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34))))            1 if d == 0 else            (np.mean(np.exp(-trials_length[int(d) - 1, :] / (np.exp(-d / fe_param) * (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(start > 34)))),                     -1))            for d, start in zip(tmsd_len_dict[oligo_len],                                 data_slice_allstarts_dict[oligo_len][:len(tmsd_len_dict[oligo_len]), 0])]all_ratio_35_new_pred_dict = dict()for oligo_len in [28, 21, 14]:    if prediction_type == 'ku' or prediction_type == 'eq':        all_ratio_35_new_pred_dict[oligo_len] = np.array([            (1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5))) /             (1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3)))            for d in range(13 + 1 * (oligo_len == 21), oligo_len + 1 - 3 * (oligo_len == 28))  # the 28-mers occluding the 3' end start acting like 3' protospacers at some point            ])    else:        tmsd_len_g0 = tmsd_len_g0_dict[oligo_len]        all_ratio_35_new_pred_dict[oligo_len]  = np.zeros(len(tmsd_len_g0) // 2)        for e2 in range(len(tmsd_len_g0)//2):            all_ratio_35_new_pred_dict[oligo_len][e2] = (                new_pred[oligo_len][tmsd_len_g0[len(tmsd_len_g0) - e2 - 1]]) / (                    new_pred[oligo_len][tmsd_len_g0[e2]])                    #%%plt.figure()for e, data_type in enumerate([start_5p_data, start_middle_data, start_3p_data]):    for occ_len in occ_lengths:        sns.swarmplot(data=sns_data[e], x='occ_len', y='rRatioNorm',                    color=colors[e], size=5, alpha=0.2, zorder=1)for e, data_type in enumerate([start_5p_data, start_middle_data, start_3p_data]):    plt.errorbar(range(4),                  [np.mean(data_type[occ_len].rRatioNorm) for occ_len in occ_lengths],                 [np.std(data_type[occ_len].rRatioNorm) / np.sqrt(len_data) for occ_len in occ_lengths],                 color=colors[e],                 marker='o', markersize=10,                 label=["5' end", "middle", "3' end"][e],                 alpha=0.4,                 zorder=100)plt.plot(range(len(occ_lengths)),    [np.mean((trials_length[int(d) - 1, :] < num_steps_allowed_from_3),              -1) for d in occ_lengths] if prediction_type == 'old'    else [np.mean(np.exp(-trials_length[int(d) - 1, :] / ((num_steps_allowed_from_3))),                   -1) for d in occ_lengths] if prediction_type == 'kstar'    else [(1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3))) for d in occ_lengths],    '--', color=colors[0]    )plt.plot(range(len(occ_lengths)),    [np.mean((trials_length[int(d) - 1, :] < num_steps_allowed_from_3 +               num_extra_steps_allowed_for_5 * (d != 28)), -1) for d in occ_lengths] if prediction_type == 'old'    else [np.mean(np.exp(-trials_length[int(d) - 1, :] / (        (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5 * (d != 28)))),         -1) for d in occ_lengths] if prediction_type == 'kstar'    else [(1/(1 + np.exp(d / fe_param) / (num_steps_allowed_from_3 + num_extra_steps_allowed_for_5*(d != 28))))           for d in occ_lengths],    '--', color=colors[2]    )plt.plot(range(len(occ_lengths)),    [np.inf] * len(occ_lengths),    '--', color='k', label='Predicted'    )plt.xticks(range(len(occ_lengths)), occ_lengths)plt.legend(title='Occluder\nalignment',            bbox_to_anchor=(1.05, 1)           )#, loc='upper right')#)plt.xlabel('Number of nucleotides occluded')plt.ylabel('Normalized activity')plt.show()#%%for e_o, oligo_len in enumerate([28, 21, 14]):    for e_f, figsize in enumerate([[6,4], [5, 4]]):        plt.figure(figsize=figsize)  # default is 6,4        data_slice_allstarts = data_slice_allstarts_dict[oligo_len]        data_slice_allrNorms = data_slice_allrNorms_dict[oligo_len]        data_slice_allrNormErrs = data_slice_allrNormErrs_dict[oligo_len]        len_pred_data = len_pred_data_dict[oligo_len]        for e, crRNA in enumerate(crRNAs_to_test):            plt.errorbar([i - 34 for i in data_slice_allstarts[:len_pred_data, e]],                          data_slice_allrNorms[:len_pred_data, e],                          data_slice_allrNormErrs[:len_pred_data, e],                          label=(#str(oligo_len) + '-mer d' +                                 'D' +                                 'ata'                             )*(e==0),                          color=colors[{21:3, 28: 4, 14:2}[oligo_len]],                          alpha=0.5,                          zorder=e + 10*e_o)                plt.plot([i - 34 for i in data_slice_allstarts[:len_pred_data, e]],                   new_pred[oligo_len],                   '--k',                  linewidth=3,                  zorder=1000,                  label='Equil\nModel' if prediction_type=='eq' else 'Model')        plt.xlabel('Occluder start position') #' relative to protospacer')        plt.xticks([-30, -15, 0, 15])        plt.ylabel('Activity normalized\nto no occluder')        plt.yticks([0, 0.5, 1., 1.5])                plt.legend(loc='lower left',                   )        plt.title(str(oligo_len) + '-mer occluders')        plt.show()           #%% Plot asymmetry as a function of number of nucleotides occludedfor e_o, oligo_len in enumerate([28, 21]):    plt.figure()    for e, crRNA in enumerate(crRNAs_to_test):        tmsd_len = tmsd_len_dict[oligo_len]        tmsd_len_g0 = np.where((tmsd_len >= tmsd_len[-1]) * tmsd_len > 0)[0] # since we don't include the full 3' end        plt.errorbar(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]],                 ratio_35_dict[oligo_len][crRNA],                  ratio_35_err_dict[oligo_len][crRNA],                  label=('Data' * (e==0)),#crRNA,                  color=colors[4 - e_o],                 alpha=0.5)        if prediction_type == 'ku':        plt.plot(range(13 + 1 * (oligo_len == 21), oligo_len + 1 - 3 * (oligo_len == 28) ),                     all_ratio_35_new_pred_dict[oligo_len],                     '--',                    color='k', linewidth=3, #alpha=0.5 / len(crRNAs_to_test),                     label='Model',                     zorder=20)    else:        plt.plot(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]],                    all_ratio_35_new_pred_dict[oligo_len],                    '--',                   color='k', linewidth=3, #alpha=0.5 / len(crRNAs_to_test),                    label='Model',                    zorder=20)    plt.plot([np.min(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]]),                 np.max(tmsd_len[tmsd_len_g0[:len(tmsd_len_g0)//2]])],              [1, 1], '--', color='k')    plt.xlabel('Number of protospacer\nnucleotides occluded')    plt.ylabel("Ratio of activities\noccluding 3' end to 5'")    plt.legend()    plt.yscale('log')    plt.ylim([0.1 * 0.95, 10*1.05])    plt.title(str(oligo_len) + ' nt occlusion')    plt.show()    #%% Plot histogram of asymmetryplt.figure()bin_width = 0.1bins = np.arange(0, 6.1, bin_width)  #np.linspace(-0.6, 0.8, 15),sns.histplot(#np.log             (all_ratio_35_dict[28]), fill=False, kde=True, stat='density',             color=colors[0],             bins=bins)sns.histplot(#np.log             (all_ratio_35_dict[21]), fill=False, kde=True, stat='density',             color=colors[1],             bins=bins)ratio_35_counts_28, _, _ = plt.hist(#np.log         (all_ratio_35_dict[28]),          bins=bins,         color=colors[0],         density=True,         alpha=0.5,         label='28-mers'         )ratio_35_counts_28_new_pred, _, _ = plt.hist(#np.log          (all_ratio_35_new_pred_dict[28]),           bins=bins,          color=colors[0],          density=True,          alpha=0,          label='28-mers new prediction'          )ratio_35_counts_21, _, _ = plt.hist(#np.log         (all_ratio_35_dict[21]),          bins=bins,         color=colors[1],         density=True,         alpha=0.5,         label='21-mers'         )ratio_35_counts_21_new_pred, _, _ = plt.hist(#np.log          (all_ratio_35_new_pred_dict[21]),           bins=bins,          color=colors[0],          density=True,          alpha=0,          label='21-mers new prediction'          )ratio_35_counts_14, _, _ = plt.hist(#np.log         (all_ratio_35_dict[14]),          bins=bins,         color=colors[2],         density=True,         alpha=0.5,         label='14-mers'         )ratio_35_counts_14_new_pred, _, _ = plt.hist(#np.log          (all_ratio_35_new_pred_dict[14]),           bins=bins,          color=colors[2],          density=True,          alpha=0,          label='14-mers new prediction'          )plt.plot(#np.log         (np.array([1., 1.])),          [0, 1.5], '--', color='gray')plt.xlabel(#r'$\log$' + '(' +            'Inhibition Asymmetry'            # + ')'           )plt.ylabel('Counts')plt.legend()plt.show()#%%# Plot cumulative histogram of asymmetryfor e_f, figsize in enumerate([[6,4], [4,3]]):    if e_f == 0:        fontsize=14    if e_f == 1:        fontsize=10    plt.figure(figsize=figsize)  # default is 6,4    plt.plot(bins[:-1] + (bins[1:] - bins[:-1])/2,              np.cumsum(ratio_35_counts_21) * bin_width,              color=colors[3],             label='21'             )    plt.plot(bins[:-1] + (bins[1:] - bins[:-1])/2,               np.cumsum(ratio_35_counts_21_new_pred) * bin_width,               color=colors[3],              linestyle='--',              label='21 (model)'              )        plt.plot(bins[:-1] + (bins[1:] - bins[:-1])/2,              np.cumsum(ratio_35_counts_28) * bin_width,              color=colors[4],             label='28'             )    plt.plot(bins[:-1] + (bins[1:] - bins[:-1])/2,               np.cumsum(ratio_35_counts_28_new_pred) * bin_width,               color=colors[4],              linestyle='--',              label='28 (model)'              )    plt.plot(#np.log             (np.array([1., 1.])),              [0, 1], ':', color='gray')    plt.xlabel('Ratio of activities occluding\n' + "3' end to 5' end",                fontsize=fontsize+2)    # plt.xscale('log')    plt.ylabel('Cumulative Fraction', fontsize=fontsize+2)    plt.legend(title=' Occlusion\n length (nt)', fontsize=fontsize, title_fontsize=fontsize)    plt.xticks([0,1,2,3,4,5,6], fontsize=fontsize)    plt.yticks([0,0.5,1], fontsize=fontsize)    plt.show()#%% ED Fig. 2K#%% Load dataRNA_probe_suffix = '126'raw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed.xlsx')num_replicates = 2  # set to 1 to average all data up toptimes = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)def get_rep_data(col_name, raw_data_to_use=raw_data):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates    if col_name in raw_data_to_use.columns:         if (col_name + '.1' in raw_data_to_use.columns):            # print('Only have 2 replicates for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                       raw_data_to_use[col_name + '.1'])))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                      np.zeros(raw_data_to_use[col_name].shape))))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data_to_use.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)orthologs = ['Rfx', 'Lwa28', 'Lwa21', 'Lbu']concs_per_ortholog = {'Rfx': ['e12', 'e11'],                      'Lwa28': ['e10', 'e9'],                      'Lwa21': ['e10', 'e9'],                       'Lbu': ['e8', 'e7']}occs = ['s60', 's54', 's39', 's33', 's0', 'NOC'][::-1]num_concs = max([len(value) for value in concs_per_ortholog.values()])data = np.zeros((len(orthologs), num_concs, len(occs), len(times), num_replicates))for e_ortholog, ortholog in enumerate(orthologs):    for e_conc, conc in enumerate(concs_per_ortholog[ortholog]):        for e_occ, occ in enumerate(occs):            col_name = ortholog + ' ' + occ + ' ' + conc            data[e_ortholog, e_conc, e_occ, :, :] = get_rep_data(col_name)data_ntc = np.zeros((len(orthologs), len(times), num_replicates))for e_ortholog, ortholog in enumerate(orthologs):    col_name = ortholog + ' NTC'    data_ntc[e_ortholog, :, :] = get_rep_data(col_name)#%% Fit datadef fit_data(time_series, xdata=times_float, fit_type='rab', yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        min_max_fluorescence = 7000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-2, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)data_fit = np.zeros((len(orthologs), num_concs, len(occs), num_replicates))data_fit_err = np.zeros((len(orthologs), num_concs, len(occs), num_replicates))data_fit_pred = np.zeros((len(orthologs), num_concs, len(occs), len(times), num_replicates))max_activity = 3/(5/60)for e_ortholog, ortholog in enumerate(orthologs):    for e_conc, conc in enumerate(concs_per_ortholog[ortholog]):        for e_occ, occ in enumerate(occs):            for replicate in range(num_replicates):                data_to_fit = data[e_ortholog, e_conc, e_occ, :, replicate]                fit_params, cov, fit_pred = fit_data(data_to_fit, xdata=times_float, fit_type='rab')                data_fit[e_ortholog, e_conc, e_occ, replicate] = np.exp(fit_params[0]) if np.exp(fit_params[0]) < max_activity else max_activity                data_fit_err[e_ortholog, e_conc, e_occ, replicate] = np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0])                data_fit_pred[e_ortholog, e_conc, e_occ, :, replicate] = fit_pred           data_fit_ntc = np.zeros((len(orthologs), num_replicates))data_fit_err_ntc = np.zeros((len(orthologs), num_replicates))data_fit_pred_ntc = np.zeros((len(orthologs), len(times), num_replicates))max_activity = 3/(5/60)for e_ortholog, ortholog in enumerate(orthologs):    for replicate in range(num_replicates):        data_to_fit = data_ntc[e_ortholog, :, replicate]        fit_params, cov, fit_pred = fit_data(data_to_fit, xdata=times_float, fit_type='rab')        data_fit_ntc[e_ortholog, replicate] = np.exp(fit_params[0]) if np.exp(fit_params[0]) < max_activity else max_activity        data_fit_err_ntc[e_ortholog, replicate] = np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0])        data_fit_pred_ntc[e_ortholog, :, replicate] = fit_pred            #%% label band definition# From https://stackoverflow.com/questions/67235301/vertical-grouping-of-labels-with-brackets-on-matplotlibdef add_label_band(ax, top, bottom, label, *, spine_pos=-0.05, tip_pos=-0.02, text_offset=-0.05):    """    Helper function to add bracket around y-tick labels.    Parameters    ----------    ax : matplotlib.Axes        The axes to add the bracket to    top, bottom : floats        The positions in *data* space to bracket on the x-axis    label : str        The label to add to the bracket    spine_pos, tip_pos : float, optional        The position in *axes fraction* of the spine and tips of the bracket.        These will typically be negative    Returns    -------    bracket : matplotlib.patches.PathPatch        The "bracket" Aritst.  Modify this Artist to change the color etc of        the bracket from the defaults.    txt : matplotlib.text.Text        The label Artist.  Modify this to change the color etc of the label        from the defaults.    """    # grab the yaxis blended transform    # transform = ax.get_yaxis_transform()    # add the bracket    bracket = mpatches.PathPatch(        mpath.Path(            [                [tip_pos, top][::-1],                [spine_pos, top][::-1],                [spine_pos, bottom][::-1],                [tip_pos, bottom][::-1],            ]        ),        # transform=transform,        clip_on=False,        facecolor="none",        edgecolor="k",        linewidth=2,    )    ax.add_artist(bracket)    # add the label    txt = ax.text(        (top + bottom) / 2,        spine_pos + text_offset,        label,        ha="center",        va="center",        # rotation="vertical",        clip_on=False,        # transform=transform,    )    return bracket, txt#%% Plot only one conc per orthologfor e_f in range(2):    if e_f == 0:        figsize = (6, 4)    elif e_f == 1:        figsize = (6, 3)    plt.figure(figsize=figsize)  # default is 6, 4    # for e_ortholog, ortholog in enumerate(orthologs):        # for e_conc, conc in enumerate(concs_per_ortholog[ortholog]):    colors=['#FFC107', '#D81B60', '#004D40', '#501ACA']    for e_occ, occ in enumerate(occs):        e_occ = occs.index(occ)        e = e_occ        x_axis_pos = np.arange(e_occ * (len(orthologs) + 1),                                (e_occ + 1) * (len(orthologs) + 1))        for e in range(len(x_axis_pos) - 1):            e_ortholog = {2:0, 0:1, 1:2, 3:3}[e]            e_conc = [1, 1, 1, 0][e_ortholog]            activity = 60 * mean_r(data_fit[e_ortholog, e_conc, e_occ, :])            if np.mean(data[e_ortholog, e_conc, e_occ, 0, :]) > 0.95 * np.mean(data[e_ortholog, e_conc, e_occ, -1, :]):                activity = max_activity            if activity >= max_activity:                activity = max_activity            plt.bar(x_axis_pos[e],                     activity,                     color=colors[e],                    # label=(orthologs[e_ortholog] + ' ' + concs_per_ortholog[orthologs[e_ortholog]][e_conc]) * (e_occ==0),                    label=(orthologs[e_ortholog]) * (e_occ==0),                    edgecolor='k',                    linewidth=0.1,                    width=0.7)            plt.errorbar(x_axis_pos[e],                         activity,                          0 if activity == max_activity else                          np.array([np.sqrt(np.std(60 * data_fit[e_ortholog, e_conc, e_occ, :], -1)**2),                                   min(np.sqrt(np.std(60 * data_fit[e_ortholog, e_conc, e_occ, :], -1)**2), max_activity - activity)                                   ]).reshape((2,1)),                         color='k',                         elinewidth=0.7,                         linestyle='')    e_occ += 1    x_axis_pos = np.arange(e_occ * (len(orthologs) + 1),                            (e_occ + 1) * (len(orthologs) + 1))    for e in range(len(x_axis_pos) - 1):        e_ortholog = e        e_conc = [1, 1, 1, 0][e_ortholog]        activity = 60 * mean_r(data_fit_ntc[e_ortholog, :])        plt.bar(x_axis_pos[e],                 activity if activity < max_activity else max_activity,                 color=colors[e],                edgecolor='k',                width=0.7)        plt.errorbar(x_axis_pos[e],                     activity if activity < max_activity else max_activity,                      np.sqrt(np.std(60 * data_fit_ntc[e_ortholog, :], -1)**2) if activity < max_activity else 0,                      color='k',                     linestyle='')    plt.plot([0 - 0.5, x_axis_pos[-1] + 4 - 0.5], [max_activity] * 2, '--k', linewidth=1)    plt.gca().annotate('Max\nmeasurement', xy=(14, max_activity),                        xytext=(14, max_activity * (2 - e_f/2)/3),                       arrowprops=dict(arrowstyle="->"), ha='center',                        fontsize=12)        for e_occ, occ in enumerate(occs + ['NTC']):        e = e_occ        x_axis_pos = np.arange(e_occ * (len(orthologs) + 1),                                (e_occ + 1) * (len(orthologs) + 1))        add_label_band(plt.gca(), x_axis_pos[0], x_axis_pos[-1] - 1, occ,                        spine_pos=-2 -60 * 0.015,                       tip_pos=-2 -60 * 0.012,                        text_offset=-2 -60 * (0.006* (1+2*e_f)))    plt.xticks([], [])    plt.ylabel('Activity (h' + r'$^{-1}$' + ')')    plt.xlabel('\n' + '\n' + 'Occluder condition')    plt.ylim([-1, max_activity+3])    plt.xlim(-2, x_axis_pos[-1] + 4)    plt.legend(title='Ortholog',               fontsize=10,               loc='upper right', bbox_to_anchor=(1.0, 0.9)               )    plt.show()    colors = (['#1E88E5', '#FFC107', '#D81B60', '#004D40', '#501ACA', '#65C598',            '#4C1F49', '#A64ADE', '#339010'] + ['#0B3B65', '#8C6902', '#7D0E36', '#03B99A', '#8F6AE2']) * 10    #%% Compare 21- to 28-nt spacersplt.figure()for e_occ, occ in enumerate(occs):    plt.plot(np.mean(data[1,1,e_occ,:12,:], -1).reshape(-1),              np.mean(data[2,1,e_occ,:12,:], -1).reshape(-1),              'o',              color=colors[0],#e_occ],             label=occ,             alpha=0.3)plt.xlabel('Fluorescence measurement\nfor 28-nt spacer')plt.ylabel('Fluorescence measurement\nfor 21-nt spacer')plt.show()#%% Compare spacer lengthsfor e_f in range(1):    if e_f == 0:        figsize = (6, 4)    elif e_f == 1:        figsize = (6, 3)    plt.figure(figsize=figsize)  # default is 6, 4    # for e_ortholog, ortholog in enumerate(orthologs):        # for e_conc, conc in enumerate(concs_per_ortholog[ortholog]):    colors=['#FFC107', '#D81B60', '#004D40', '#501ACA']    for e_occ, occ in enumerate(occs):        e_occ = occs.index(occ)        e = e_occ        x_axis_pos = np.arange(e_occ * (2 + 1),                                (e_occ + 1) * (2 + 1))        for e in range(len(x_axis_pos) - 1):            e_ortholog = {2:0, 0:1, 1:2, 3:3}[e]            e_conc = [1, 1, 1, 0][e_ortholog]            activity = 60 * mean_r(data_fit[e_ortholog, e_conc, e_occ, :])            if np.mean(data[e_ortholog, e_conc, e_occ, 0, :]) > 0.95 * np.mean(data[e_ortholog, e_conc, e_occ, -1, :]):                activity = max_activity            if activity >= max_activity:                activity = max_activity            plt.bar(x_axis_pos[e],                     activity,                     color=colors[e],                    # label=(orthologs[e_ortholog] + ' ' + concs_per_ortholog[orthologs[e_ortholog]][e_conc]) * (e_occ==0),                    label=(orthologs[e_ortholog][-2:]) * (e_occ==0),                    edgecolor='k',                    linewidth=0.1,                    width=0.7)            plt.errorbar(x_axis_pos[e],                         activity,                          0 if activity == max_activity else                          np.array([np.sqrt(np.std(60 * data_fit[e_ortholog, e_conc, e_occ, :], -1)**2),                                   min(np.sqrt(np.std(60 * data_fit[e_ortholog, e_conc, e_occ, :], -1)**2), max_activity - activity)                                   ]).reshape((2,1)),                         color='k',                         elinewidth=0.7,                         linestyle='')    e_occ += 1    x_axis_pos = np.arange(e_occ * (2 + 1),                            (e_occ + 1) * (2 + 1))    for e in range(len(x_axis_pos) - 1):        e_ortholog = e        e_conc = [1, 1, 1, 0][e_ortholog]        activity = 60 * mean_r(data_fit_ntc[e_ortholog, :])        plt.bar(x_axis_pos[e],                 activity if activity < max_activity else max_activity,                 color=colors[e],                edgecolor='k',                width=0.7)        plt.errorbar(x_axis_pos[e],                     activity if activity < max_activity else max_activity,                      np.sqrt(np.std(60 * data_fit_ntc[e_ortholog, :], -1)**2) if activity < max_activity else 0,                      color='k',                     linestyle='')    plt.plot([0 - 0.5, x_axis_pos[-1] + 4 - 0.5], [max_activity] * 2, '--k', linewidth=1)    plt.gca().annotate('Max\nmeasurement', xy=(8, max_activity),                        xytext=(8, max_activity * (2 - e_f/2)/3),                       arrowprops=dict(arrowstyle="->"), ha='center',                        fontsize=12)        for e_occ, occ in enumerate(occs + ['NTC']):        e = e_occ        x_axis_pos = np.arange(e_occ * (2 + 1),                                (e_occ + 1) * (2 + 1))        add_label_band(plt.gca(), x_axis_pos[0], x_axis_pos[-1] - 1, occ,                        spine_pos=-2 -60 * 0.015,                       tip_pos=-2 -60 * 0.012,                        text_offset=-2 -60 * (0.006* (1+2*e_f)))    plt.xticks([], [])    plt.ylabel('Activity (h' + r'$^{-1}$' + ')')    plt.xlabel('\n' + '\n' + 'Occluder condition')    plt.ylim([-1, max_activity+3])    plt.xlim(-2, x_axis_pos[-1] + 2)    plt.legend(title='Spacer\nlength',               # bbox_to_anchor=(1.05, 1),                fontsize=10,               loc='upper right', bbox_to_anchor=(1.0, 0.9)               )    plt.show()    colors = (['#1E88E5', '#FFC107', '#D81B60', '#004D40', '#501ACA', '#65C598',            '#4C1F49', '#A64ADE', '#339010'] + ['#0B3B65', '#8C6902', '#7D0E36', '#03B99A', '#8F6AE2']) * 10#%% Fig. 2H #XXX#%% Load dataRNA_probe_suffix = '067_068'raw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed.xlsx')# Naming scheme: target comes first, crRNA comes second (and is preceded by "c"). # So WT s31 cm5 is wildtype target, with forward occlusion, plus m5 crRNAnum_replicates = 3  # set to 1 to average all data up toptimes = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)def get_rep_data(col_name, raw_data_to_use=raw_data):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates    if col_name in raw_data_to_use.columns:         if (col_name + '.1' in raw_data_to_use.columns) and (col_name + '.2' in raw_data_to_use.columns):            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                       raw_data_to_use[col_name + '.1'],                                                      raw_data_to_use[col_name + '.2'])))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name, col_name + '.1', col_name + '.2'], axis=1, inplace=True)          elif (col_name + '.1' in raw_data_to_use.columns):            print('Only have 2 replicates for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                       raw_data_to_use[col_name + '.1'],                                                      np.zeros(raw_data_to_use[col_name].shape))))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                      np.zeros(raw_data_to_use[col_name].shape),                                                     np.zeros(raw_data_to_use[col_name].shape))))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data_to_use.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)annealings = ['PRE', 'reg']occs = ['NOC', 's31 2x', 's31 5x', 's31 10x', 's61 2x', 's61 5x', 's61 10x', 'NTC']data = np.zeros((len(annealings), len(occs), len(times), num_replicates))for e_ann, ann in enumerate(annealings):    for e_occ, occ in enumerate(occs):        col_name = ann + ' ' + occ        data[e_ann, e_occ, :, :] = get_rep_data(col_name)    #%% Fit datadef fit_data(time_series, xdata=times_float, fit_type='rab', yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        min_max_fluorescence = 7000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)data_fit = np.zeros((len(annealings), len(occs), num_replicates))data_fit_err = np.zeros((len(annealings), len(occs), num_replicates))data_fit_pred = np.zeros((len(annealings), len(occs), len(times), num_replicates))for e_ann, ann in enumerate(annealings):    for e_occ, occ in enumerate(occs):        for replicate in range(num_replicates):            data_to_fit = data[e_ann, e_occ, :, replicate]            fit_params, cov, fit_pred = fit_data(data_to_fit, xdata=times_float, fit_type='rab')            data_fit[e_ann, e_occ, replicate] = np.exp(fit_params[0])            data_fit_err[e_ann, e_occ, replicate] = np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0])            data_fit_pred[e_ann, e_occ, :, replicate] = fit_pred                        #%% label band definition# From https://stackoverflow.com/questions/67235301/vertical-grouping-of-labels-with-brackets-on-matplotlibdef add_label_band(ax, top, bottom, label, *, spine_pos=-0.05, tip_pos=-0.02, text_offset=-0.05):    """    Helper function to add bracket around y-tick labels.    Parameters    ----------    ax : matplotlib.Axes        The axes to add the bracket to    top, bottom : floats        The positions in *data* space to bracket on the x-axis    label : str        The label to add to the bracket    spine_pos, tip_pos : float, optional        The position in *axes fraction* of the spine and tips of the bracket.        These will typically be negative    Returns    -------    bracket : matplotlib.patches.PathPatch        The "bracket" Aritst.  Modify this Artist to change the color etc of        the bracket from the defaults.    txt : matplotlib.text.Text        The label Artist.  Modify this to change the color etc of the label        from the defaults.    """    # grab the yaxis blended transform    # transform = ax.get_yaxis_transform()    # add the bracket    bracket = mpatches.PathPatch(        mpath.Path(            [                [tip_pos, top][::-1],                [spine_pos, top][::-1],                [spine_pos, bottom][::-1],                [tip_pos, bottom][::-1],            ]        ),        # transform=transform,        clip_on=False,        facecolor="none",        edgecolor="k",        linewidth=2,    )    ax.add_artist(bracket)    # add the label    txt = ax.text(        (top + bottom) / 2,        spine_pos + text_offset,        label,        ha="center",        va="center",        # rotation="vertical",        clip_on=False,        # transform=transform,    )    return bracket, txt#%% Fig. 2Hplt.figure()for e_ann, ann in enumerate(annealings):    x_axis_pos = np.arange(len(annealings) * len(occs))[e_ann:][::2] - (e_ann-0.5)*0.2    plt.bar(x_axis_pos,             60 * mean_r(data_fit[e_ann, :, :]),             color=[colors[0], colors[1], colors[1], colors[1], colors[2], colors[2], colors[2], 'k'],            hatch=['', '//'][e_ann],            edgecolor='k',            width=0.7)    plt.errorbar(x_axis_pos,                 60 * mean_r(data_fit[e_ann, :, :]),                  np.sqrt(np.std(60 * data_fit[e_ann, :, :], -1)**2),                  color='k',                 # marker='.',                 linestyle='')    for replicate in range(num_replicates):        x_offset = [-0.2, 0, 0.2][replicate]        plt.plot(x_axis_pos + x_offset,                 60 * data_fit[e_ann, :, replicate],                 color='gray',                linestyle='',                markersize=5,                marker='.'                )plt.xticks(x_axis_pos + (e_ann-0.5)*0.2 - 0.5,            ['NOC', '2x', '5x', '10x', '2x', '5x', '10x', 'NTC'],           rotation=30,            ha='center')add_label_band(plt.gca(), 1.9, 7.3, "Protospacer\noccluder", spine_pos=-60 * 0.015, tip_pos=-60 * 0.012, text_offset=-60 * 0.006)add_label_band(plt.gca(), 7.9, 13.3, "3' occluder", spine_pos=-60 * 0.015, tip_pos=-60 * 0.012, text_offset=-60 * 0.006)plt.ylabel('Activity (hr' + r'$^{-1}$' + ')')PRE_patch = matplotlib.patches.Patch(facecolor='w', label='With occluder', hatch='', edgecolor='k')reg_patch = matplotlib.patches.Patch(facecolor='w', label='After occluder', hatch='//', edgecolor='k')plt.gca().legend(handles=[PRE_patch, reg_patch], title='crRNA added', #fontsize=13,                  )plt.show()#%% Fig. 2e-f #XXX#%% Load dataRNA_probe_suffix = '057'  # This has the NOC conditions at the same concentration as the occluded onesfit_type = 'rib'index_to_start_fit = 0raw_data_a = pd.read_excel('/Users/Ofer/Dropbox/LSI 2021/Cas13/Data analysis/' +     'RNAProbe' + RNA_probe_suffix + 'a_indexed.xlsx')raw_data_b = pd.read_excel('/Users/Ofer/Dropbox/LSI 2021/Cas13/Data analysis/' +     'RNAProbe' + RNA_probe_suffix + 'b_indexed.xlsx')raw_data = raw_data_a.join(raw_data_b, lsuffix='_a')  # put a suffix on the columns in both# These are: Time, WT_order_2 cr10 NOC, WT_order_2 cr10 NOC.1# Putting a suffix on the ones from "a" since the data looks a tiny bit less good# (both are saturated but a is decreasing more significantly)raw_data_NOC_lowconc = pd.read_excel('/Users/Ofer/Dropbox/LSI 2021/Cas13/Data analysis/' +     'RNAProbe' + '066_b' + '_indexed.xlsx')  # '066'num_replicates = 2  # set to 1 to average all data up toptimes = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)times_lowconc = raw_data_NOC_lowconc.Time.to_numpy()times_lowconc_float = np.array(times_lowconc, dtype=float)#%% Organize datadef get_rep_data(col_name, raw_data_to_read):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates    if col_name in raw_data_to_read.columns:         if col_name + '.1' in raw_data_to_read.columns:            data_to_return = np.transpose(np.vstack((raw_data_to_read[col_name],                                                       raw_data_to_read[col_name + '.1'])))            ## To check if we missed anything            # raw_data_to_read.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_read[col_name],                                                      np.zeros(raw_data_to_read[col_name].shape))))            ## To check if we missed anything            # raw_data_to_read.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        # print(col_name + ' not in raw_data.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)def get_col_name(order, crRNA, occluder, position, which_mut=0):    # which_mut=0 for WT    if position == 'WT':        return(position + '_order_' + str(order) + ' cr' + str(crRNA) + ' ' + occluder)    else:        return('ord' + str(order) + '_pos' + str(position) + '_it' + str(which_mut) +                ' cr' + str(crRNA) + ' ' + occluder)def fit_data(time_series, xdata=times_float, fit_type=fit_type, yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        min_max_fluorescence = 7000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)        return(fit_params, covariance, fit_pred)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)if fit_type == 'rib':    def get_r(fit_params):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)        r_tot = 1 / (1/r + 1/r2)        return(r_tot)        def get_r_err(fit_params, cov):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)                sigma_r = cov[0, 0]        sigma_r2 = cov[1, 1]        return(np.sqrt((r2 * sigma_r)**2 + (r * sigma_r2)**2) / (r + r2))        # if r < r2:        #     return(sigma_r)        # else:        #     return(sigma_r2)else:    def get_r(fit_params):        return(np.exp(fit_params[0]))        def get_r_err(fit_params, cov):        return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]))#%% Get dataorders = [1, 2]crRNAs = [4, 5, 8, 10]occluders = ['NOC', 'fwd', 'rev', 'NOC_lowconc']positions = ['WT', 2, 5, 9, 12]  which_muts = [1, 3]data = np.zeros((len(orders), len(crRNAs), len(occluders), len(positions),                  len(which_muts), len(times), num_replicates))data_fit_r = np.zeros((len(orders), len(crRNAs), len(occluders), len(positions),                  len(which_muts), num_replicates))data_fit_r_err = np.zeros((len(orders), len(crRNAs), len(occluders), len(positions),                  len(which_muts), num_replicates))data_fit_pred = np.zeros((len(orders), len(crRNAs), len(occluders), len(positions),                  len(which_muts), len(times) - index_to_start_fit, num_replicates))for e_position, position in enumerate(positions):    if position == 'WT':        which_muts_for_position = [1]  # put them in index 0        orders_for_position = orders #[2]    else:        which_muts_for_position = which_muts        orders_for_position = orders    for order in orders_for_position:        e_order = orders.index(order)        for e_crRNA, crRNA in enumerate(crRNAs):            if crRNA == 10:  # there is no reverse occluder for crRNA10                occluders_for_crRNA = [occluders[0], occluders[1], occluders[3]]            else:                occluders_for_crRNA = occluders            for occluder in occluders_for_crRNA:                e_occluder = occluders.index(occluder)                for which_mut in which_muts_for_position:                    e_which_mut = which_muts.index(which_mut)                    if occluder == 'NOC_lowconc':                        col_name = get_col_name(order, crRNA, '', position, which_mut)[:-1]                        rep_data = get_rep_data(col_name, raw_data_to_read=raw_data_NOC_lowconc)                    else:                        col_name = get_col_name(order, crRNA, occluder, position, which_mut)                        rep_data = get_rep_data(col_name, raw_data_to_read=raw_data)                    if not np.all(rep_data == 0):                        data[e_order, e_crRNA, e_occluder, e_position,                              e_which_mut, :rep_data.shape[0], :] = rep_data                        for replicate in range(num_replicates):  # get fit for each curve                            time_series_to_fit = rep_data[index_to_start_fit:, replicate]                            if occluder == 'NOC_lowconc':                                times_to_fit = times_lowconc_float[index_to_start_fit:] - times_lowconc_float[index_to_start_fit]                            else:                                times_to_fit = times_float[index_to_start_fit:] - times_float[index_to_start_fit]                                                        init_guesses = [-5., -4., -6., -3., -7., -2., -8., -1., 0., 1., 2.]                            fit_success = False                            init_guess = init_guesses.pop(0)                            while (len(init_guesses) > 0 and (fit_success == False)):                                if fit_type=='rib':                                    p0 = [init_guess, init_guess + .6, np.max(raw_data.max())]                                else:                                    p0 = [init_guess, np.max(raw_data.max())]                                try:                                    fit_params, covariance, fit_pred = fit_data(                                        time_series_to_fit,                                         xdata=times_to_fit,                                        p0=p0)                                    fit_success = True                                except:                                    fit_success = False                                    init_guess = init_guesses.pop(0)                            # if fit_success == False:                                # print('REALLY NO FIT FOUND FOR ',                                #       crRNA, position, order, occluder,                                 #       which_mut, replicate, init_guess)                            data_fit_r[e_order, e_crRNA, e_occluder, e_position,                                   e_which_mut, replicate] = get_r(fit_params)                            data_fit_r_err[e_order, e_crRNA, e_occluder, e_position,                                   e_which_mut, replicate] = get_r_err(fit_params, covariance)                            data_fit_pred[e_order, e_crRNA, e_occluder, e_position,                                   e_which_mut, :rep_data.shape[0], replicate] = fit_pred        ntc_data = np.zeros((len(crRNAs), len(times), num_replicates))ntc_data_fit_r = np.zeros((len(crRNAs), num_replicates))ntc_data_fit_r_err = np.zeros((len(crRNAs), num_replicates))ntc_data_fit_pred = np.zeros((len(crRNAs), len(times) - index_to_start_fit, num_replicates))for e_crRNA, crRNA in enumerate(crRNAs):    rep_data = get_rep_data('cr' + str(crRNA) + ' NTC', raw_data)    ntc_data[e_crRNA, :, :] = rep_data    for replicate in range(num_replicates):  # get fit for each curve        time_series_to_fit = rep_data[index_to_start_fit:, replicate]        times_to_fit = times_float[index_to_start_fit:] - times_float[index_to_start_fit]        fit_params, covariance, fit_pred = fit_data(time_series_to_fit, xdata=times_to_fit)        ntc_data_fit_r[e_crRNA, replicate] = get_r(fit_params)        ntc_data_fit_r_err[e_crRNA, replicate] = get_r_err(fit_params, covariance)        ntc_data_fit_pred[e_crRNA, :, replicate] = fit_pred#%% ED Fig. 6mutations = {1: {'A': 'C', 'C': 'G', 'G': 'U', 'U': 'A'},             3: {'A': 'U', 'C': 'A', 'G': 'C', 'U': 'G'}}wt_nts = {4: {2: 'U', 5: 'A', 6:'C', 9:'C', 12:'U'},          5: {2: 'A', 5: 'C', 6:'A', 9:'U', 12:'U'},          8: {2: 'G', 5: 'C', 6:'U', 9:'A', 12:'G'}}def get_starting_nt(crRNA, pos):    return(wt_nts[crRNA][pos])def get_mutant_nt(crRNA, pos, which_mut):    return(mutations[which_mut][wt_nts[crRNA][pos]])    def get_mutation(starting_nt, mutant_nt):    return(starting_nt + '>' + #r'$>$' + #r'$\to$' +            mutant_nt)positions = ['WT', 2, 5, 9, 12]  fig, axs = plt.subplots(nrows=9, ncols=4, figsize=(20, 40))for occluder in occluders:    e_occluder = occluders.index(occluder)    for position in positions:        e_position = positions.index(position)        for e_which_mut, which_mut in enumerate(which_muts):            axs1 = e_occluder            axs0 = e_position * len(which_muts) + e_which_mut - (position != 'WT')            if position != 'WT' or e_which_mut != 1:                ax = axs[axs0, axs1]                for crRNA in [4, 5, 8]:                    e_crRNA = crRNAs.index(crRNA)                    for e_order, order in enumerate(orders):                        for replicate in range(num_replicates)[::-1]:                            if data[e_order, e_crRNA, e_occluder, e_position,                                     e_which_mut, 0, replicate] > 0:  # if data exists                                # print([i for i in data[e_order, e_crRNA, e_occluder, e_position, e_which_mut, :, replicate]])                                if occluder=='NOC_lowconc':                                    times_to_plot = times_lowconc                                else:                                    times_to_plot = times                                ax.plot(times_to_plot,                                          data[e_order, e_crRNA, e_occluder, e_position, e_which_mut, :len(times_to_plot), replicate],                                         color=colors[e_crRNA],                                         linestyle=linestyles[e_order + 2*replicate],                                         # label=get_col_name(                                         #     order, crRNA, occluder, position, which_mut                                         #     ) + ' rep' + str(replicate + 1)                                         )                                # ax.plot(times_to_plot[index_to_start_fit:],                                 #           data_fit_pred[e_order, e_crRNA, e_occluder, e_position, e_which_mut, :len(times_to_plot), replicate],                                #           color=colors[e_crRNA],                                #           linestyle=linestyles[e_which_mut + 2*replicate],                                #           alpha=0.5, linewidth=2.5                                #           )                    label = 'crRNA' + str(crRNA)                    if position != 'WT':                        label += ('; ' + get_mutation(                            get_starting_nt(crRNA, position),                             get_mutant_nt(crRNA, position, which_mut)))                    ax.plot([np.inf]*2, [np.inf]*2, color=colors[e_crRNA],                             label=label                             )                if axs0 == 0:                    ax.set_title({'NOC': 'No occluder',                               'fwd': 'Target occluder',                               'rev': 'crRNA occluder',                                'NOC_lowconc': 'No occluder (low concentration)'}[occluder])                if axs0 == axs.shape[0] - 1:                    ax.set_xlabel('Time (hr)')                    ax.set_xticks([0, 60, 120, 180], [0, 1, 2, 3])                else:                    ax.set_xticks([0, 60, 120, 180], ['']*4)                if axs1 == 0:                    ax.set_ylabel(('Mismatch in position ' + str(position) if position != 'WT'                     else 'No mismatch') + '\n'                        'Fluorescence (a.u.)')                    ax.set_yticks([0, 3000, 6000, 9000, 12000])                else:                    ax.set_yticks([0, 3000, 6000, 9000, 12000], ['']*5)                ax.set_ylim([0, 14000])                legend1 = ax.legend(                    fontsize=12,                    #bbox_to_anchor=(1.05, 1)#, ncol=2                    )                ax.add_artist(legend1)                if axs0 == 0 and axs1 == axs.shape[1] - 1:                    lines = []                    for e_order, order in enumerate(orders):                        for replicate in range(num_replicates)[::-1]:                            l1, = ax.plot([np.inf]*2, [np.inf]*2, color='k',                                     linestyle=linestyles[e_order + 2*replicate],                                     label=('Target order ' + str(order) + '; ' +                                             'Replicate ' + str(replicate + 1))                                     )                            lines += [l1]                    ax.legend(handles=lines, bbox_to_anchor=(1.05, 1))plt.show()#%% Fig. 2Edark_colors = ['#0B3B65', '#C39D2D',#'#8C6902',                '#7D0E36', '#03B99A', '#8F6AE2']occluders_to_plot = ['NOC_lowconc', 'rev']#['NOC', 'rev']sns_data_mut_WT_ratio = [data_fit_r[e_order, e_crRNA, e_occluder, e_position, e_which_mut, replicate] /                          data_fit_r[1, e_crRNA, e_occluder, 0, 0, replicate]                          for e_order, order in enumerate(orders)                         for e_occluder in [occluders.index(occluder) for occluder in occluders_to_plot]                         for e_crRNA, crRNA in enumerate(crRNAs[:-1])                         for e_position in [positions.index(position) for position in positions[1:]]                         for e_which_mut, which_mut in enumerate(which_muts)                         for replicate in range(num_replicates)                         ]sns_data_occluder = [{'rev': 'With occluder', 'NOC_lowconc': 'No occluder'}[occluders[e_occluder]]                         for e_order, order in enumerate(orders)                         for e_occluder in [occluders.index(occluder) for occluder in occluders_to_plot]                         for e_crRNA, crRNA in enumerate(crRNAs[:-1])                         for e_position in [positions.index(position) for position in positions[1:]]                         for e_which_mut, which_mut in enumerate(which_muts)                         for replicate in range(num_replicates)                         ]sns_data_crRNA = [crRNA                         for e_order, order in enumerate(orders)                         for e_occluder in [occluders.index(occluder) for occluder in occluders_to_plot]                         for e_crRNA, crRNA in enumerate(crRNAs[:-1])                         for e_position in [positions.index(position) for position in positions[1:]]                         for e_which_mut, which_mut in enumerate(which_muts)                         for replicate in range(num_replicates)                         ]sns_data_position = [positions[e_position]                         for e_order, order in enumerate(orders)                         for e_occluder in [occluders.index(occluder) for occluder in occluders_to_plot]                         for e_crRNA, crRNA in enumerate(crRNAs[:-1])                         for e_position in [positions.index(position) for position in positions[1:]]                         for e_which_mut, which_mut in enumerate(which_muts)                         for replicate in range(num_replicates)                         ]sns_data_which_mut = [which_mut                         for e_order, order in enumerate(orders)                         for e_occluder in [occluders.index(occluder) for occluder in occluders_to_plot]                         for e_crRNA, crRNA in enumerate(crRNAs[:-1])                         for e_position in [positions.index(position) for position in positions[1:]]                         for e_which_mut, which_mut in enumerate(which_muts)                         for replicate in range(num_replicates)                         ]sns_data = pd.DataFrame({'mut_WT_ratio': sns_data_mut_WT_ratio,                         'occluder': sns_data_occluder,                         'crRNA' : sns_data_crRNA,                         'position': sns_data_position,                         'which_mut': sns_data_which_mut})sns_data['starting_nt'] = sns_data.apply(lambda x: get_starting_nt(    crRNA=x['crRNA'], pos=x['position']), axis=1)sns_data['mutant_nt'] = sns_data.apply(lambda x: get_mutant_nt(    crRNA=x['crRNA'], pos=x['position'], which_mut=x['which_mut']), axis=1)sns_data['mutation'] = sns_data.apply(lambda x: get_mutation(    starting_nt=x['starting_nt'], mutant_nt=x['mutant_nt']), axis=1)plt.figure(#figsize=(8.4, 4)           )positions = np.unique(sns_data['position'])for e_o, occluder in enumerate(['No occluder', 'With occluder']):    violin_data = [np.log2(1/                    sns_data[        (sns_data['position'] == position) & (sns_data['occluder'] == occluder)].mut_WT_ratio)            for position in positions]    violin_crRNA = [sns_data[        (sns_data['position'] == position) & (sns_data['occluder'] == occluder)].crRNA            for position in positions]        violin_pos = np.arange(len(positions)) * 3.5 + e_o    jitter = 0.2        parts = plt.violinplot(        dataset=violin_data,        positions=violin_pos,        widths=0.8,        showextrema=False,         )    for pc in parts['bodies']:        pc.set_facecolor(colors[e_o])        pc.set_edgecolor('black')        pc.set_alpha(0.5)        for e_v, (violin_datapoints, violin_crRNApoints) in enumerate(zip(violin_data, violin_crRNA)):        for d, c in zip(violin_datapoints, violin_crRNApoints):            plt.scatter(np.array([violin_pos[e_v]])                        + (np.random.random() * jitter*2) - jitter                        ,                         d,                         color=dark_colors[e_o],                         marker={4: 's', 5: 'o', 8: '^'}[c],                        s=20,                         alpha=0.7,                        )plt.plot(np.linspace(-0.6, max(violin_pos) + 0.6, 2), np.zeros(2),           '--', color='gray')# plt.yscale('log')plt.xticks(violin_pos - 0.5, positions)# lines = []# for e_crRNA, crRNA in enumerate(crRNAs[:-1]):#     l1, = plt.plot([np.inf, np.inf], [np.inf, np.inf], markers[e_crRNA], #                    color='gray', label=crRNA)#     lines += [l1]# legend1 = plt.legend(handles=lines, loc='upper right', #                       title='crRNA', fontsize=12)plt.bar([np.inf]*2, [np.inf]*2,        color=colors[0],        label='No occluder',        alpha=0.5)plt.bar([np.inf]*2, [np.inf]*2,        color=colors[1],        label='With occluder',        alpha=0.5)plt.legend(bbox_to_anchor=(1.05, 1))plt.xlabel('Mismatch position')plt.ylabel('Mismatch discrimination')folder_name = '/Users/Ofer/Dropbox/LSI 2021/Cas13/Figures/July23/'plt.savefig(folder_name + 'PNGs/' +             'large_scale_mut_plate_summary_noOccVsOcc_mutRatio_plt.png',             bbox_inches='tight', dpi=300)plt.show()#%% Fig. 2Fplt.figure(#figsize=(8.4, 4)           )mutations = np.unique(sns_data['mutation'])# mutations = [mutations[i] for i in [3, 4, 1, 6, 0, 2, 5, 7]]for e_o, occluder in enumerate(['No occluder', 'With occluder']):    violin_data = [np.log2(1/                    sns_data[        (sns_data['mutation'] == mutation) & (sns_data['occluder'] == occluder)].mut_WT_ratio)            for mutation in mutations]    violin_crRNA = [sns_data[        (sns_data['mutation'] == mutation) & (sns_data['occluder'] == occluder)].crRNA            for mutation in mutations]        violin_pos = np.arange(8) * 3.5 + e_o    jitter = 0.2        parts = plt.violinplot(        dataset=violin_data,        positions=violin_pos,        widths=0.8,        showextrema=False,         )    for pc in parts['bodies']:        pc.set_facecolor(colors[e_o])        pc.set_edgecolor('black')        pc.set_alpha(0.5)        for e_v, (violin_datapoints, violin_crRNApoints) in enumerate(zip(violin_data, violin_crRNA)):        for d, c in zip(violin_datapoints, violin_crRNApoints):            plt.scatter(np.array([violin_pos[e_v]])                        + (np.random.random() * jitter*2) - jitter                        ,                         d,                         color=dark_colors[e_o],                         marker={4: 's', 5: 'o', 8: '^'}[c],                        s=20,                         alpha=0.7,                        )plt.plot(np.linspace(-0.6, max(violin_pos) + 0.6, 2), np.zeros(2),           '--', color='gray')# plt.yscale('log')plt.xticks(violin_pos - 0.5, mutations, rotation=45)lines = []for e_crRNA, crRNA in enumerate(crRNAs[:-1]):    l1, = plt.plot([np.inf, np.inf], [np.inf, np.inf],                    {4: 's', 5: 'o', 8: '^'}[crRNA],#markers[e_crRNA],                     color='gray', label=crRNA)    lines += [l1]legend1 = plt.legend(handles=lines, #loc='upper right',                       bbox_to_anchor=(1.05, 1),                      title='crRNA', fontsize=12)plt.xlabel('Mutation')plt.ylabel('Mismatch discrimination')plt.show()#%% Only show no-occluderplt.figure(#figsize=(8.4, 4)           )positions = np.unique(sns_data['position'])for e_o, occluder in enumerate(['No occluder']):    violin_data = [np.log2(1/                    sns_data[        (sns_data['position'] == position) & (sns_data['occluder'] == occluder)].mut_WT_ratio)            for position in positions]    violin_crRNA = [sns_data[        (sns_data['position'] == position) & (sns_data['occluder'] == occluder)].crRNA            for position in positions]        violin_pos = np.arange(len(positions)) * 3.5 + e_o    jitter = 0.2        parts = plt.violinplot(        dataset=violin_data,        positions=violin_pos,        widths=0.8,        showextrema=False,         )    for pc in parts['bodies']:        pc.set_facecolor(colors[e_o])        pc.set_edgecolor('black')        pc.set_alpha(0.5)        for e_v, (violin_datapoints, violin_crRNApoints) in enumerate(zip(violin_data, violin_crRNA)):        for d, c in zip(violin_datapoints, violin_crRNApoints):            plt.scatter(np.array([violin_pos[e_v]])                        + (np.random.random() * jitter*2) - jitter                        ,                         d,                         color=dark_colors[e_o],                         marker={4: 's', 5: 'o', 8: '^'}[c],                        s=20,                         alpha=0.7,                        )plt.plot(np.linspace(-0.6, max(violin_pos) + 0.6, 2), np.zeros(2),           '--', color='gray')plt.xticks(violin_pos, positions)plt.xlabel('Mismatch position')plt.ylabel('Mismatch discrimination')plt.show()plt.figure(#figsize=(8.4, 4)           )mutations = np.unique(sns_data['mutation'])# mutations = [mutations[i] for i in [3, 4, 1, 6, 0, 2, 5, 7]]for e_o, occluder in enumerate(['No occluder']):    violin_data = [np.log2(1/                    sns_data[        (sns_data['mutation'] == mutation) & (sns_data['occluder'] == occluder)].mut_WT_ratio)            for mutation in mutations]    violin_crRNA = [sns_data[        (sns_data['mutation'] == mutation) & (sns_data['occluder'] == occluder)].crRNA            for mutation in mutations]        violin_pos = np.arange(8) * 3.5 + e_o    jitter = 0.2        parts = plt.violinplot(        dataset=violin_data,        positions=violin_pos,        widths=0.8,        showextrema=False,         )    for pc in parts['bodies']:        pc.set_facecolor(colors[e_o])        pc.set_edgecolor('black')        pc.set_alpha(0.5)        for e_v, (violin_datapoints, violin_crRNApoints) in enumerate(zip(violin_data, violin_crRNA)):        for d, c in zip(violin_datapoints, violin_crRNApoints):            plt.scatter(np.array([violin_pos[e_v]])                        + (np.random.random() * jitter*2) - jitter                        ,                         d,                         color=dark_colors[e_o],                         marker={4: 's', 5: 'o', 8: '^'}[c],                        s=20,                         alpha=0.7,                        )plt.plot(np.linspace(-0.6, max(violin_pos) + 0.6, 2), np.zeros(2),           '--', color='gray')# plt.yscale('log')plt.xticks(violin_pos, mutations, rotation=45)lines = []for e_crRNA, crRNA in enumerate(crRNAs[:-1]):    l1, = plt.plot([np.inf, np.inf], [np.inf, np.inf],                    {4: 's', 5: 'o', 8: '^'}[crRNA],#markers[e_crRNA],                     color='gray', label=crRNA)    lines += [l1]legend1 = plt.legend(handles=lines, #loc='upper right',                       bbox_to_anchor=(1.05, 1),                      title='crRNA', fontsize=12)plt.xlabel('Mutation')plt.ylabel('Mismatch discrimination')plt.show()#%% How many of the 24 different position/mutation pairs are significantly greater than 0?num_NOC_nodiscrim = 0num_NOC_discrim = 0positions = ['WT', 2, 5, 9, 12]  occluders_to_plot = ['NOC_lowconc', 'rev']#['NOC', 'rev']for e_order, order in enumerate(orders):    for occluder in occluders_to_plot:        for e_crRNA, crRNA in enumerate(crRNAs[:-1]):  # don't include cr10            e_occluder = occluders.index(occluder)            for position in positions[1:]:  # don't include WT                e_position = positions.index(position)                for e_which_mut, which_mut in enumerate(which_muts):                    for replicate in range(num_replicates):                        if (data[e_order, e_crRNA, e_occluder, e_position,                                 e_which_mut, 0, replicate] > 0) and (                            data[1, e_crRNA, e_occluder, 0,                                     0, 0, replicate] > 0):  # if mut & WT both exist                            WT_r_norm = data_fit_r[                                1, e_crRNA, e_occluder, 0, 0, replicate]                            WT_r_err_norm = data_fit_r_err[                                1, e_crRNA, e_occluder, 0, 0, replicate]                            mut_r_norm = data_fit_r[e_order, e_crRNA, e_occluder,                                            e_position, e_which_mut, replicate]                            mut_r_err_norm = min(data_fit_r_err[e_order, e_crRNA, e_occluder,                                            e_position, e_which_mut, replicate],                                                 1e0)                            if occluder == 'NOC_lowconc':                                if mut_r_norm >= WT_r_norm:                                    num_NOC_nodiscrim += 1                                else:                                    num_NOC_discrim += 1print('In NOC conditions, mut activity >= WT in', num_NOC_nodiscrim, 'out of', num_NOC_discrim + num_NOC_nodiscrim, 'cases')from scipy.stats import ttest_1sampnum_mismatches_not_discriminated = 0num_mismatches_total = 0num_datapoints_less_than_zero = 0for crRNA in np.unique(sns_data.crRNA):    for position in np.unique(sns_data.position):        for mutation in np.unique(sns_data.mutation):            sns_data_slice = np.log2(                1 /                 sns_data[                    (sns_data.occluder == 'No occluder') &                     (sns_data.crRNA == crRNA) &                     (sns_data.position==position) &                     (sns_data.mutation==mutation)                ].mut_WT_ratio                )            if len(sns_data_slice):                num_datapoints_less_than_zero += np.sum(sns_data_slice < 0)                num_mismatches_total += 1                if ttest_1samp(                        sns_data_slice,                         popmean=0,                         alternative='greater').pvalue > 0.05:                    num_mismatches_not_discriminated += 1print('Discrimination is not statistically significant in ' + str(num_mismatches_not_discriminated) +       ' out of ' + str(num_mismatches_total) + ' mismatches')num_mismatches_incorrectly_discriminated = 0num_mismatches_total = 0num_datapoints_less_than_zero = 0for crRNA in np.unique(sns_data.crRNA):    for position in np.unique(sns_data.position):        for mutation in np.unique(sns_data.mutation):            sns_data_slice = np.log2(                1 /                 sns_data[                    (sns_data.occluder == 'No occluder') &                     (sns_data.crRNA == crRNA) &                     (sns_data.position==position) &                     (sns_data.mutation==mutation)                ].mut_WT_ratio                )            if len(sns_data_slice):                num_datapoints_less_than_zero += np.sum(sns_data_slice < 0)                num_mismatches_total += 1                if ttest_1samp(                        sns_data_slice,                         popmean=0,                         alternative='less').pvalue < 0.05:                    num_mismatches_incorrectly_discriminated += 1print('Discrimination is statistically significantly wrong in ' + str(num_mismatches_incorrectly_discriminated) +       ' out of ' + str(num_mismatches_total) + ' mismatches')#%% Figure 3 c-d #XXX#%% Define datadata = pd.read_excel('RNAProbe' + '052' + '_indexed.xlsx')num_replicates = 3  # set to 1 to average all data up topnum_dil = 6times = data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)#%% Functionsfit_type = 'rib'def get_rep_data(col_name):    # Each column name appears twice for two replicates; return both    data_to_return = np.transpose(np.vstack((data[col_name],                                               data[col_name + '.1'],                                              data[col_name + '.2'])))    # data.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)  # to check if we missed anything    if num_replicates == 1:  # meaning we want to average the data at this step        data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    return(data_to_return)def fit_data(time_series, fit_type='rib', xdata=times_float, p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    def fit_fxn_exp_rs(t, log_r, start_time):         a = np.min(data.iloc[0][1:])        b = np.max(data.max())        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = np.min(data.iloc[0][1:])        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))        min_max_fluorescence = 9000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, np.max(data.max())]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, np.max(data.max())])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, np.min(data.iloc[0][1:]), np.max(data.max())]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, np.max(data.max())])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        p0 = [-3, np.max(data.max())]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, np.max(data.max())])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-3., -3.6, np.max(data.max())]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, np.max(data.max())])        # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        #sigma=?        bounds=bounds,        maxfev=8000,        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)if fit_type == 'rib':    def get_r(fit_params):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)        r_tot = 1 / (1/r + 1/r2)        return(r_tot)        def get_r_err(fit_params, cov):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)                sigma_r = cov[0, 0]        sigma_r2 = cov[1, 1]        return(np.sqrt((r2 * sigma_r)**2 + (r * sigma_r2)**2) / (r + r2))        # if r < r2:        #     return(sigma_r)        # else:        #     return(sigma_r2)else:    def get_r(fit_params):        return(np.exp(fit_params[0]))        def get_r_err(fit_params, cov):        return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]))#%% Import dataWT_dils = np.array([get_rep_data('WT dil' + str(i))                     for i in range(1, num_dil + 1)])WT_occ_dils = np.array([get_rep_data('WTocc dil' + str(i))                         for i in range(1, num_dil + 1)])m5_dils = np.array([get_rep_data('m5 dil' + str(i))                     for i in range(1, num_dil + 1)])m5_occ_dils = np.array([get_rep_data('m5occ dil' + str(i))                         for i in range(1, num_dil + 1)])m4_11_dils = np.array([get_rep_data('m4-11 dil' + str(i))                     for i in range(1, num_dil + 1)])m4_11_occ_dils = np.array([get_rep_data('m4-11occ dil' + str(i))                         for i in range(1, num_dil + 1)])data_dict = dict()data_dict['WT'] = WT_dilsdata_dict['WTocc'] = WT_occ_dilsdata_dict['m5'] = m5_dilsdata_dict['m5occ'] = m5_occ_dilsdata_dict['m4_11'] = m4_11_dilsdata_dict['m4_11occ'] = m4_11_occ_dilsdata_dict['NTC'] = get_rep_data('NTC')#%% Fit datafit_dict = dict()fit_dict['r'] = dict()fit_dict['r_err'] = dict()fit_dict['pred'] = dict()fit_dict['r']['NTC'] = np.zeros(num_replicates)fit_dict['r_err']['NTC'] = np.zeros(num_replicates)fit_dict['pred']['NTC'] = np.zeros((len(times), num_replicates))for rep in range(num_replicates):    fit_params_NTC, cov_NTC, fit_pred_NTC = fit_data(        data_dict['NTC'][:, rep],         fit_type=fit_type)    fit_dict['r']['NTC'][rep] = get_r(fit_params_NTC)    fit_dict['r_err']['NTC'][rep] = get_r_err(fit_params_NTC, cov_NTC)    fit_dict['pred']['NTC'][:, rep] = fit_pred_NTCfor mut in ['WT', 'm5', 'm4_11']:    for occ in ['', 'occ']:        fit_dict['r'][mut+occ] = np.zeros((num_dil, num_replicates))        fit_dict['r_err'][mut+occ] = np.zeros((num_dil, num_replicates))        fit_dict['pred'][mut+occ] = np.zeros((num_dil, len(times), num_replicates))        for dil in range(num_dil):            for rep in range(num_replicates):                init_guess = -4.                fit_success = False                while (init_guess < 2.4 and (fit_success == False)):                    try:                        fit_params, cov, fit_pred = fit_data(                            data_dict[mut + occ][dil, :, rep],                             fit_type=fit_type,                            p0=[init_guess, init_guess + 0.6, np.max(data.max())])                        fit_success = True                    except:                        print(mut, occ, dil, rep, init_guess)                        fit_success = False                        init_guess += 1.                fit_dict['r'][mut+occ][dil, rep] = get_r(fit_params)                fit_dict['r_err'][mut+occ][dil, rep] = get_r_err(fit_params, cov)                if fit_dict['r'][mut+occ][dil, rep] < np.max(fit_dict['r']['NTC']):                    fit_dict['r'][mut+occ][dil, rep] = np.max(fit_dict['r']['NTC'])                    fit_dict['r_err'][mut+occ][dil, rep] = np.max(fit_dict['r_err']['NTC'])  #1.                            fit_dict['pred'][mut+occ][dil, :, rep] = fit_pred                #%% Fig. 3C# Plot curves for WT & m5 for one dilutionfor e_occs_to_plot, occs_to_plot in enumerate([[''], ['', 'occ']]):    for e_f, figsize in enumerate([[6,4], [4,4]]):        plt.figure(figsize=figsize)  # default is 6,4        for e in [2]:  # plot dil3            fluor_to_normalize = np.max(data_dict['WT'][e, :, :])  # np.max(data.max())            for e_occ, occ in enumerate(occs_to_plot):                 for e_mut, mut in enumerate(['WT', 'm5']):                    for rep in range(num_replicates):                        plt.plot(times / 60,                                  np.mean(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                                 color=colors[e_occ], linestyle=linestyles[e_mut],                                 linewidth=3.5,                                 label=({'occ': 'With occluder', '': 'No occluder'}[occ] +                                         '; ' +                                         {'WT': 'No mismatch', 'm5': 'Mismatch'}[mut]                                        ) * (rep==0))                        plt.fill_between(times / 60,                                          # (np.mean(data_dict[mut+occ][e, :, :], axis=1) -                                          #  np.std(data_dict[mut+occ][e, :, :], axis=1)) / fluor_to_normalize,                                         np.min(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                                         # (np.mean(data_dict[mut+occ][e, :, :], axis=1) +                                          #  np.std(data_dict[mut+occ][e, :, :], axis=1)) / fluor_to_normalize,                                         np.max(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                                         color=colors[e_occ], alpha=0.1                                         )        for rep in range(num_replicates):            plt.plot(times / 60,                      np.mean(data_dict['NTC'], axis=1) / fluor_to_normalize,                     color='black',                      label=('NTC') * (rep==0))            plt.fill_between(times / 60,                              (np.mean(data_dict['NTC'], axis=1) -                               np.std(data_dict['NTC'], axis=1)) / fluor_to_normalize,                             (np.mean(data_dict['NTC'], axis=1) +                               np.std(data_dict['NTC'], axis=1)) / fluor_to_normalize,                             color='black', alpha=0.1                             )        plt.xlabel('Time (h' + 'r' * (1-e_f) + ')')        plt.xticks([0, 1, 2, 3])        plt.ylabel('Normalized fluorescence')        if e_f == 0:            plt.legend(bbox_to_anchor=(1.05, 1))        else:            leg = plt.legend(bbox_to_anchor=(0.24, 0.36), fontsize=9)            for legobj in leg.legendHandles:                legobj.set_linewidth(2.0)        plt.show()     #%% Make all plots of fluorescence in a single gridfig, axs = plt.subplots(nrows=2, ncols=3, figsize=(18, 10))occs_to_plot = ['', 'occ']for e in range(num_dil):  # plot dil3    fluor_to_normalize = 1. #np.max(data_dict['WT'][e, :, :])  # np.max(data.max())    axs0 = e//3    axs1 = e%3    ax = axs[axs0, axs1]        for e_occ, occ in enumerate(occs_to_plot):         for e_mut, mut in enumerate(['WT', 'm5', 'm4_11']):            for rep in range(num_replicates):                if np.any(data_dict[mut+occ][e, :, :]):                    ax.plot(times / 60,                              np.mean(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                             color=colors[e_occ], linestyle=linestyles[e_mut],                             linewidth=3.5,                             label=({'occ': 'With occluder', '': 'No occluder'}[occ] +                                     '; ' +                                     {'WT': 'WT', 'm5': 'Mismatch', 'm4_11': 'Double mismatch'}[mut]                                    ) * (rep==0))                    ax.fill_between(times / 60,                                      # (np.mean(data_dict[mut+occ][e, :, :], axis=1) -                                      #  np.std(data_dict[mut+occ][e, :, :], axis=1)) / fluor_to_normalize,                                     np.min(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                                     # (np.mean(data_dict[mut+occ][e, :, :], axis=1) +                                      #  np.std(data_dict[mut+occ][e, :, :], axis=1)) / fluor_to_normalize,                                     np.max(data_dict[mut+occ][e, :, :], axis=1) / fluor_to_normalize,                                     color=colors[e_occ], alpha=0.1                                     )    for rep in range(num_replicates):        ax.plot(times / 60,                  np.mean(data_dict['NTC'], axis=1) / fluor_to_normalize,                 color='black',                  label=('NTC') * (rep==0),                 zorder=-10)        ax.fill_between(times / 60,                          (np.mean(data_dict['NTC'], axis=1) -                           np.std(data_dict['NTC'], axis=1)) / fluor_to_normalize,                         (np.mean(data_dict['NTC'], axis=1) +                           np.std(data_dict['NTC'], axis=1)) / fluor_to_normalize,                         color='black', alpha=0.1,                         zorder=-10                         )        if axs1 == axs.shape[1] - 1 and axs0 == 0:        ax.legend(bbox_to_anchor=(1.05, 1))    if axs0 == axs.shape[0] - 1:        ax.set_xlabel('Time (hr)')        ax.set_xticks([0, 1, 2, 3])    else:        ax.set_xticks([0, 1, 2, 3], ['']*4)    # if axs1 == 0:    ax.set_ylabel('Fluorescence (a.u.)')    # ax.set_ylim([0, 15000])    ax.set_title(str([63, 12, 2.5, 0.5, 0.1, 0.02][e]) + ' nM input concentration')plt.subplots_adjust(wspace=0.3,                    hspace=0.2)plt.show()#%% Plot maximum fluorescence ratio as a function of dilutionWT_over_mut = dict()err_WT_over_mut = dict()WT_over_mut_max = dict()err_WT_over_mut_max = dict()for mut in ['m5', 'm4_11']:    WT_over_mut[mut] = np.zeros((2, num_dil, len(times)))    err_WT_over_mut[mut] = np.zeros((2, num_dil, len(times)))    WT_over_mut_max[mut] = np.zeros((2, num_dil))    err_WT_over_mut_max[mut] = np.zeros((2, num_dil))    for e_occ, occ in enumerate(['', 'occ']):         for e in range(num_dil):            to_subtract = np.min(get_rep_data('NTC'))  #np.mean(get_rep_data('NTC')) - 2* np.std(get_rep_data('NTC'))             mean_WT = np.mean(data_dict['WT'+occ][e, :, :], -1) - to_subtract            mean_mut = np.mean(data_dict[mut+occ][e, :, :], -1) - to_subtract            WT_over_mut[mut][e_occ, e, :] = mean_WT / mean_mut            std_WT = np.std(data_dict['WT'+occ][e, :, :], -1)  # std is invariant to adding or subtracting a constant            std_mut = np.std(data_dict[mut+occ][e, :, :], -1)            err_WT_over_mut[mut][e_occ, e, :] = np.sqrt(                (mean_WT**2)*(std_mut**2) + (mean_mut**2)*(std_WT**2)) / (mean_mut**2)                        min_argmax = 0            WT_over_mut_argmax = min_argmax + np.argmax(WT_over_mut[mut][e_occ, e, min_argmax:])            WT_over_mut_max[mut][e_occ, e] = WT_over_mut[mut][e_occ, e, WT_over_mut_argmax]            err_WT_over_mut_max[mut][e_occ, e] = err_WT_over_mut[mut][e_occ, e, WT_over_mut_argmax]mut='m5'for e_occs_to_plot, occs_to_plot in enumerate([[''], ['', 'occ']]):    for e_f, figsize in enumerate([[6,4], [4,4]]):        plt.figure(figsize=figsize)  # default is 6,4        bar_width=0.4        for e_occ, occ in enumerate(occs_to_plot):             for e in range({'m5': 6, 'm4_11':2}[mut]): #num_dil):                plt.bar(np.arange(1 + e_occ*0.4, num_dil + 1 + e_occ*0.4),                         WT_over_mut_max[mut][e_occ, :],                         yerr=err_WT_over_mut_max[mut][e_occ, :], width=bar_width,                         color=colors[e_occ],                         label={'': 'No ' + '\n'*e_f + 'occluder',                                'occ': 'With ' + '\n'*e_f + 'occluder'}[occ] * (e==0))            plt.plot(np.linspace(1 - bar_width/2, num_dil + bar_width*1.5, 50), [1]*50,                  '-', color='gray')            plt.xticks([i + bar_width/2 for i in range(1, num_dil + 1)],                    [63, 12, 2.5, 0.5, 0.1, 0.02][:])        plt.xlabel('Input concentration (nM)')        plt.ylabel('Maximum fluorescence ratio')        # plt.yscale('log')        plt.legend(fontsize=14 - 2*e_f)#bbox_to_anchor=(1.05, 1))            plt.show()    #%% Fig. 3h & ED Fig. 8 #XXX#%% Load dataRNA_probe_suffix = '064'  # RNA_probe_suffix = '056'raw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed' + '_updated.xlsx')# Naming scheme: target comes first, crRNA comes second (and is preceded by "c"). # So WT s31 cm5 is wildtype target, with forward occlusion, plus m5 crRNAnum_replicates = 2  # set to 1 to average all data up toptimes = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)def get_rep_data(col_name):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates    if col_name in raw_data.columns:         if (col_name + '.1' in raw_data.columns):            data_to_return = np.transpose(np.vstack((raw_data[col_name],                                                       raw_data[col_name + '.1'])))            ## To check if we missed anything            # raw_data.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data[col_name],                                                      raw_data[col_name])))            ## To check if we missed anything            # raw_data.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)def get_col_name(target, cRNA, target_occ, cRNA_occ):    targets_to_try = [target]    if target[:2] == 'ti':        targets_to_try += ['it' + target[-1], 'It' + target[-1]]    elif target == 'WT':        targets_to_try = ['tWT']    cRNAs_to_try = [cRNA]    if cRNA[:2] == 'ti':        cRNAs_to_try += ['it' + cRNA[-1], 'It' + cRNA[-1]]    for target_to_try in targets_to_try:        for cRNA_to_try in cRNAs_to_try:            col_name = 'c' + cRNA_to_try + cRNA_occ + ' ' + target_to_try + target_occ            if col_name in raw_data.columns:                return(col_name)    print('Could not find col_name for ', target, cRNA, target_occ, cRNA_occ)    return(False)        muts = ['WT', 'ti1', 'ti2', 'ti3']occluders = ['', 'Occ']data = np.zeros((len(muts), len(muts), len(occluders), len(occluders), len(times), num_replicates))for e_target, target in enumerate(muts):    for e_cRNA, cRNA in enumerate(muts):        for e_target_occ, target_occ in enumerate(occluders):            for e_cRNA_occ, cRNA_occ in enumerate(occluders):                data[e_target, e_cRNA, e_target_occ, e_cRNA_occ, :, :] = get_rep_data(                    get_col_name(target, cRNA, target_occ, cRNA_occ))# NTC dataNTC_data = np.zeros((len(muts), len(occluders), len(times), num_replicates))for e_cRNA, cRNA in enumerate(muts):    for e_cRNA_occ, cRNA_occ in enumerate(occluders):        NTC_data[e_cRNA, e_cRNA_occ, :, :] = get_rep_data(            get_col_name('NTC', cRNA, '', cRNA_occ))#%% Fit datafit_type = 'rb'def fit_data(time_series, xdata=times_float, fit_type=fit_type, yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        min_max_fluorescence = 8000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)if fit_type == 'rib':    def get_r(fit_params):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)        r_tot = 1 / (1/r + 1/r2)        return(r_tot)        def get_r_err(fit_params, cov):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)                sigma_r = cov[0, 0]        sigma_r2 = cov[1, 1]        return(np.sqrt((r2 * sigma_r)**2 + (r * sigma_r2)**2) / (r + r2))        # if r < r2:        #     return(sigma_r)        # else:        #     return(sigma_r2)else:    def get_r(fit_params):        return(np.exp(fit_params[0]))        def get_r_err(fit_params, cov):        return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]))index_to_start_fit = 10data_fit_r = np.zeros((len(muts), len(muts), len(occluders), len(occluders), num_replicates))data_fit_r_err = np.zeros((len(muts), len(muts), len(occluders), len(occluders), num_replicates))data_fit_pred = np.zeros((len(muts), len(muts), len(occluders), len(occluders),                           len(times) - index_to_start_fit, num_replicates))for e_target_occ, target_occ in enumerate(occluders):    for e_cRNA_occ, cRNA_occ in enumerate(occluders):        for e_cRNA, cRNA in enumerate(muts):            for e_target, target in enumerate(muts):                for replicate in range(num_replicates):                    time_series_to_fit = data[e_target, e_cRNA, e_target_occ, e_cRNA_occ, index_to_start_fit:, replicate]                    times_to_fit = times_float[index_to_start_fit:] - times_float[index_to_start_fit]                                        init_guesses = [-5., -4., -6., -3., -7., -2., -8., -1., 0., 1., 2.]                    fit_success = False                    init_guess = init_guesses.pop(0)                    while (len(init_guesses) > 0 and (fit_success == False)):                        if fit_type=='rib':                            p0 = [init_guess, init_guess + .6, np.max(raw_data.max())]                        else:                            p0 = [init_guess, np.max(raw_data.max())]                        try:                            fit_params, covariance, fit_pred = fit_data(                                time_series_to_fit,                                 xdata=times_to_fit,                                p0=p0)                            fit_success = True                        except:                            fit_success = False                            init_guess = init_guesses.pop(0)                    data_fit_r[e_target, e_cRNA, e_target_occ, e_cRNA_occ, replicate] = get_r(fit_params)                    data_fit_r_err[e_target, e_cRNA, e_target_occ, e_cRNA_occ, replicate] = get_r_err(                        fit_params, covariance)                    data_fit_pred[e_target, e_cRNA, e_target_occ, e_cRNA_occ, :, replicate] = fit_pred#%% Extended Data Fig. 8crRNA_mut_labels = [r'$U\to U$', r'$U\to G$', r'$U\to C$', r'$U\to A$']target_mut_labels = [r'$A\to A$', r'$A\to C$', r'$A\to G$', r'$A\to U$']fig, axs = plt.subplots(nrows=4, ncols=4, figsize=(20, 20))for e_target_occ, target_occ in enumerate(occluders):    for e_cRNA_occ, cRNA_occ in enumerate(occluders):        for e_target, target in enumerate(muts):            axs1 = e_target_occ * len(occluders) + e_cRNA_occ            axs0 = e_target            for cRNA in muts[::-1]:                e_cRNA = muts.index(cRNA)                for replicate in range(num_replicates):                    time_series_to_plot = data[e_target, e_cRNA, e_target_occ, e_cRNA_occ, :, replicate]                    if time_series_to_plot[-1] > 0:  # i.e. if the data exists                        axs[axs0, axs1].plot(times, time_series_to_plot,                                   color=colors[e_cRNA],                                  linestyle='-', #linestyles[e_cRNA],                                  label=(target_mut_labels[e_target][-2] + ' / ' +                                          crRNA_mut_labels[e_cRNA][-2]) * (replicate==0))                        axs[axs0, axs1].plot(times[index_to_start_fit:],                                  data_fit_pred[e_target, e_cRNA, e_target_occ, e_cRNA_occ, :, replicate],                                  color=colors[e_cRNA],                                  linestyle='--', #linestyles[e_cRNA],                                  alpha=0.5)            for cRNA in muts[::-1]:                e_cRNA = muts.index(cRNA)                for replicate in range(2):                    axs[axs0, axs1].plot(times, NTC_data[e_cRNA, e_cRNA_occ, :, replicate], color='k',                              linestyle=linestyles[e_cRNA],                             zorder=-100,                             label=('NTC / '+ crRNA_mut_labels[e_cRNA][-2])*(replicate==0))            if axs0 == 0:                axs[axs0, axs1].set_title(                    {'Occ': 'With crRNA occluder', '': 'No crRNA occluder'}[cRNA_occ] + '\n' +                     {'Occ': 'With target occluder', '': 'No target occluder'}[target_occ]                    # + '; ' + crRNA_mut_labels[e_cRNA] + ' crRNA'                    )            if axs1 == axs.shape[1] - 1:                axs[axs0, axs1].legend(bbox_to_anchor=(1.05, 1), title='Target / crRNA')            if axs0 == axs.shape[0] - 1:                axs[axs0, axs1].set_xlabel('Time (hr)')                axs[axs0, axs1].set_xticks([0, 60, 120, 180], [0, 1, 2, 3])            else:                axs[axs0, axs1].set_xticks([0, 60, 120, 180], ['']*4)            if axs1 == 0:                axs[axs0, axs1].set_ylabel('Fluorescence (a.u.)')                axs[axs0, axs1].set_yticks([0, 5000, 10000, 15000])            else:                axs[axs0, axs1].set_yticks([0, 5000, 10000, 15000], ['']*4)            axs[axs0, axs1].set_ylim([0, 16500])plt.show()#%% Fig. 3hlinear_cmap = matplotlib.colormaps['BuGn']  #LinearSegmentedColormap.from_list('rg',["w", colors[7], 'k'], N=256) log_space_fxn = lambda x: xe_target_occ = 0target_occ = ''for e_cRNA_occ, cRNA_occ in enumerate(occluders):            spec_mat = log_space_fxn(mean_r(data_fit_r[:, :, e_target_occ, e_cRNA_occ, :],                              mean_exp=(log_space_fxn==np.log)))        spec_mat_to_normalize = spec_mat  # to normalize each row individually         row_normalized_spec_mat = np.transpose(np.transpose(spec_mat) / np.diag(spec_mat_to_normalize))    plt.figure()    plt.imshow(row_normalized_spec_mat,               cmap=linear_cmap, #'BuGn',               norm=matplotlib.colors.Normalize(log_space_fxn(0.0), log_space_fxn(2.)))    plt.colorbar(label='Normalized activity', ticks=[0, 1, 2])    plt.title({'Occ': 'With occluder', '': 'No occluder'}[cRNA_occ])    plt.xticks([0, 1, 2, 3], [i[-2] for i in crRNA_mut_labels])    plt.yticks([0, 1, 2, 3], [i[-2] for i in target_mut_labels],                rotation='vertical', va='center')    plt.xlabel('crRNA')    plt.ylabel('Target')    plt.show()#%% Fig. 3g, ED Fig. 7A, 5B #XXX#%% Load dataRNA_probe_suffix = '065' RNA_probe_suffix_NOC_conditions = '067_068'  raw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed.xlsx')# Naming scheme: target comes first, crRNA comes second (and is preceded by "c"). # So WT s31 cm5 is wildtype target, with forward occlusion, plus m5 crRNAraw_data_redone = pd.read_excel('RNAProbe' + RNA_probe_suffix_NOC_conditions + '_indexed.xlsx')num_dil = 8  # including the "nospike" condition (negative control)num_replicates = 3  # set to 1 to average all data up toptimes = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)def get_rep_data(col_name, raw_data_to_use):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates    if col_name in raw_data_to_use.columns:         if (col_name + '.1' in raw_data_to_use.columns) and (col_name + '.2' in raw_data_to_use.columns):            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                       raw_data_to_use[col_name + '.1'],                                                      raw_data_to_use[col_name + '.2'])))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name, col_name + '.1', col_name + '.2'], axis=1, inplace=True)          elif (col_name + '.1' in raw_data_to_use.columns):            print('Only have 2 replicates for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                       raw_data_to_use[col_name + '.1'],                                                      np.zeros(raw_data_to_use[col_name].shape))))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_to_use[col_name],                                                      np.zeros(raw_data_to_use[col_name].shape),                                                     np.zeros(raw_data_to_use[col_name].shape))))            ## To check if we missed anything            # raw_data_to_use.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data_to_use.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)#%%num_replicates = 3  # set to 1 to average all data up topmuts = ['It1', 'It2', 'It3']occs = ['no_occ', 'rev_occ']WT_spikein = np.zeros((len(muts), len(occs), num_dil, len(times), num_replicates))for e_mut, mut in enumerate(muts):    for e_occ, occ in enumerate(occs):        if occ == 'no_occ':            occ_label = ' NOC'        elif occ == 'rev_occ':            occ_label = 'Occ'        for dil in range(num_dil):            if dil == num_dil - 1:                dil_label = 'nospike'            else:                dil_label = 'dil' + str(dil + 1)            col_name = mut + occ_label + ' ' + dil_label            raw_data_to_use = raw_data            if occ == 'no_occ':                raw_data_to_use = raw_data_redone            WT_spikein[e_mut, e_occ, dil, :, :] = get_rep_data(col_name, raw_data_to_use)    NTC_rev_occ_data = get_rep_data('Occ NTC', raw_data)NTC_no_occ_data = get_rep_data('NOC NTC', raw_data_redone)NTC_data = {'no_occ': NTC_no_occ_data, 'rev_occ': NTC_rev_occ_data}#%% ED Fig. 7Acolors_series_blue = ['#D2E7FB', '#A8D5FB', '#7FC2FD', '#3AA1FB', '#3685C9', '#1C5F9C', '#046361'][::-1] + [colors[2]] + colors[6:]allele_freqs = ['50', '11', '5.9', '3.0', '1.5', '0.78', '0.39', '0']fig, axs = plt.subplots(nrows=2, ncols=3, figsize=(9, 5))for e_occ, occ in enumerate(['no_occ', 'rev_occ']):    for e_mut, mut in enumerate(muts):        axs0 = e_occ        axs1 = e_mut        ax = axs[axs0, axs1]        for dil in range(num_dil):            ax.plot(times / 60,                      np.mean(WT_spikein[e_mut, e_occ, dil, :, :], -1)                     # / WT_spikein[e_mut, e_occ, dil, -1, replicate]                     ,                     color=colors_series_blue[dil], #colors[dil],                      # linestyle=linestyles[replicate],                     label=(allele_freqs[dil]))            ax.fill_between(times / 60,                              np.min(WT_spikein[e_mut, e_occ, dil, :, :], -1),                             np.max(WT_spikein[e_mut, e_occ, dil, :, :], -1),                             color=colors_series_blue[dil], #colors[dil],                              alpha=0.2)        for NTC_occ in ['no_occ', 'rev_occ']:            ax.plot(times / 60,                      np.mean(NTC_data[NTC_occ], -1)                     # / max(10000, NTC_data[occ][-1, replicate])                     ,                     color={'no_occ': 'gray', 'rev_occ': 'k'}[NTC_occ],                      label=('NTC, ' +                             {'no_occ': 'no', 'rev_occ': 'with'}[NTC_occ]                            + ' occluder'                            ))            ax.fill_between(times / 60,                              np.min(NTC_data[NTC_occ], -1),                             np.max(NTC_data[NTC_occ], -1),                             color={'no_occ': 'gray', 'rev_occ': 'k'}[NTC_occ],                              alpha=0.2)        if axs0 == 0:            ax.set_title({'It1' : r'$A>C$', 'It2': r'$A>G$', 'It3': r'$A>U$'}[mut])            yticks = [0, 5000, 10000]            ylim = [0, 12000]        elif axs0 == 1:            yticks = [0, 2500, 5000]            ylim = [0, 5500]                    if axs1 == axs.shape[1] - 1 and axs0 == 0:            ax.legend(title='Allele frequency (%)',                        bbox_to_anchor=(1.05, 1))        if axs0 == axs.shape[0] - 1:            ax.set_xlabel('Time (hr)')            ax.set_xticks([0, 1, 2, 3])        else:            ax.set_xticks([0, 1, 2, 3], ['']*4)        if axs1 == 0:            ax.set_ylabel(                {'no_occ': 'No', 'rev_occ': 'With'}[occ] + ' occluder' + '\n'                'Fluorescence (a.u.)')            ax.set_yticks(yticks)        else:            ax.set_yticks(yticks, ['']*len(yticks))        ax.set_ylim(ylim)plt.show()#%% Find final projected value of each curve more accuratelyfit_type = 'rab'  # 'rab'time_series_point_to_start_fit = 15  # 15def fit_data(time_series, xdata=times_float, fit_type=fit_type, yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        if RNA_probe_suffix == '065':            min_max_fluorescence = 8000        if RNA_probe_suffix == '060':            min_max_fluorescence = 8000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':  ## NOTICE THAT WE CHANGED UPPER BOUND OF b ##        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max * 2])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)if fit_type == 'rib':    def get_r(fit_params):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)        r_tot = 1 / (1/r + 1/r2)        return(r_tot)        def get_r_err(fit_params, cov):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)                sigma_r = cov[0, 0]        sigma_r2 = cov[1, 1]        return(np.sqrt((r2 * sigma_r)**2 + (r * sigma_r2)**2) / (r + r2))        # if r < r2:        #     return(sigma_r)        # else:        #     return(sigma_r2)else:    def get_r(fit_params):        return(np.exp(fit_params[0]))        def get_r_err(fit_params, cov):        return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]))WT_spikein_fin = np.zeros(np.shape(WT_spikein)[:-2] + (num_replicates,))WT_spikein_fin_fit = np.zeros(np.shape(WT_spikein)[:-2] + (num_replicates,))WT_spikein_fit_pred = np.zeros(np.shape(WT_spikein)[:-2] +                                (len(times) - time_series_point_to_start_fit,                                num_replicates))WT_spikein_log_activity = np.zeros(np.shape(WT_spikein)[:-2] + (num_replicates,))for e_occ, occ in enumerate(occs):    for e_mut, mut in enumerate(muts):        for dil in range(num_dil):            WT_spikein_fin[e_mut, e_occ, dil, :] = WT_spikein[e_mut, e_occ, dil, -1, :]            for replicate in range(num_replicates):                fit_params, covariance, fit_pred = fit_data(                    WT_spikein[e_mut, e_occ, dil, time_series_point_to_start_fit:, replicate],                    xdata=times_float[time_series_point_to_start_fit:] - times_float[time_series_point_to_start_fit])                WT_spikein_fin_fit[e_mut, e_occ, dil, replicate] = fit_params[-1]                WT_spikein_fit_pred[e_mut, e_occ, dil, :, replicate] = fit_pred                WT_spikein_log_activity[e_mut, e_occ, dil, replicate] = np.log2(get_r(fit_params))#%% Fig. 3hfrom scipy.stats import ttest_1sampfrom  matplotlib.colors import LinearSegmentedColormaplinear_cmap=LinearSegmentedColormap.from_list('rg',["w", colors[7]                                                    ], N=256) linear_cmap_gray_white = LinearSegmentedColormap.from_list('rg', [gray_colors[0], 'w'], N=256) linear_cmap_white_blue_green = matplotlib.colormaps['BuGn']#(np.linspace(0, 1, 256))linear_cmap_gray_white_blue_green=LinearSegmentedColormap.from_list(    'rg',    list(linear_cmap_gray_white(np.linspace(0, 1, 256))) + list(linear_cmap_white_blue_green(np.linspace(0, 1, 256))),    N=512)allele_freqs = ['50', '11', '5.9', '3.0', '1.5', '0.78', '0.39']modified_num_dil = num_dil #- subtract_nospikefor plot_activity in [True]:  # either plot activities, or plot just final fluorescence ratios    heatmap_data = np.zeros((len(occs) * len(muts), num_dil))    p_vals = np.zeros(heatmap_data.shape)    log_fxn = np.log  # lambda x:x  # Only relevant if plot_activity = False                group_occ = True  # should occs be group together (True) or mutations grouped together (False)    for subtract_nospike in [True]:        for e_occ, occ in enumerate(['no_occ', 'rev_occ']):            for e_mut, mut in enumerate(muts):                if subtract_nospike:                    if plot_activity:                        to_subtract = np.mean(WT_spikein_log_activity[e_mut, :, -1, :], -1)                    else:                        to_subtract = np.mean(WT_spikein[e_mut, :, -1, -1, :], -1)                else:                    to_subtract = np.zeros(2)                                    if plot_activity:                    data_to_average = (WT_spikein_log_activity[e_mut, e_occ, :modified_num_dil, :]                                    - to_subtract[e_occ])                    popmean = 0.  # since we're looking at the subtraction of logs, 0. is the null value                else:                    data_to_average = log_fxn(                        (WT_spikein[e_mut, e_occ, :, -1, :]                         - np.mean(NTC_data[occ][-1, :]))                        / (to_subtract[e_occ]                           - np.mean(NTC_data[occ][-1, :])))                    popmean=log_fxn(1.)                                if group_occ:                    idx = len(muts) * e_occ + e_mut                else:                    idx = len(occs) * e_mut + e_occ                                heatmap_data[idx, :] = np.mean(                    data_to_average,                     -1)                                for dil in range(num_dil):                    _, p_vals[idx, dil] = ttest_1samp(                        data_to_average[dil, :],                         popmean=popmean,                         alternative='greater')                            plt.figure(figsize=(4,4))  # default is 6,4     if plot_activity:        exp_fxn = lambda x: x #np.exp  # plot the ratios of activities in linear space if this is np.exp;         # otherwise plot the difference of log_activities        heatmap_data_to_plot = exp_fxn(heatmap_data[:, :-1])          popmean = exp_fxn(popmean)        title = 'Activity discrimination' + ' Ratio' * (exp_fxn == np.exp)        max_norm = np.max(heatmap_data_to_plot)  # exp_fxn(1.)  #     else:         heatmap_data_to_plot = heatmap_data[:, :-1]  # don't show the noise term        max_norm = np.max(heatmap_data_to_plot)        title = 'Discrimination Ratio'    plt.imshow(heatmap_data_to_plot,               # cmap=linear_cmap, #'magma_r',#'BuGn'               # norm=matplotlib.colors.Normalize(popmean, max_norm),                              cmap=linear_cmap_gray_white_blue_green,#'PRGn',#'PiYG', #'RdYlBu',               norm=matplotlib.colors.Normalize(-max_norm, max_norm),               )    # Annotate with significance    for mut_occ in range(2 * len(muts)):        for dil in range(num_dil):            # if p_vals[mut_occ, dil] < 0.001:            #     plt.annotate('***', (dil-0.2, mut_occ-0.1))            # elif p_vals[mut_occ, dil] < 0.01:            #     plt.annotate('**', (dil, mut_occ-0.1))            if p_vals[mut_occ, dil] < 0.05:                plt.annotate('*', (dil+0.2, mut_occ-0.1))        # plt.xlabel('Dilution')    # plt.xticks(range(modified_num_dil - 1), dilutions_short[:-1], rotation=30)    plt.xlabel('Allele frequency (%)')    plt.xticks(range(modified_num_dil - 1), allele_freqs,                rotation=45               )        cbar = plt.colorbar(label=['Final Fluorescence',                 title,                ][subtract_nospike],                  # ticks = [0, 0.5, 1.],                  fraction=0.04, pad=0.04,                 )    if group_occ:        plt.yticks(range(2 * len(muts)),                    [{'It1' : r'$A>C$', 'It2': r'$A>G$', 'It3': r'$A>U$'}[mut] for mut in muts*len(occs)])        plt.ylabel('  With occluder    No occluder   ')    else:        plt.yticks(range(2 * len(muts)),                    [{'no_occ': 'N', 'rev_occ': 'W'}[occ] for occ in occs*len(muts)])        plt.ylabel(r'$A>C$' + ' '*10 + r'$A>G$'+ ' '*10 + r'$A>U$')    plt.show()#%% ED Fig. 5Bplt.figure()for replicate in range(num_replicates):    plt.plot(times / 60, NTC_data['no_occ'][:, replicate],              color='gray',              # linestyle=linestyles[replicate],             label='NTC, no occluder'*(replicate==0))    plt.plot(times / 60, NTC_data['rev_occ'][:, replicate],              color='k',              # linestyle=linestyles[replicate],             label='NTC, with occluder'*(replicate==0))plt.xlabel('Time (hr)')plt.ylabel('Fluorescence (a.u.)')plt.xticks([0, 1, 2, 3])plt.legend()plt.show()#%% ED Fig. 5#%% Load dataRNA_probe_suffix = '042'  raw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_indexed.xlsx')# Naming scheme: target comes first, crRNA comes second (and is preceded by "c"). # So WT s31 cm5 is wildtype target, with forward occlusion, plus m5 crRNAraw_data_NOC_lowconc = pd.read_excel('RNAProbe' + '076_077' + '_indexed.xlsx')num_replicates = 2  # set to 1 to average all data up topfit_type = 'rib'times = raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)def get_rep_data(col_name):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates        if col_name in raw_data.columns:         if (col_name + '.1' in raw_data.columns):            data_to_return = np.transpose(np.vstack((raw_data[col_name],                                                       raw_data[col_name + '.1'])))            ## To check if we missed anything            # raw_data.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data[col_name],                                                      raw_data[col_name])))            ## To check if we missed anything            # raw_data.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)def get_col_name(mut, rev_occ, fwd_occ):    if fwd_occ != 'NOC' and fwd_occ != 'NTC':        col_name = mut + rev_occ + '_28_' + fwd_occ    else:        col_name = mut + rev_occ + '_' + fwd_occ       if col_name in raw_data.columns:        return(col_name)    print('Could not find col_name for ', mut, fwd_occ, rev_occ)    return(False)def get_rep_data_NOC_lowconc(col_name):    # Each column name appears twice for two replicates; return both    # Some of the data was botched in the experiment, so we only have 0 or 1 replicates        if col_name in raw_data_NOC_lowconc.columns:         if (col_name + '.1' in raw_data_NOC_lowconc.columns):            data_to_return = np.transpose(np.vstack((raw_data_NOC_lowconc[col_name],                                                       raw_data_NOC_lowconc[col_name + '.1'])))            ## To check if we missed anything            # raw_data_NOC_lowconc.drop(labels=[col_name, col_name + '.1'], axis=1, inplace=True)          else:            print('Only have 1 replicate for ' + col_name)            data_to_return = np.transpose(np.vstack((raw_data_NOC_lowconc[col_name],                                                      raw_data_NOC_lowconc[col_name])))            ## To check if we missed anything            # raw_data_NOC_lowconc.drop(labels=[col_name], axis=1, inplace=True)         if num_replicates == 1:  # meaning we want to average the data at this step            data_to_return = np.expand_dims(np.mean(data_to_return, -1), -1)    else:        print(col_name + ' not in raw_data_NOC_lowconc.columns')        data_to_return = np.zeros((len(times), num_replicates))        return(data_to_return)def get_col_name_NOC_lowconc(mut):    if mut == 'wt':         mut = 'WT'    return(mut + ' NOC')def fit_data(time_series, xdata=times_float, fit_type=fit_type, yerr=None,              min_max_fluorescence=None, fluor_max=np.max(raw_data.max()), p0=None):    # r is the rate of the exponential; a is min; b is max; start_time is t offset    # The log of the rate of the exponential, log_r, always needs to be the first parameter    min_data = time_series[0]    def fit_fxn_exp_rs(t, log_r, start_time):         a = min_data        b = fluor_max        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rsb(t, log_r, start_time, b):         a = min_data        r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - start_time)))    def fit_fxn_exp_rab(t, log_r, a, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))    def fit_fxn_exp_rb(t, log_r, b):         r = np.exp(log_r)        return(b - (b - a) * np.exp(-r * (t - 0)))        def fit_fxn_exp_rib(t, log_r, log_r2, b):         r = np.exp(log_r)        r2 = np.exp(log_r2)        # return(a + b * (r * (1 - np.exp(-r2 * t)) - r2 * (1 - np.exp(-r * t))) / (r - r2))        return(b + (a - b) * (            r * np.exp(-r2 * t) - r2 * np.exp(-r * t)) / (r - r2))    if min_max_fluorescence is None:        if RNA_probe_suffix == '042':            min_max_fluorescence = 7000        if fit_type=='rs':        fit_fxn = fit_fxn_exp_rs        p0 = [-3, 0]        bounds = ([-np.inf, -np.inf], [np.inf, np.inf])    elif fit_type == 'rsb':        fit_fxn = fit_fxn_exp_rsb        p0 = [-3, 0, fluor_max]        bounds = ([-np.inf, -np.inf, min_max_fluorescence], [np.inf, np.inf, fluor_max])    elif fit_type == 'rab':  ## NOTICE THAT WE CHANGED UPPER BOUND OF b ##        fit_fxn = fit_fxn_exp_rab        p0 = [-3, min_data, fluor_max]        bounds = ([-np.inf, 0., min_max_fluorescence], [np.inf, np.inf, fluor_max * 2])    elif fit_type == 'rb':  # force a to be time_series[0]        fit_fxn = fit_fxn_exp_rb        a = time_series[0]        p0 = [-3, fluor_max]        bounds = ([-np.inf, min_max_fluorescence], [np.inf, fluor_max])    elif fit_type == 'rib':  # force a to be time_series[0]; include intermediate state        fit_fxn = fit_fxn_exp_rib        # a = time_series[0]        a = min(time_series[0], time_series[-1])  # to deal with fully saturated curves        if p0 is None:            p0 = [-5., -5.1, fluor_max]        bounds = ([-10., -10., min_max_fluorescence],                   [np.inf, np.inf, fluor_max])    # try:    fit_params, covariance = optimize.curve_fit(        fit_fxn,         xdata=xdata,  # x data, passed to fit_fxn_exp as first argument        ydata=time_series,  # data that's being fit        p0=p0,  # initial guess of the parameters        sigma=yerr,        bounds=bounds        )    fit_pred = fit_fxn(xdata, *fit_params)    # except:    #     n_params = len(p0)    #     fit_params = np.zeros(n_params)    #     covariance = np.zeros((n_params, n_params))    #     fit_pred = np.zeros(len(time_series))        return(fit_params, covariance, fit_pred)if fit_type == 'rib':    def get_r_in_hours(fit_params):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)        r_tot = 1 / (1/r + 1/r2)        return(r_tot * 60)        def get_r_err_in_hours(fit_params, cov):        log_r, log_r2, b = fit_params        r = np.exp(log_r)        r2 = np.exp(log_r2)                sigma_r = cov[0, 0]        sigma_r2 = cov[1, 1]        return((np.sqrt((r2 * sigma_r)**2 + (r * sigma_r2)**2) / (r + r2)) * 60)        # if r < r2:        #     return(sigma_r)        # else:        #     return(sigma_r2)else:    def get_r_in_hours(fit_params):        return(np.exp(fit_params[0]) * 60)        def get_r_err_in_hours(fit_params, cov):        return(np.sqrt(np.exp(fit_params[0])**2 * cov[0, 0]) * 60)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)#%% muts = ['wt', 'm5', 'm11', 'm4-11']rev_occs = ['', 'Occ']fwd_occs = ['NOC', '19', '31', '52', '61']data = np.zeros((len(muts), len(rev_occs), len(fwd_occs), len(times), num_replicates))for e_mut, mut in enumerate(muts):    for e_rev_cc, rev_occ in enumerate(rev_occs):        for e_fwd_occ, fwd_occ in enumerate(fwd_occs):            data[e_mut, e_rev_cc, e_fwd_occ, :, :] = get_rep_data(                get_col_name(mut, rev_occ, fwd_occ))# NTC dataNTC_data = np.zeros((len(muts), len(rev_occs), len(times), num_replicates))for e_mut, mut in enumerate(muts):    for e_rev_occ, rev_occ in enumerate(rev_occs):        NTC_data[e_mut, e_rev_occ, :, :] = get_rep_data(            get_col_name(mut, rev_occ, 'NTC'))# NOC_lowconc dataNOC_lowconc_data = np.zeros((len(muts), len(times), num_replicates))for e_mut, mut in enumerate(muts):    NOC_lowconc_data[e_mut, :, :] = get_rep_data_NOC_lowconc(        get_col_name_NOC_lowconc(mut))#%% Fit dataactivities = np.zeros((len(muts), len(rev_occs), len(fwd_occs), num_replicates))activity_errs = np.zeros((len(muts), len(rev_occs), len(fwd_occs), num_replicates))fit_preds = np.zeros((len(muts), len(rev_occs), len(fwd_occs), len(times), num_replicates))for e_mut, mut in enumerate(muts):    for e_rev_occ, rev_occ in enumerate(rev_occs):        for e_fwd_occ, fwd_occ in enumerate(fwd_occs):            for replicate in range(num_replicates):                data_to_fit = data[e_mut, e_rev_occ, e_fwd_occ, :, replicate]                 fit_params, covariance, fit_pred = fit_data(data_to_fit, fit_type=fit_type)                activities[e_mut, e_rev_occ, e_fwd_occ, replicate] = get_r_in_hours(fit_params)                activity_errs[e_mut, e_rev_occ, e_fwd_occ, replicate] = get_r_err_in_hours(fit_params, covariance)                fit_preds[e_mut, e_rev_occ, e_fwd_occ, :, replicate] = fit_predNTC_activities = np.zeros((len(muts), len(rev_occs), num_replicates))NTC_activity_errs = np.zeros((len(muts), len(rev_occs), num_replicates))NTC_fit_preds = np.zeros((len(muts), len(rev_occs), len(times), num_replicates))for e_mut, mut in enumerate(muts):    for e_rev_occ, rev_occ in enumerate(rev_occs):        for replicate in range(num_replicates):            data_to_fit = NTC_data[e_mut, e_rev_occ, :, replicate]             fit_params, covariance, fit_pred = fit_data(data_to_fit, fit_type=fit_type)            NTC_activities[e_mut, e_rev_occ, replicate] = get_r_in_hours(fit_params)            NTC_activity_errs[e_mut, e_rev_occ, replicate] = get_r_err_in_hours(fit_params, covariance)            NTC_fit_preds[e_mut, e_rev_occ, :, replicate] = fit_predNOC_lowconc_activities = np.zeros((len(muts), num_replicates))NOC_lowconc_activity_errs = np.zeros((len(muts), num_replicates))NOC_lowconc_fit_preds = np.zeros((len(muts), len(times), num_replicates))for e_mut, mut in enumerate(muts):    for replicate in range(num_replicates):        data_to_fit = NOC_lowconc_data[e_mut, :, replicate]         fit_params, covariance, fit_pred = fit_data(data_to_fit, fit_type=fit_type)        NOC_lowconc_activities[e_mut, replicate] = get_r_in_hours(fit_params)        NOC_lowconc_activity_errs[e_mut, replicate] = get_r_err_in_hours(fit_params, covariance)        NOC_lowconc_fit_preds[e_mut, :, replicate] = fit_predsaturated_activity_level = np.mean(activities[muts.index('m4-11'),                                      rev_occs.index(''),                                      fwd_occs.index('19'), :])#%% Plot fluorescencemut_fit = {'wt': 'None',       'm5': '5U>A',       'm11': '11G>C',       'm4-11': '4G>C, 11G>C'}for e_rev_occ, rev_occ in enumerate(rev_occs):    for e_fwd_occ, fwd_occ in enumerate(fwd_occs):        plt.figure()        for e_mut, mut in enumerate(muts):            for replicate in range(num_replicates):                plt.plot(times,                         data[e_mut, e_rev_occ, e_fwd_occ, :, replicate],                          color=colors[e_mut],                         label=mut_fit[mut]*(replicate==0)                         )                plt.plot(times,                         fit_preds[e_mut, e_rev_occ, e_fwd_occ, :, replicate],                          '--',                         color=colors[e_mut],                         label=(mut_fit[mut] + ' fit')*(replicate==0)                         )        for e_mut, mut in enumerate(muts):            for replicate in range(num_replicates):                plt.plot(times,                         NTC_data[e_mut, e_rev_occ, :, replicate],                          color=gray_colors[e_mut],                         label=(mut_fit[mut] + ' NTC')*(replicate==0)                         )                plt.plot(times,                         NTC_fit_preds[e_mut, e_rev_occ, :, replicate],                          '--',                         color=gray_colors[e_mut],                         label=(mut_fit[mut] + ' NTC fit')*(replicate==0)                         )        plt.xlabel('Time (min)')        plt.ylabel('Fluorescence (a.u.)')        plt.legend(bbox_to_anchor=(1.05, 1), title='crRNA Mutation', ncol=2)        plt.title({'NOC': 'No',                   '19': 's19',                   '31': 's31',                   '52': 's52',                   '61': 's61'}[fwd_occ] + ' target occluder; ' +                   {'': 'No', 'Occ': 'With'}[rev_occ] + ' crRNA occluder')        plt.show()        plt.figure()for e_mut, mut in enumerate(muts):    for replicate in range(num_replicates):        plt.plot(times,                 NOC_lowconc_data[e_mut, :, replicate],                  color=colors[e_mut],                 label=mut_fit[mut]*(replicate==0)                 )        plt.plot(times,                 NOC_lowconc_fit_preds[e_mut, :, replicate],                  '--',                 color=colors[e_mut],                 label=(mut_fit[mut] + ' fit')*(replicate==0)                 )for e_mut, mut in enumerate(muts):    for replicate in range(num_replicates):        plt.plot(times,                 NTC_data[e_mut, 0, :, replicate],                  color=gray_colors[e_mut],                 label=(mut_fit[mut] + ' NTC')*(replicate==0)                 )        plt.plot(times,                 NTC_fit_preds[e_mut, 0, :, replicate],                  '--',                 color=gray_colors[e_mut],                 label=(mut_fit[mut] + ' NTC fit')*(replicate==0)                 )plt.xlabel('Time (min)')plt.ylabel('Fluorescence (a.u.)')plt.legend(bbox_to_anchor=(1.05, 1), title='crRNA Mutation', ncol=2)plt.title('No target occluder; No crRNA occluder\nLow concentration')plt.show()       #%% ED Fig. 5Bfwd_occ_index = fwd_occs.index('31')def quotient_err(num, mean_den, std_den):    mean_num = np.mean(num)    std_num = np.std(num)    return(np.sqrt(        (mean_num**2)*(std_den**2) + (mean_den**2)*(std_num**2)) / (mean_den**2))def log2_err(x, err):  # if we have a measurement x with error err, what is the error on log2(x)?    return(np.sqrt((1/(x * np.log(2)))**2 * err**2))for plot_norm in [True]:    plt.figure()    for e_plot, (data_to_plot_input, err_to_plot) in enumerate([            # [activities[:, 0, 0, :], activity_errs[:, 0, 0, :]],  # NOC with high conc            [NOC_lowconc_activities, NOC_lowconc_activity_errs],  # NOC with low conc            [activities[:, 1, 0, :], activity_errs[:, 1, 0, :]],  # just rev occ            [activities[:, 0, fwd_occ_index, :], activity_errs[:, 0, fwd_occ_index, :]],  # just fwd occluder            [activities[:, 1, fwd_occ_index, :], activity_errs[:, 1, fwd_occ_index, :]]] +  # both rev and fwd occs            [[NTC_activities[:, 0, :], NTC_activity_errs[:, 0, :]],             [NTC_activities[:, 1, :], NTC_activity_errs[:, 1, :]]] * (1-plot_norm)            ):                if plot_norm:            # err_to_plot = (np.std(data_to_plot[1:, :], -1) * np.mean(data_to_plot[0, :]) -             #                np.std(data_to_plot[0, :]) * np.mean(data_to_plot[1:, :], -1)) / (            #                    np.mean(data_to_plot[0, :])**2)  # I think this was just wrong            ratio_to_plot = data_to_plot_input[0, :] / data_to_plot_input[1:, :]            data_to_plot = np.log2(ratio_to_plot)            err_to_plot_all = log2_err(ratio_to_plot,                                    np.expand_dims(quotient_err(data_to_plot_input[0, :],                                                np.mean(data_to_plot_input[1:, :], -1),                                                 np.std(data_to_plot_input[1:, :], -1)), 1))            err_to_plot = np.sqrt(np.sum(err_to_plot_all**2, -1)) / err_to_plot_all.shape[1]            num_muts_to_plot = len(muts) - 1        else:            data_to_plot = data_to_plot_input            err_to_plot = np.std(data_to_plot, -1),            num_muts_to_plot = len(muts)        plt.bar(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot),                 # mean_r(data_to_plot, r_errs=None, mean_exp=True, mean_axis=-1)                np.mean(data_to_plot, -1),                 color=colors[5 - num_muts_to_plot:],                )        plt.errorbar(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot),                      # mean_r(data_to_plot, r_errs=None, mean_exp=True, mean_axis=-1),                      np.mean(data_to_plot, -1),                      err_to_plot,                     marker='.',                     linestyle='',                      color='k'                     )        # Plot individual data points        for replicate in range(num_replicates):            plt.plot(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot) + (-1)**replicate * 0.3,                     data_to_plot[:, replicate],                     color='gray',                     linestyle='',                     markersize=5,                     marker='.'                     )                     # np.mean(err_to_plot, -1)    plt.xticks((num_muts_to_plot + 1) * np.arange(6) + 1.5 - 0.5*plot_norm,                ['None', 'crRNA', 'target', 'crRNA+\ntarget',                 'NTC\nNOC', 'NTC\ncrRNA'],               rotation=0)    if plot_norm:        plt.ylabel('Mismatch discrimination')        for e_mut, mut in enumerate(muts[1:]):            plt.bar([np.inf],                     [np.inf],                     color=colors[e_mut+2],                    label={'wt': 'None',                           'm5': '5U>A',                           'm11': '11G>C',                           'm4-11': '4G>C, 11G>C'}[mut]                    )        plt.legend(title='crRNA Mutation',#'Mismatch\n  position',                    bbox_to_anchor=(1.15, 1)                   )    else:        plt.ylabel('Activity (hr' + r'$^{-1}$' + ')')        plt.yscale('log')        for e_mut, mut in enumerate(muts):            plt.bar([np.inf],                     [np.inf],                     color=colors[e_mut+1],                    label={'wt': 'None',                           'm5': '5U>A',                           'm11': '11G>C',                           'm4-11': '4G>C, 11G>C'}[mut]                    )        plt.legend(title='crRNA Mutation')#'Mismatch position')    plt.xlabel('Occluder')    plt.show()#%% ED Fig. 5Afor plot_norm in [False]:    plt.figure(figsize=(12,4))    for e_plot, (data_to_plot, err_to_plot) in enumerate([            [activities[:, 0, 0, :], activity_errs[:, 0, 0, :]],  # NOC with high conc            [NOC_lowconc_activities, NOC_lowconc_activity_errs],  # NOC with low conc            [activities[:, 1, 0, :], activity_errs[:, 1, 0, :]],  # just rev occ            [activities[:, 0, 1, :], activity_errs[:, 0, 1, :]],  # just fwd occluder            [activities[:, 1, 1, :], activity_errs[:, 1, 1, :]],  # both rev and fwd occs            [activities[:, 0, 2, :], activity_errs[:, 0, 2, :]],  # just fwd occluder            [activities[:, 1, 2, :], activity_errs[:, 1, 2, :]],  # both rev and fwd occs            [activities[:, 0, 3, :], activity_errs[:, 0, 3, :]],  # just fwd occluder            [activities[:, 1, 3, :], activity_errs[:, 1, 3, :]],  # both rev and fwd occs            [activities[:, 0, 4, :], activity_errs[:, 0, 4, :]],  # just fwd occluder            [activities[:, 1, 4, :], activity_errs[:, 1, 4, :]]] +  # both rev and fwd occs            [[NTC_activities[:, 0, :], NTC_activity_errs[:, 0, :]],             [NTC_activities[:, 1, :], NTC_activity_errs[:, 1, :]]] * (1-plot_norm)            ):                if plot_norm:            err_to_plot = (np.std(data_to_plot[1:, :], -1) * np.mean(data_to_plot[0, :]) -                            np.std(data_to_plot[0, :]) * np.mean(data_to_plot[1:, :], -1)) / (                               np.mean(data_to_plot[0, :])**2)            data_to_plot = np.log2(data_to_plot[0, :] / data_to_plot[1:, :])            num_muts_to_plot = len(muts) - 1        else:            err_to_plot = np.std(data_to_plot, -1),            num_muts_to_plot = len(muts)        plt.bar(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot),                 # mean_r(data_to_plot, r_errs=None, mean_exp=True, mean_axis=-1)                np.mean(data_to_plot, -1),                 color=colors[5 - num_muts_to_plot:],                )        plt.errorbar(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot),                      # mean_r(data_to_plot, r_errs=None, mean_exp=True, mean_axis=-1),                      np.mean(data_to_plot, -1),                      err_to_plot,                     marker='.',                     linestyle='',                      color='k'                     )        # Plot individual data points        for replicate in range(num_replicates):            plt.plot(e_plot * (num_muts_to_plot + 1) + np.arange(num_muts_to_plot) + (-1)**replicate * 0.3,                     data_to_plot[:, replicate],                     color='gray',                     linestyle='',                     markersize=5,                     marker='.'                     )                     # np.mean(err_to_plot, -1)    plt.xticks((num_muts_to_plot + 1) * np.arange(13) + 1.5 - 0.5*plot_norm,                ['None', 'None (reduced\n conc.)\n\n', 'crRNA', 's19',                 's19+\ncrRNA', 's31', 's31+\ncrRNA', 's52', 's52+\ncrRNA',                 's61', 's61+\ncrRNA', 'NTC', 'NTC\ncrRNA'],               rotation=45)    if plot_norm:        plt.ylabel('Mismatch discrimination')        for e_mut, mut in enumerate(muts[1:]):            plt.bar([np.inf],                     [np.inf],                     color=colors[e_mut+2],                    label={'wt': 'None',                           'm5': '5U>A',                           'm11': '11G>C',                           'm4-11': '4G>C, 11G>C'}[mut]                    )        plt.legend(title='crRNA Mutation',#'Mismatch\n  position',                   # bbox_to_anchor=(1.15, 1)                   )    else:        plt.ylabel('Activity (h' + r'$^{-1}$' + ')')        plt.yscale('log')        for e_mut, mut in enumerate(muts):            plt.bar([np.inf],                     [np.inf],                     color=colors[e_mut+1],                    label={'wt': 'None',                           'm5': '5U>A',                           'm11': '11G>C',                           'm4-11': '4G>C, 11G>C'}[mut]                    )        plt.legend(title='crRNA Mutation')#'Mismatch position')    if not plot_norm:        plt.plot([-0.5, (num_muts_to_plot + 1) *13],                  [saturated_activity_level] * 2,                 '--',                 color=gray_colors[1])        plt.plot([-0.5, (num_muts_to_plot + 1) *13],                  [np.max(NTC_activities)] * 2,                 '--',                 color=gray_colors[1])        plt.annotate('Saturated', ((num_muts_to_plot + 1) *3.5, saturated_activity_level*10),                     fontsize=18)        plt.axhspan(            saturated_activity_level, np.max(activities),                     color=gray_colors[0], alpha=0.3)    plt.xlabel('Occluder')    plt.show()#%% Fig. 4B, ED Fig. 10A #XXX#%% Load dataraw_data = pd.read_excel('RNAProbe136_indexed.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data.rename(col_renaming_dict, axis=1, inplace=True)times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['cDNOC', 'cONOC', 'cDocc', 'cOocc']targets = ['Dss undil', 'Oss undil', 'Dss 1/100', 'Oss 1/100', 'NTC', 'ampNTC']num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))col_names_loaded = []for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        for r in range(num_replicates):            col_name = crRNA + ' ' + target + ' r' + str(r + 1)            if target == 'NTC' and crRNA in ['cDocc', 'cOocc']:                col_name = crRNA[:2] + ' detNTC r' + str(r + 1)            if target == 'ampNTC':                if crRNA in ['cDocc', 'cOcc']:                    col_name = crRNA[:2] + ' ampNTC r' + str(r + 1)                else:                    col_name = ''            if col_name:                data[e_crRNA, e_target, :, r] = raw_data[col_name]                col_names_loaded += [col_name]#%% Fig. 4Blinear_cmap_white_purple = LinearSegmentedColormap.from_list('rg', ['w', '#0B3B65'], N=256) min_NTC = np.max(data[:, -2, :, :]) #np.max(np.mean(data, -1)[:, -1, :])data_mean = np.mean(data, -1)fin_fluor = data_mean[:, :, -1]max_fin_fluor = np.max(fin_fluor, 0)for colorbar_plot in [True, False]:    for e in range(2):        crRNAs_to_use = range(2) if e == 0 else range(2, 4)            fluor_ratio = np.log2(np.mean((data[crRNAs_to_use[1], :, :, :]) / (data[crRNAs_to_use[0], :, :, :]), -1))        # Don't want to consider the fluorescence ratio of noise, unless it's all noise        fluor_ratio[(np.max(data_mean, 0)<min_NTC*1.7) & np.expand_dims((max_fin_fluor > min_NTC*1.7), -1)] = 0        # ext_fluor is the fluorescence values at the point where the discrimination is highest        ext_fluor = np.transpose(np.array([data_mean[:, e, np.argmax(np.abs(i), -1)] for e, i in enumerate(fluor_ratio)]))                fluor_to_plot = ext_fluor  # fin_fluor        # max_fluor = np.max(np.mean(data, -1)[crRNAs_to_use, :, -1], 0)            targets_to_use = range(2) #range(2, 4)        if e == 1:            targets_to_use = [0, 1, -1]        fluor_to_plot = fluor_to_plot[crRNAs_to_use, :]        fluor_to_plot = fluor_to_plot[:, targets_to_use]        # max_fluor = max_fluor[targets_to_use]            plt.figure(figsize=(2+e,2))        plt.imshow(                (fluor_to_plot - min_NTC) * ((fluor_to_plot - min_NTC) > 0) /                 (np.max(fluor_to_plot, 0) - min_NTC                 )            ,            cmap=linear_cmap_white_purple,            aspect='auto',            vmin=0, vmax=1,            )            for i in range(len(crRNAs_to_use)):            plt.annotate(r'$\star$', (i-0.2, i+0.15), color='white', fontsize=30)            plt.yticks(range(len(crRNAs_to_use)),                    [{'cDNOC': 'Delta',                     'cONOC': 'Omicron',                     'cDocc': 'Delta',                     'cOocc': 'Omicron'}[crRNAs[i]] for i in crRNAs_to_use],                    # rotation=45                   )        plt.xticks(range(len(targets_to_use)),                    [{'D': 'Delta',                     'O': 'Omicron',                     'a': 'neg'}[targets[i][0]] for i in targets_to_use],                   rotation=0)        plt.title({'cDNOC': 'No occluder', 'cONOC': 'No occluder',                   'cDocc': 'With occluder', 'cOocc': 'With occluder'}[crRNAs[crRNAs_to_use[0]]])        if colorbar_plot:            plt.colorbar(label='Normalized fluorescence', shrink=2)        plt.ylabel('crRNA')        plt.xlabel('Target')        plt.show()#%% ED Fig. 10Atarget_groups = [[0,],                 [1],                 [4, 5]                 ]crRNA_groups = [[0,1], [2,3]]target_dict = {'Dss undil': 'De',               'Oss undil': 'Om',               'ampNTC': 'NTC',               'NTC': 'NTC'}ncols = 2nrows = 3fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(6, 8))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index #// len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index #// len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    if np.any(data[e_crRNA, e_target, :, r]):                        ax.plot(times,                                 data[e_crRNA, e_target, :, r],                                 color=colors_to_use[color_index],                                 linestyle=linestyles[e_crRNA % len(crRNA_group)],                                 label=target*(r==0)*((e_crRNA==0) + (e_crRNA==2))                                )        if e_tg == 2 and e_c == 1:            leg = ax.legend(ncol=1, fontsize=10, loc='upper left')                    ax.add_artist(leg)        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence (a.u.)')                    ax.set_title(['No occluder', 'With occluder'][e_c] + '; ' + target_dict[target]                     )        # ax.set_yticks([0, 5000, 10000])        if ax_index == 0:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='De')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='Om')                ax.legend(handles=lines,                                    loc='lower right',                                    title='crRNA',                                     fontsize=12,                                    )plt.subplots_adjust(wspace=0.45, hspace=0.35)fig.align_ylabels(axs)plt.show()#%% Fig. 4C, ED Fig. 9C #XXX#%% Load dataraw_data_NOC = pd.read_excel('627_invitro_NOCs.xlsx')raw_data_Occ = pd.read_excel('627_invitro_occluded.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data_NOC.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data_NOC.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data_NOC.rename(col_renaming_dict, axis=1, inplace=True)col_renaming_dict = dict()for e, col in enumerate(raw_data_Occ.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data_Occ.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data_Occ.rename(col_renaming_dict, axis=1, inplace=True)times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['WT', 'K', 'V', 'WTOcc', 'KOcc', 'VOcc']targets = ['FJ', '1918', 'VN', 'WSN K', '627V', 'WSN E', #WSN E is NO RNA; FJ is E; VN, 1918 are K           'NTC']num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))col_names_loaded = []for e_crRNA, crRNA in enumerate(crRNAs):    if crRNA[-1] == 'c':        raw_data_to_use = raw_data_Occ    else:        raw_data_to_use = raw_data_NOC    for e_target, target in enumerate(targets):        for r in range(num_replicates):            col_name = crRNA + ' ' + target + ' r' + str(r + 1)            data[e_crRNA, e_target, :, r] = raw_data_to_use[col_name]            col_names_loaded += [col_name]       #%% Fig. 4Cfin_fluor_all = np.mean(data, -1)[:, :, -1]linear_cmap_white_purple = LinearSegmentedColormap.from_list('rg', ['w', '#0B3B65'], N=256) for e, crRNAs_to_use in enumerate([range(3), range(3, 6)]):  # [[1, 0, 2], [4, 3, 5]]):    min_NTC = np.max(data[crRNAs_to_use, -1:, :, :]) #np.max(np.mean(data, -1)[crRNAs_to_use, -1:, :])    targets_to_use = range(6) #[1,2,3,0,4,5] #range(6)    fin_fluor = fin_fluor_all[crRNAs_to_use, :]    fin_fluor = fin_fluor[:, targets_to_use]    fig = plt.figure(figsize=(4.5,1.5))    plt.imshow(            (fin_fluor - min_NTC) * ((fin_fluor - min_NTC) > 0) /             (np.max(fin_fluor, 0) - min_NTC             )        ,        cmap=linear_cmap_white_purple,        vmin=0, vmax=1,        aspect='auto',        )    for i in range(5):        plt.annotate(r'$\star$',                     (i-0.24, (0 if i ==0 else 1 if i < 4 else 2) + 0.25),                      # (i-0.24, (0 if i <3 else 1 if i < 4 else 2) + 0.25),         color='white', fontsize=30)        plt.yticks(range(len(crRNAs_to_use)),                [{'WT': 'E',                 'K': 'K',                 'V': 'V',                 'WTOcc': 'E',                 'KOcc': 'K',                  'VOcc': 'V'}[crRNAs[i]] for i in crRNAs_to_use],                )    plt.title({'WT': 'No occluder', 'K': 'No occluder',                'WTOcc': 'With occluder', 'KOcc': 'With occluder'}[crRNAs[crRNAs_to_use[0]]])    plt.xticks(range(len(targets_to_use)),                [{'FJ': 'Fujian\nH5N1 2005',                 'VN': 'Vietnam\nH5N1 2005',                 'WSN K': 'WSN\nH1N1 E627K',                 '1918': '\nH1N1 1918',                 'WSN E': 'neg',                 '627V': '\nE627V'                 }[targets[i]] for i in targets_to_use],               rotation=60,               # ha='right', rotation_mode='anchor'               )    # create -5pt offset in tick labels x direction.     # https://stackoverflow.com/questions/14852821/aligning-rotated-xticklabels-with-their-respective-xticks    from matplotlib.transforms import ScaledTranslation    for el, label in enumerate(plt.gca().xaxis.get_majorticklabels()):        dx, dy = [-10 * (1 + (el < 4)), 0]        offset = ScaledTranslation(dx / fig.dpi, dy / fig.dpi, fig.dpi_scale_trans)        label.set_transform(label.get_transform() + offset)    # plt.colorbar(label='Normalized final fluorescence')    plt.ylabel('crRNA')    plt.xlabel('Target')    plt.show()#%% ED Fig. 9Ctarget_groups = [[0],                  [2],                  [4],                 [1],                 [3],                  [5, 6]]  crRNA_groups = [[0,1,2], [3,4,5]]target_names = {'FJ': 'Fujian H5N1 2005',  'VN': 'Vietnam H5N1 2005',  'WSN K': 'WSN H1N1 E627K',  '1918': 'H1N1 1918',  'WSN E': 'neg 2',  '627V': 'E627V',  'NTC': 'neg'  }ncols = 4nrows = 3fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(12, 8))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target and 'WSN E' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    ax.plot(times,                             data[e_crRNA, e_target, :, r],                             color=colors_to_use[color_index],                             linestyle=linestyles[e_crRNA % len(crRNA_group)],                             # label=target_names[target]*(r==0)*((e_crRNA==0) +(e_crRNA==3))                            )        # leg = ax.legend(ncol=1)                # ax.add_artist(leg)        ax.set_title(target_names[target])            if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)                    if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence (a.u.)')        # plt.title(target)        if ax_index == 6:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='E')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='K')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle=':', color='black',                             label='V')                ax.legend(handles=lines,                                    # loc='lower right',                                    title='crRNA',                                     )plt.suptitle('   No occluder                        With occluder',              fontsize=26,y=0.98)plt.subplots_adjust(wspace=0.45, hspace=0.25)fig.align_ylabels(axs)plt.show()#%% Fig. 4D, ED Fig. 10C #XXX#%% Define label_band# From https://stackoverflow.com/questions/67235301/vertical-grouping-of-labels-with-brackets-on-matplotlibdef add_ylabel_band(ax, top, bottom, label, *, spine_pos=-0.05, tip_pos=-0.02, text_offset=-0.05):    """    Helper function to add bracket around y-tick labels.    Parameters    ----------    ax : matplotlib.Axes        The axes to add the bracket to    top, bottom : floats        The positions in *data* space to bracket on the x-axis    label : str        The label to add to the bracket    spine_pos, tip_pos : float, optional        The position in *axes fraction* of the spine and tips of the bracket.        These will typically be negative    Returns    -------    bracket : matplotlib.patches.PathPatch        The "bracket" Aritst.  Modify this Artist to change the color etc of        the bracket from the defaults.    txt : matplotlib.text.Text        The label Artist.  Modify this to change the color etc of the label        from the defaults.    """    # grab the yaxis blended transform    # transform = ax.get_yaxis_transform()    # add the bracket    bracket = mpatches.PathPatch(        mpath.Path(            [                [tip_pos, top],                [spine_pos, top],                [spine_pos, bottom],                [tip_pos, bottom],            ]        ),        # transform=transform,        clip_on=False,        facecolor="none",        edgecolor="k",        linewidth=2,    )    ax.add_artist(bracket)    # add the label    txt = ax.text(        spine_pos + text_offset,        (top + bottom) / 2,        label,        ha="center",        va="center",        # rotation="vertical",        clip_on=False,        # transform=transform,    )    return bracket, txtdef add_xlabel_band(ax, top, bottom, label, *, spine_pos=-0.05, tip_pos=-0.02, text_offset=-0.05):    """    Helper function to add bracket around y-tick labels.    Parameters    ----------    ax : matplotlib.Axes        The axes to add the bracket to    top, bottom : floats        The positions in *data* space to bracket on the x-axis    label : str        The label to add to the bracket    spine_pos, tip_pos : float, optional        The position in *axes fraction* of the spine and tips of the bracket.        These will typically be negative    Returns    -------    bracket : matplotlib.patches.PathPatch        The "bracket" Aritst.  Modify this Artist to change the color etc of        the bracket from the defaults.    txt : matplotlib.text.Text        The label Artist.  Modify this to change the color etc of the label        from the defaults.    """    # grab the yaxis blended transform    # transform = ax.get_yaxis_transform()    # add the bracket    bracket = mpatches.PathPatch(        mpath.Path(            [                [tip_pos, top][::-1],                [spine_pos, top][::-1],                [spine_pos, bottom][::-1],                [tip_pos, bottom][::-1],            ]        ),        # transform=transform,        clip_on=False,        facecolor="none",        edgecolor="k",        linewidth=2,    )    ax.add_artist(bracket)    # add the label    txt = ax.text(        (top + bottom) / 2,        spine_pos + text_offset,        label,        ha="center",        va="center",        # rotation="vertical",        clip_on=False,        # transform=transform,    )    return bracket, txt#%% Load dataraw_data = pd.read_excel('H275Y.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data.rename(col_renaming_dict, axis=1, inplace=True)times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['C', 'T', 'COcc', 'TOcc']targets = ['34_1 C', '18_1 C', '61_1 C', '09_2 C', '82_2 C', '68_2 C', '24_2 C',            '34_1 T', '18_1 T', '61_1 T', '09_2 T', '82_2 T', '68_2 T', '24_2 T',           'NTC1', 'NTC2']targets_good_names = {'34_1 C': '2009 H1N1 H',                      '34_1 T': '2009 H1N1 Y',                      '18_1 C': '1934 H1N1 H',                      '18_1 T': '1934 H1N1 Y',                      '61_1 C': '1996 H5N1 H',                      '61_1 T': '1996 H5N1 Y',                      '09_2 C': '1999 H9N2 H',                      '09_2 T': '1999 H9N2 Y',                      '82_2 C': '1968 H2N2 H',                      '82_2 T': '1968 H2N2 Y',                      '68_2 C': '2004 H3N2 H',                      '68_2 T': '2004 H3N2 Y',                      'NTC1':   'NTC       1',                      'NTC2':   'NTC       2'}num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))col_names_loaded = []for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        for r in range(num_replicates):            if 'NTC' in target:                col_name = 'c' + target[-1] + crRNA + ' ' + 'NTC' + ' r' + str(r + 1)            else:                col_name = 'c' + target[3] + crRNA + ' ' + target + ' r' + str(r + 1)            data[e_crRNA, e_target, :, r] = raw_data[col_name]            col_names_loaded += [col_name]#%% Fig. 4Ddata_mean = np.mean(data, -1)fin_fluor_all = data_mean[:, :, -1]linear_cmap_white_purple = LinearSegmentedColormap.from_list('rg', ['w', '#0B3B65'], N=256) for e, crRNAs_to_use in enumerate([range(2), range(2, 4)]):    targets_to_use_all = [0,7,1,8,2,9, #-1,                          3,10,4,11,5,12, -2                      ]    # fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True, height_ratios=[1,1])    fig = plt.figure(figsize=(5.5,6)                     )    gs = gridspec.GridSpec(1,2, width_ratios=[6, 7])    ax1, ax2 = [plt.subplot(gs[0]), plt.subplot(gs[1])]    for n1n2 in range(2):        if n1n2 == 0:            min_NTC = np.max(data[:, -2, :, :]) #np.max(np.mean(data, -1)[:, -1, :])        else:            min_NTC = np.max(data[:, -1, :, :]) #np.max(np.mean(data, -1)[:, -1, :])                max_fin_fluor = np.max(fin_fluor_all, 0)        fluor_ratio = np.log2(np.mean((data[crRNAs_to_use[1], :, :, :]) / (data[crRNAs_to_use[0], :, :, :]), -1))        # Don't want to consider the fluorescence ratio of noise, unless it's all noise        fluor_ratio[(np.max(data_mean, 0)<min_NTC*1.7) & np.expand_dims((max_fin_fluor > min_NTC*1.7), -1)] = 0        # ext_fluor is the fluorescence values at the point where the discrimination is highest        ext_fluor = np.transpose(np.array([data_mean[:, e, np.argmax(np.abs(i), -1)] for e, i in enumerate(fluor_ratio)]))                fluor_to_plot = ext_fluor  # fin_fluor        # max_fluor = np.max(np.mean(data, -1)[crRNAs_to_use, :, -1], 0)                fluor_to_plot = fluor_to_plot[crRNAs_to_use, :] #fin_fluor_all[crRNAs_to_use, :]        if n1n2 == 0:            targets_to_use = targets_to_use_all[:6]            fluor_to_plot = fluor_to_plot[:, targets_to_use]            ax = ax1            ax.set_ylabel('crRNA')        else:            targets_to_use = targets_to_use_all[-7:]            fluor_to_plot = fluor_to_plot[:, targets_to_use]            ax = ax2        # If normalizing to crRNA instead of to target,         # comment in the two np.transpose, and change np.max(fin_fluor, 0) to np.max(fin_fluor, 1)        ax.imshow(            # np.transpose(            # np.transpose(                (                (fluor_to_plot - min_NTC) * ((fluor_to_plot - min_NTC) > 0)                # )                ) /                 (np.max(fluor_to_plot, 0) - min_NTC                 )                # )            ,            cmap=linear_cmap_white_purple,            vmin=0, vmax=1,            aspect='auto',            )        for i in range(6): #len(targets_to_use)):            ax.annotate(r'$\star$', (i-0.25, (i%2)+0.15),                          color='white', fontsize=20)                # plt.imshow(np.log(np.transpose(fin_fluor_mat_mean) / np.mean(fin_fluor_mat_mean, 1)))        ax.set_yticks(range(len(crRNAs_to_use)),                    [{'C': 'H',                     'T': 'Y',                     'COcc': 'H',                     'TOcc': 'Y'}[crRNAs[i]] for i in crRNAs_to_use],                    # rotation=45                   )        ax.set_xticks(range(len(targets_to_use)),                    [targets_good_names[targets[i]][-1] if i >= 0 else 'neg' for i in targets_to_use])        for i in range(len(targets_to_use)//2):            add_xlabel_band(ax, 2 * i, 2 * i + 1,                             targets_good_names[targets[targets_to_use[2 * i]]][:4] + '\n' +                             targets_good_names[targets[targets_to_use[2 * i]]][5:-2],                            spine_pos=1.6 +60 * 0.015,                             tip_pos=1.6 +60 * 0.012,                             text_offset=0.5 +60 * 0.006)        ax.set_xlabel('\n\n\nTarget')    plt.suptitle({'C': 'No occluder',                'COcc': 'With occluder'}[crRNAs[crRNAs_to_use[0]]],                 y=0.932#0.6                 )    plt.tight_layout()    plt.show()#%% ED Fig. 10Ctarget_groups = [[0],                 [1],                 [2],                 [3],                 [4],                 [5],                 [14],                 [7],                 [8],                 [9],                 [10],                 [11],                 [12],                 [15]                 ]crRNA_groups = [[0,1], [2,3]]target_dict = {'34_1 C': '2009 H1N1 H',                      '34_1 T': '2009 H1N1 Y',                      '18_1 C': '1934 H1N1 H',                      '18_1 T': '1934 H1N1 Y',                      '61_1 C': '1996 H5N1 H',                      '61_1 T': '1996 H5N1 Y',                      '09_2 C': '1999 H9N2 H',                      '09_2 T': '1999 H9N2 Y',                      '82_2 C': '1968 H2N2 H',                      '82_2 T': '1968 H2N2 Y',                      '68_2 C': '2004 H3N2 H',                      '68_2 T': '2004 H3N2 Y',                      'NTC1':   'NTC 1',                      'NTC2':   'NTC 2'}ncols = 4nrows = 7fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(12, 16))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    ax.plot(times,                             data[e_crRNA, e_target, :, r],                             color=colors_to_use[color_index],                             linestyle=linestyles[e_crRNA % len(crRNA_group)],                             label=target*(r==0)*((e_crRNA==0) +(e_crRNA==3))                            )        # leg = ax.legend(ncol=1, fontsize=10)                # ax.add_artist(leg)        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence\n(a.u.)')        ax.set_title(#['No occluder', 'With occluder'][e_c] + '\n' +                      target_dict[target]                     )        # ax.set_yticks([0, 5000, 10000])        if ax_index == 0:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='H')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='Y')                ax.legend(handles=lines,                                    loc='upper left',                                    title='crRNA',                                     fontsize=12,                                    )        # if e_tg == len(target_groups) - 1:        #     ax.annotate('NTC', [10,1600], fontsize=18)plt.subplots_adjust(wspace=0.45, hspace=0.45)fig.align_ylabels(axs)plt.suptitle('   No occluder                       With occluder',              fontsize=26,y=0.94)plt.show()#%% Fig. 4E, ED Fig. 10B #XXX#%% Load plate mapRNA_probe_suffix = '125'plate_map = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_data.xlsx',    index_col=0,    sheet_name='Plate Map')plate_map_dict = dict()for i in plate_map.columns:    for j in plate_map.index:        if type(plate_map[i][j]) == str:            plate_map_dict[j + str(i)] = plate_map[i][j]plate_map_dict_inv = dict()for val in np.unique([i for i in plate_map_dict.values()]):     plate_map_dict_inv[val] = []for i in plate_map_dict.keys():    plate_map_dict_inv[plate_map_dict[i]] += [i]    #%% Load dataraw_data = pd.read_excel('RNAProbe' + RNA_probe_suffix + '_data.xlsx',    sheet_name='Clean data')times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['cO', 'cD']targets = np.unique([i[3:] for i in plate_map_dict.values()])num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        chambers = plate_map_dict_inv[crRNA + ' ' + target]        for r, chamber in enumerate(chambers):            data[e_crRNA, e_target, :, r] = raw_data[chamber]                   #%% Data with experimental error that had to be rerunraw_data_2 = pd.read_excel('RNAProbe136_indexed.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data_2.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data_2.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data_2.rename(col_renaming_dict, axis=1, inplace=True)data_2 = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))targets_2 = []for col in raw_data_2.columns[32:]:    if not any([i in col for i in ['NOC', 'det']]):        col_split = col.split(' ')        crRNA = col_split[0]        target = col_split[1]        r = int(col_split[2][-1]) - 1                e_crRNA = crRNAs.index(crRNA)        if target in targets:            e_target = list(targets).index(target)        elif 'amp' in target:            e_target = list(targets).index('NTC')        else:            for target_mod in ['DeP', 'OmP']:                rev_target = target_mod + target[1:]                if rev_target in targets:                    e_target = list(targets).index(rev_target)                    break        if targets[e_target] not in targets_2:            targets_2 += [targets[e_target]]        data_2[e_crRNA, e_target, :, r] = raw_data_2[col]#%% Fig. 4Entc_data = data[:, 10, :, :]pos_cutoff = np.max(ntc_data) #np.max(fin_fluor[:, 10]) * 1.5data_mean = np.mean(data, -1)fin_fluor = data_mean[:, :, -1]max_fin_fluor = np.max(fin_fluor, 0)# This is the difference between cD and cOfluor_ratio = np.log2(np.mean((data[1, :, :, :]) / (data[0, :, :, :]), -1))# Don't want to consider the fluorescence ratio of noise, unless it's all noisefluor_ratio[(np.max(data_mean, 0)<pos_cutoff*1.5) & np.expand_dims((max_fin_fluor > pos_cutoff*1.5), -1)] = 0ext_fluor_ratio = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_ratio])norm_fin_fluor = fin_fluor / pos_cutoffntc_data_2 = data_2[:, 10, :, :]pos_cutoff_2 = np.max(ntc_data_2)data_mean_2 = np.mean(data_2, -1)fin_fluor_2 = data_mean_2[:, :, -1]max_fin_fluor_2 = np.max(fin_fluor_2, 0)fluor_ratio_2 = np.mean(np.log2((data_2[1, :, :, :]) / (data_2[0, :, :, :])), -1)# Don't want to consider the fluorescence ratio of noise, unless it's all noisefluor_ratio_2[(np.max(data_mean_2, 0)<pos_cutoff_2*1.7) & np.expand_dims((max_fin_fluor_2 > pos_cutoff_2 * 1.7), -1)] = 0ext_fluor_ratio_2 = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_ratio_2])norm_fin_fluor_2 = fin_fluor_2 / pos_cutoff_2for e_target, target in enumerate(targets):    for e_crRNA, crRNA in enumerate(crRNAs):        if fin_fluor_2[e_crRNA, e_target] > 0:            fin_fluor[e_crRNA, e_target] = fin_fluor_2[e_crRNA, e_target]            norm_fin_fluor[e_crRNA, e_target] = norm_fin_fluor_2[e_crRNA, e_target]    if not np.isnan(ext_fluor_ratio_2[e_target]):        ext_fluor_ratio[e_target] = ext_fluor_ratio_2[e_target]delta_targets = np.array([1,2]) omicron_targets = np.array([0] + list(range(11, 28))) negative_targets = np.array(list(range(3, 8)) + [9])plt.figure(figsize=(4.6, 4))  # default is 6,4plt.plot(np.max(norm_fin_fluor, 0)[delta_targets],         ext_fluor_ratio[delta_targets],          '.', markersize=15, alpha=0.5,          color=colors[0])plt.plot(np.max(norm_fin_fluor, 0)[omicron_targets],          ext_fluor_ratio[omicron_targets],          '.', markersize=15, alpha=0.5,          color=colors[2])plt.plot(np.max(norm_fin_fluor, 0)[negative_targets],          ext_fluor_ratio[negative_targets],          '.', markersize=15, alpha=0.5,          color=colors[3])max_fluor_ratio = max(np.abs(ext_fluor_ratio)) * 1.1plt.plot([1] * 2, #np.max(fin_fluor[:, 10])]*2,          [-max_fluor_ratio, max_fluor_ratio], #np.min(fluor_ratio), np.max(fluor_ratio)],           '--k')plt.ylim([-max_fluor_ratio, max_fluor_ratio])plt.plot([0, #np.max(fin_fluor[:, 10]),           np.max(norm_fin_fluor)], [0]*2,           '-k', alpha=0.2)plt.xlim([0, np.max(norm_fin_fluor) * 1.03])plt.xlabel('Normalized final fluorescence', fontsize=16)plt.ylabel(r'$\log_2 (F_{De/Om})$', fontsize=18)plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[0],          label='Delta')plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[2],          label='Omicron')plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[3],          label='Negative')plt.legend(    loc='upper left', bbox_to_anchor=(0.09, 1),#(0.09,0.48),    title='Patient samples',    )plt.gca().annotate('NTC', xy=(1, -2.),                    xytext=(1 * 3, -2.1),                   arrowprops=dict(arrowstyle="->"))plt.show()#%% ED Fig. 10Bdelta_targets = np.array([1,2,8]) omicron_targets = np.array([0] + list(range(11, 28))) negative_targets = np.array(list(range(3, 8)) + [9])target_groups = [                 [0],                 [1],                 [2],                  [22],                 [23],                 [24],  # [22, 24]                 [25, 27],                 [26],                 # [8],                 [11],                 [12, 13],                 [14],                 [15],                 [16],                 [17],                 [18, 19],                 [20],                 [21],                 [3],                 [4],                 [5],                 [6],                 [7],                 [9],                 [10],                 ]crRNA_groups = [[0,1]]target_dict = dict()for target in targets:    if target == 'NTC':        target_dict[target] = 'NTC'    else:        if target[0] == 'N':            target_num = int(target[1:])        elif target[0] == 'D' or target[0] == 'O':            target_num = int(target[3:])        if target_num > 28:  # we're removing N28            target_num -= 1        if target_num > 20:            target_num -= 2        target_dict[target] = 'P' + str(target_num)    ncols = 6nrows = 4fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(18, 9))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors[:21] + colors[23:]#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    data_to_use = data_2                    if not np.any(data_to_use[e_crRNA, e_target, :, r]):                        data_to_use = data                    ax.plot(times,                             data_to_use[e_crRNA, e_target, :, r],                             color=colors_to_use[color_index],                             linestyle=linestyles[(1-e_crRNA) % len(crRNA_group)],                             label=target_dict[target]*(r==0)*((e_crRNA==1))                            )        leg = ax.legend(ncol=1, fontsize=10)                ax.add_artist(leg)        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence\n(a.u.)')        if ax_index == 4:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='De')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='Om')                ax.legend(handles=lines,                                    loc='center left',                                    title='crRNA',                                     fontsize=10                                    )plt.subplots_adjust(wspace=0.45)fig.align_ylabels(axs)plt.show()#%% Fig. 4f, ED Fig. 9D  #XXX#%% Load dataraw_data = pd.read_excel('UK_data_compiled.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data.rename(col_renaming_dict, axis=1, inplace=True)times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['cE', 'cK']targets = ['f' + str(i) for i in range(1, 34)] + ['ampNTC', 'detNTC']num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))col_names_loaded = []for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        for r in range(num_replicates):            col_name = crRNA + ' ' + target + ' r' + str(r + 1)            data[e_crRNA, e_target, :, r] = raw_data[col_name]            col_names_loaded += [col_name]#%% F18 data had issueraw_data_f18 = pd.read_excel('NewF18data.xlsx')col_renaming_dict = dict()for e, col in enumerate(raw_data_f18.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data_f18.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data_f18.rename(col_renaming_dict, axis=1, inplace=True)target = 'f18'e_target = targets.index(target)for e_crRNA, crRNA in enumerate(crRNAs):    for r in range(num_replicates):        col_name = crRNA + ' F' + target[-2:] + ' r' + str(r + 1)        data[e_crRNA, e_target, :, r] = raw_data_f18[col_name]#%% Fig. 4Fntc_data = data[:, -2:, :, :]pos_cutoff = np.max(ntc_data) #np.max(fin_fluor[:, 10]) * 1.5data_mean = np.mean(data, -1)fin_fluor = data_mean[:, :, -1]max_fin_fluor = np.max(fin_fluor, 0)# This is the actual fluorescence ratiofluor_ratio = np.mean(np.log2((data[0, :, :, :]) / (data[1, :, :, :])), -1)# Don't want to consider the fluorescence ratio of noise, unless it's all noisefluor_ratio[(np.max(data_mean, 0)<pos_cutoff*1.7) & np.expand_dims((max_fin_fluor > pos_cutoff*1.7), -1)] = 0ext_fluor_ratio = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_ratio])norm_fin_fluor = fin_fluor / pos_cutoff# This is the difference between cE and cKfluor_diff = np.mean((data[0, :, :, :] - data[1, :, :, :]), -1) ext_fluor_diff = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_diff])K_targets = np.array(list(range(17)) + list(range(18,33)), dtype=int)plt.figure(figsize=(4.6, 4))  # default is 6,4plt.plot(np.max(norm_fin_fluor, 0)[K_targets],          ext_fluor_ratio[K_targets],          '.', markersize=15, alpha=0.5, color=colors[2])plt.plot(np.max(norm_fin_fluor, 0)[17],          ext_fluor_ratio[17],          '.', markersize=15, alpha=0.5, color=colors[0])max_fluor_ratio = max(np.abs(ext_fluor_ratio[:33])) * 1.2plt.plot([1] * 2, #np.max(fin_fluor[:, 10])]*2,          [-max_fluor_ratio, max_fluor_ratio], #np.min(fluor_ratio), np.max(fluor_ratio)],           '--k')plt.ylim([-max_fluor_ratio, max_fluor_ratio])plt.plot([0, #np.max(fin_fluor[:, 10]),           np.max(norm_fin_fluor)], [0]*2,           '-k', alpha=0.2)plt.xlim([0, np.max(norm_fin_fluor) * 1.03])plt.xlabel('Normalized final fluorescence', fontsize=16)plt.ylabel(r'$\log_2 (F_{E/K})$', fontsize=18)plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[0],          label='E')plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[2],          label='K')plt.legend(title='Patient samples',             loc='lower left',             bbox_to_anchor=(0.2, 0.6),#(0.2, 0.67)           )plt.gca().annotate('NTC', xy=(1, -0.6), #0.3),                    xytext=(1 * 2, -0.6), #0.3),                   arrowprops=dict(arrowstyle="->"))plt.show()#%% ED Fig. 9Dtarget_groups = [[2, 7],                 [1, 17],                 [4,5],                  [3],                 [6,32],                 [27,20],                 [0, 9,10],                 [12,13],                 [14],                 [15, 16],                 [7,19],                 [21, 24,25, 30,],                 [22,28,29, ],                 [8,11,18],                 [23,26,31],                 [33,34]                 ]crRNA_groups = [[0,1]]ncols = 4nrows = 4fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(12, 8))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    ax.plot(times,                             data[e_crRNA, e_target, :, r],                             color=colors_to_use[color_index],                             linestyle=linestyles[e_crRNA % len(crRNA_group)],                             label=target*(r==0)*((e_crRNA==0) +(e_crRNA==3))                            )        leg = ax.legend(ncol=1, fontsize=10)                ax.add_artist(leg)        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence\n(a.u.)')        if ax_index == 3:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='E')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='K')                ax.legend(handles=lines,                                    loc='lower left',                                    title='crRNA',                                     fontsize=12,                                    )plt.subplots_adjust(wspace=0.45)fig.align_ylabels(axs)plt.show()#%% Fig. 4G, 10D #XXX#%% Load plate maps & datatimes = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['cH', 'cY']targets = ['S1H', 'S2H', 'S3H', 'S4H', 'S1Y', 'S2Y', 'S3Y', 'S4Y', 'NTC13', 'NTC2', 'NTC4']num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))# Load data from 3 spreadsheetsfor filename in ['RIVM S1_S3', 'RIVM S4', 'RIVM S2']:    plate_map = pd.read_excel(filename + '.xlsx',        index_col=0,        sheet_name='Plate Map')        raw_data = pd.read_excel(filename + '.xlsx',        sheet_name='Clean data')        plate_map_dict = dict()    for i in plate_map.columns:        for j in plate_map.index:            if type(plate_map[i][j]) == str:                plate_map_dict[j + str(i)] = plate_map[i][j]        plate_map_dict_inv = dict()    for val in np.unique([i for i in plate_map_dict.values()]):         plate_map_dict_inv[val] = []    for i in plate_map_dict.keys():        plate_map_dict_inv[plate_map_dict[i]] += [i]            targets_in_file = {'RIVM S1_S3': ['S1H', 'S1Y', 'S3H', 'S3Y', 'NTC'],                        'RIVM S4': ['S4H', 'S4Y', 'NTC'],                        'RIVM S2': ['S2H', 'S2Y', 'NTC']}    for e_crRNA, crRNA in enumerate(crRNAs):        for target in targets_in_file[filename]:            if target == 'NTC':                e_target = targets.index(                    {'RIVM S1_S3': 'NTC13',                      'RIVM S4': 'NTC4',                      'RIVM S2': 'NTC2'}[filename])                if filename == 'RIVM S4':                    target = 'detNTC'  # also have ampNTC            else:                e_target = targets.index(target)            chambers = plate_map_dict_inv[crRNA + ' ' + target]            for r, chamber in enumerate(chambers):                if np.any(data[e_crRNA, e_target, :, r]):                    print('Overwriting', e_crRNA, e_target, r)                data[e_crRNA, e_target, :, r] = raw_data[chamber]#%% Fig. 4Gntc_data = data[:, -3:, :, :]pos_cutoff = np.max(ntc_data) data_mean = np.mean(data, -1)fin_fluor = data_mean[:, :, -1]max_fin_fluor = np.max(fin_fluor, 0)norm_fin_fluor = fin_fluor / pos_cutoff# # This is the actual fluorescence ratiofluor_ratio = np.mean(np.log2((data[0, :, :, :]) / (data[1, :, :, :])), -1)# Don't want to consider the fluorescence ratio of noise, unless it's all noisefluor_ratio[(np.max(data_mean, 0)<pos_cutoff*1.7) & np.expand_dims((max_fin_fluor > pos_cutoff*1.7), -1)] = 0ext_fluor_ratio = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_ratio])# This is the difference between cH and cYfluor_diff = np.mean((data[0, :, :, :] - data[1, :, :, :]), -1) ext_fluor_diff = np.array([i[np.argmax(np.abs(i), -1)] for i in fluor_diff])plt.figure(figsize=(4.6, 4))  # default is 6,4plt.plot(np.max(norm_fin_fluor, 0)[:4],          ext_fluor_ratio[:4],          '.', markersize=15, alpha=0.5,          color=colors[0])plt.plot(np.max(norm_fin_fluor, 0)[4:8],          ext_fluor_ratio[4:8],          '.', markersize=15, alpha=0.5,          color=colors[2])max_fluor_ratio = max(np.abs(ext_fluor_ratio[:33])) * 1.1plt.plot([1] * 2, #np.max(fin_fluor[:, 10])]*2,          [-max_fluor_ratio, max_fluor_ratio], #np.min(fluor_ratio), np.max(fluor_ratio)],           '--k')plt.ylim([-max_fluor_ratio, max_fluor_ratio])plt.plot([0, #np.max(fin_fluor[:, 10]),           np.max(norm_fin_fluor)], [0]*2,           '-k', alpha=0.2)plt.xlim([0, np.max(norm_fin_fluor) * 1.03])plt.xlabel('Normalized final fluorescence', fontsize=16)plt.ylabel(r'$\log_2 (F_{H/Y})$', fontsize=18)plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[0],          label='H')plt.plot([np.inf]*2, [np.inf]*2, '.', markersize=15, alpha=0.5, color=colors[2],          label='Y')plt.legend(    loc='upper left', bbox_to_anchor=(0.05,1),    title=' Patient\nsamples'    )plt.gca().annotate('NTC', xy=(1, -0.7),                    xytext=(1 * 5, -0.7),                   arrowprops=dict(arrowstyle="->"))plt.show()#%% ED Fig. 10Dtarget_groups = [[0],                 [1],                 [2],                  [3],                 [4],                 [5],                 [6],                 [7],                 [8,9,10],                 ]crRNA_groups = [[0,1]]target_names_dict = dict()for target in targets:    target_names_dict[target] = target    if target == 'NTC13':        target_names_dict[target] = 'NTC1'    if target == 'NTC4':        target_names_dict[target] = 'NTC3'ncols = 3nrows = 3fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(12, 8))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_crRNA in crRNA_group:                crRNA = crRNAs[e_crRNA]                for r in range(num_replicates):                    ax.plot(times,                             data[e_crRNA, e_target, :, r],                             color=colors_to_use[color_index],                             linestyle=linestyles[e_crRNA % len(crRNA_group)],                             label=target_names_dict[target]*(r==0)*((e_crRNA==0) +(e_crRNA==3))                            )        leg = ax.legend(ncol=1)                ax.add_artist(leg)        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if ax_index % nrows == nrows - 1:            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 60, 120, 180])        else:            ax.set_xticks([0, 60, 120, 180], ['']*4)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence\n(a.u.)')        if ax_index == 0:            lines = []            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='-', color='black',                             label='H')            lines += ax.plot([np.inf]*2, [np.inf]*2,                             linestyle='--', color='black',                             label='Y')                ax.legend(handles=lines,                                    loc='lower left',                                    title='crRNA',                                     )plt.subplots_adjust(wspace=0.45)fig.align_ylabels(axs)plt.show()#%% Fig. 4I and ED Fig. 9E  #XXX#%% Label band definition# From https://stackoverflow.com/questions/67235301/vertical-grouping-of-labels-with-brackets-on-matplotlibdef add_xlabel_band(ax, top, bottom, label, *, spine_pos=-0.05, tip_pos=-0.02, text_offset=-0.05, fontsize=14):    """    Helper function to add bracket around y-tick labels.    Parameters    ----------    ax : matplotlib.Axes        The axes to add the bracket to    top, bottom : floats        The positions in *data* space to bracket on the x-axis    label : str        The label to add to the bracket    spine_pos, tip_pos : float, optional        The position in *axes fraction* of the spine and tips of the bracket.        These will typically be negative    Returns    -------    bracket : matplotlib.patches.PathPatch        The "bracket" Aritst.  Modify this Artist to change the color etc of        the bracket from the defaults.    txt : matplotlib.text.Text        The label Artist.  Modify this to change the color etc of the label        from the defaults.    """    # grab the yaxis blended transform    # transform = ax.get_yaxis_transform()    # add the bracket    bracket = mpatches.PathPatch(        mpath.Path(            [                [tip_pos, top][::-1],                [spine_pos, top][::-1],                [spine_pos, bottom][::-1],                [tip_pos, bottom][::-1],            ]        ),        # transform=transform,        clip_on=False,        facecolor="none",        edgecolor="k",        linewidth=2,    )    ax.add_artist(bracket)    # add the label    txt = ax.text(        (top + bottom) / 2,        spine_pos + text_offset,        label,        ha="center",        va="center",        # rotation="vertical",        clip_on=False,        fontsize=fontsize        # transform=transform,    )    return bracket, txt#%% Load dataraw_data = pd.read_excel('RNAProbe114_b.xlsx')# Rename columns resulting from merged cells since those refer to replicatescol_renaming_dict = dict()for e, col in enumerate(raw_data.columns):    if col[:7] == 'Unnamed':        prev_col_name = raw_data.columns[e - 1]        col_renaming_dict[prev_col_name] = prev_col_name + ' r1'        col_renaming_dict[col] = prev_col_name + ' r2'raw_data.rename(col_renaming_dict, axis=1, inplace=True)times = range(0, 180 + 1, 5) #raw_data.Time.to_numpy()times_str = [str(i) for i in times]times_float = np.array(times, dtype=float)crRNAs = ['cE', 'cK']targets = ['hE1', 'hE2', 'hE3', 'hE4', 'hK1', 'hK2', 'hK3', 'hK4m', 'hK5m',            'h4o', 'h5o', 'hK6', 'hK7', 'detNTC', 'ampNTC', '-ext']num_replicates = 2data = np.zeros((len(crRNAs), len(targets), len(times), num_replicates))col_names_loaded = []for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        for r in range(num_replicates):            col_name = 'PCR ' + crRNA + ' ' + target + ' r' + str(r + 1)            data[e_crRNA, e_target, :, r] = raw_data[col_name]            col_names_loaded += [col_name]#%% Fig. 4Imin_NTC = np.max(data[:, -3:-1, :, :]) #np.max(np.mean(data, -1)[:, -3:-1, :])data_mean = np.mean(data, -1)fin_fluor = data_mean[:, :, -1]max_fin_fluor = np.max(fin_fluor, 0)fluor_ratio = np.log2(np.mean((data[0, :, :, :]) / (data[1, :, :, :]), -1))# Don't want to consider the fluorescence ratio of noise, unless it's all noisefluor_ratio[(np.max(data_mean, 0)<min_NTC*1.7) & np.expand_dims((max_fin_fluor > min_NTC*1.7), -1)] = 0# ext_fluor is the fluorescence values at the point where the discrimination is highestext_fluor = np.transpose(np.array([data_mean[:, e, np.argmax(np.abs(i), -1)] for e, i in enumerate(fluor_ratio)]))linear_cmap_white_purple = LinearSegmentedColormap.from_list('rg', ['w', '#0B3B65'], N=256) fluor_to_plot = ext_fluor  # fin_fluorcrRNAs_to_use = range(2) #[1,0]targets_to_use = [9, 10, 7, 8, 4, 5, 6, 11, 12, 1, 0, 2, 3, -1]  # 9, 10 are h4o, h5o; -1 is neg controlfluor_to_plot = fluor_to_plot[crRNAs_to_use, :]fluor_to_plot = fluor_to_plot[:, targets_to_use]max_fluor = np.max(np.mean(data, -1)[crRNAs_to_use, :, -1], 0)max_fluor = max_fluor[targets_to_use]plt.figure(figsize=(4.6, 1))  # default is 6,4plt.imshow(        (fluor_to_plot - min_NTC) * ((fluor_to_plot - min_NTC) > 0) /         (np.max(fluor_to_plot, 0) - min_NTC        # (max_fluor - min_NTC         )    ,    cmap=linear_cmap_white_purple,    aspect='auto',    vmin=0, vmax=1,    )for e, i in enumerate(targets_to_use):    top_row_star = (e-0.45, 0 + 0.15)    bottom_row_star = (e-0.45, 1 + 0.15)    if targets[i] in ['hK4m', 'h4o', 'hK5m', 'h5o', 'hK1', 'hK2', 'hK3', 'hK6', 'hK7', 'hE2']:        plt.annotate(r'$\star$', bottom_row_star, color='white', fontsize=20)    if targets[i] in ['hE2', 'hE1', 'hE3', 'hE4']:        plt.annotate(r'$\star$', top_row_star, color='white', fontsize=20)# plt.imshow(np.log(np.transpose(fin_fluor_mat_mean) / np.mean(fin_fluor_mat_mean, 1)))plt.yticks(range(len(crRNAs_to_use)),            [{'cE': 'E',             'cK': 'K',             }[crRNAs[i]] for i in crRNAs_to_use],            rotation=0)plt.xticks(range(len(targets_to_use)),            [{'-ext': 'n1',             'hK4m': 'p1',              'h4o': 'p1o',             'hK5m': 'p2',             'h5o': 'p2o',             'hK1': 'p3',             'hK2': 'p4',             'hK3': 'p5',             'hK6': 'p6',             'hK7': 'p7',             'hE2': 'p8',             'hE1': 'p9',             'hE3': 'p10',             'hE4': 'p11'             }[targets[i]] for i in targets_to_use],            fontsize=12,           rotation=45)add_xlabel_band(plt.gca(), -0.3, 1.3,                 'Patient\nsamples',                spine_pos=2.05 +60 * 0.015,                 tip_pos=2.05 +60 * 0.012,                 text_offset=0.2 +60 * 0.006,                fontsize=10)add_xlabel_band(plt.gca(), 1.7, 12.3,                 'Clinical\nisolates',                spine_pos=2.05 +60 * 0.015,                 tip_pos=2.05 +60 * 0.012,                 text_offset=0.2 +60 * 0.006,                fontsize=10)plt.ylabel('crRNA')plt.xlabel('\n\n\nTarget')plt.title('Cambodia H5N1 2023')plt.show()#%% ED Fig. 9Etarget_groups = [[9, 10],                  [7, 8, 4, 5, 6, ],                 [11, 12],                  [1],                  [0, 2, 3],                  [-3, -2, -1]]  # 9, 10 are h4o, h5o; -1 is neg controltarget_names = {'-ext': 'n1',  'hK4m': 'p1',   'h4o': 'p1o',  'hK5m': 'p2',  'h5o': 'p2o',  'hK1': 'p3',  'hK2': 'p4',  'hK3': 'p5',  'hK6': 'p6',  'hK7': 'p7',  'hE2': 'p8',  'hE1': 'p9',  'hE3': 'p10',  'hE4': 'p11',  'detNTC': 'detNTC',  'ampNTC': 'ampNTC',  }blue_colors_index = 0red_colors_index = 0gray_colors_index = 0fig, axs = plt.subplots(ncols=3, nrows=2, figsize=(12, 8))for e_tg, target_group in enumerate(target_groups):    ax = axs[e_tg//3, e_tg%3]    for e_target in target_group:        target = targets[e_target]        if 'NTC' not in target and '-ext' not in target:            colors_to_use = colors#blue_colors            color_index = blue_colors_index            blue_colors_index += 1        else:            colors_to_use = gray_colors            color_index = gray_colors_index            gray_colors_index += 1        for e_crRNA, crRNA in enumerate(crRNAs):            for r in range(num_replicates):                ax.plot(times,                         data[e_crRNA, e_target, :, r],                         color=colors_to_use[color_index],                         linestyle=linestyles[e_crRNA],                         label=target_names[target]*(r==0)*(e_crRNA==0))    if e_tg == 0:        leg = ax.legend(ncol=1, loc='upper left')    else:        leg = ax.legend(ncol=1)            ax.add_artist(leg)        if ax.get_ylim()[1] > 6000:        ax.set_ylim(bottom=-100)    if e_tg // 3 == 1:        ax.set_xlabel('Time (min)')        ax.set_xticks([0, 60, 120, 180])    else:        ax.set_xticks([0, 60, 120, 180], ['']*4)    if e_tg % 3 == 0:        ax.set_ylabel('Fluorescence (a.u.)')    # plt.title(target)    if e_tg == 0:        lines = []        lines += ax.plot([np.inf]*2, [np.inf]*2,                         linestyle='-', color='black',                         label='E')        lines += ax.plot([np.inf]*2, [np.inf]*2,                         linestyle='--', color='black',                         label='K')        ax.legend(handles=lines,                                loc='lower right',                                title='crRNA',                                 )plt.subplots_adjust(wspace=0.35)fig.align_ylabels(axs)plt.show()#%% Fig. 4J and ED Fig. 10E, 7D #XXX#%% Load dataRNA_probe_suffix = '129_b'data = pd.read_csv('RNAProbe' + RNA_probe_suffix + '_named.txt',                   delimiter='\t')assays = np.unique(data.Assay)  # Assays are the different crRNAs# NPC = no crRNA control; crRNA1-10 are targets; crRNA_rand has no target# r1 = replicate 1; r2 = replicate 2samples = np.unique(data.Sample)  # Samples are the different occluders# target1 and target2 are the two different shuffles of the target order# NOC is labeled as occluding nts 99-99 (Just arbitrarily)# Example of how to read:    #5' UCAAACCAUACAUAUAACACUCUUUAUUCUCCUUAACUUUUCAA...  3' is an RNA target    # 10nt_step18_start20_end29 corresponds to the oligo that's complementary to     # 5' UCUUUAUUCU 3' . Meaning that the oligo itself is 5' AGAAUAAAGA 3'. # Some "starts" are at 0 meaning that they start at the first nucleotide. # ie nt index is 0-indexed.times = range(0, 480 + 1, 5)times_str = [str(i) for i in times]#%% Add columns to clear up dataframedef get_crRNA_variant(assay_name):    putative_variant = assay_name[3]    if putative_variant in ['A', 'C', 'D', 'R', 'S', 'V']:        return(putative_variant)    if 'WT' in assay_name:        return('WT')    if 'NTC' in assay_name:        return('NTC')    print('Error in get_cRNA_variant', assay_name)    def is_crRNA_conc_normal(assay_name):    if 'high' in assay_name or 'low' in assay_name:        return(False)    return(True)def is_crRNA_conc_optimized(assay_name):    if 'high' in assay_name or 'low' in assay_name:        return(True)    if '12D' in assay_name or '12R' in assay_name or 'WT' in assay_name or '12S' in assay_name:        return(False)    return(True)def get_Mg_conc(sample_name):    return({'1': 2, '2': 9, '3': 14}[sample_name[-1]])def get_dilution(sample_name):    if 'NTC' in sample_name:        return(1)    return(int(sample_name[-8]))def get_target(sample_name):    if 'NTC' in sample_name:        return('NTC')    return(sample_name[:-10])def get_target_variant(sample_name):    if 'NTC' in sample_name:        return('NTC')    if sample_name[:2] == '12':        return(sample_name[:3])    if 'A1' in sample_name:        return('12D')    if 'N1' in sample_name:        return('12C')    if '480' in sample_name or '620' in sample_name:        return('12V')    if 'S1' in sample_name or 'WT' in sample_name:        return('WT')    print('Error in get_target_variant', sample_name)def mean_r(rs, r_errs=None, mean_exp=True, mean_axis=-1):    if r_errs is None:        if mean_exp:            log_rs = np.log(rs)            mean_log_rs = np.mean(log_rs, mean_axis)            mean_rs = np.exp(mean_log_rs)        else:            mean_rs = np.mean(rs, mean_axis)    else:  # use weighted mean        if mean_exp:            log_rs = np.log(rs)            log_rs_weighted = log_rs / r_errs**2            mean_rs = np.exp(np.sum(log_rs_weighted, mean_axis) /                              np.sum(1. / r_errs**2, mean_axis))        else:            mean_rs = np.sum(rs / r_errs**2, mean_axis) / (                np.sum(1. / r_errs**2, mean_axis))    return(mean_rs)data['crRNAVariant'] = data.Assay.map(get_crRNA_variant)data['replicate'] = data.Assay.map(lambda x: int(x[-1]))data['crRNA'] = data.Assay.map(lambda x: x[:-4])data['crRNAConcNormal'] = data.Assay.map(is_crRNA_conc_normal)data['crRNAConcOpt'] = data.Assay.map(is_crRNA_conc_optimized)data['MgConc'] = data.Sample.map(get_Mg_conc)data['dilution'] = data.Sample.map(get_dilution)data['target'] = data.Sample.map(get_target)data['targetVar'] = data.Sample.map(get_target_variant)data_as_numpy = data[times_str].to_numpy()data_as_list = [data_as_numpy[i] for i in range(data_as_numpy.shape[0])]data['timeSeries'] = data_as_listtarget_variants = list(np.unique(data['targetVar']))targets = list(np.unique(data['target']))crRNA_variants = list(np.unique(data['crRNAVariant']))crRNAs = list(np.unique(data['crRNA']))dilutions = list(np.unique(data['dilution']))Mg_concs = list(np.unique(data['MgConc'])) #%% Fig. 4Jlinear_cmap = matplotlib.colormaps['BuGn']  #LinearSegmentedColormap.from_list('rg',["w", colors[7], 'k'], N=256) dilution = dilutions[0]Mg_conc = Mg_concs[2]data_subset = data[    (data['dilution'] == dilution) &  #  + (target=='NTC') * (1 - dilution)     (data['MgConc'] == Mg_conc)    ]NTC_data = data[    (data['dilution'] == dilution) &    (data['target'] == 'NTC') &     (data['MgConc'] == Mg_conc)    ]min_NTC = min([min(i) for i in NTC_data.timeSeries])fin_fluor_mat_t = np.zeros((len(crRNAs), len(targets), 2))for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        data_target_crRNA = data_subset[            (data_subset['target'] == target) &             (data_subset['crRNA'] == crRNA)]        if target == 'NTC':  # 8 replicates rather than 2            fin_fluor_mat_t[e_crRNA, e_target, :] = [                mean_r(np.array(data_target_crRNA[times_str[-1]])[:4], mean_exp=True),                mean_r(np.array(data_target_crRNA[times_str[-1]])[4:], mean_exp=True)]        else:            fin_fluor_mat_t[e_crRNA, e_target, :] = data_target_crRNA['480']fin_fluor_mat_mean_t = mean_r(fin_fluor_mat_t, mean_exp=True)crRNAs_to_use = np.array([1, 2, 4, 6, 8, 9, 11], dtype=int)  # , 0 is NTCtargets_to_use = np.array([0, 1, 2, 3, 4, 5, 12], dtype=int)  # 10 is NTCfin_fluor_mat_mean_t = fin_fluor_mat_mean_t[crRNAs_to_use, :]fin_fluor_mat_mean_t = fin_fluor_mat_mean_t[:, targets_to_use]fin_fluor = fin_fluor_mat_mean_tplt.figure()plt.imshow(        (fin_fluor - np.min(fin_fluor, 0)) /    # min_NTC        (np.max(fin_fluor, 0) - np.min(fin_fluor, 0))  # min_NTC    ,    cmap=linear_cmap,#linear_cmap_white_purple,    vmin=0, vmax=1,    )for i in range(len(fin_fluor_mat_mean_t)):    plt.annotate(r'$\star$', (i-0.32, i+0.24), color='white', fontsize=30)plt.yticks(range(len(crRNAs_to_use)),            [{'c12AOcc': 'A',             'c12COcc': 'C',             'c12DOcc high': 'D',             'c12ROcc high': 'R',             'c12SOcc low': 'S',             'c12VOcc': 'V',             'cWTOcc high': 'WT',             'NTC': 'NTC'}            [crRNAs[i]] for i in crRNAs_to_use],            )plt.xticks(range(len(targets_to_use)),            [targets[i][-1] if targets[i] != 'WT' else 'WT' for i in targets_to_use],           # rotation=45           )plt.colorbar(label='Normalized final fluorescence')plt.ylabel('crRNA')plt.xlabel('Target')plt.title('KRAS codon 12 variants')plt.show()#%% ED Fig. 10Ecolors = (['#1E88E5', '#FFC107', '#D81B60', '#004D40', '#501ACA',            '#4C1F49', '#03B99A'])dilution = dilutions[0]Mg_conc = Mg_concs[2]data_subset = data[    (data['dilution'] == dilution) &  #  + (target=='NTC') * (1 - dilution)     (data['MgConc'] == Mg_conc)    ]fluor_mat_mean = np.zeros((len(crRNAs), len(targets), len(times)))for e_crRNA, crRNA in enumerate(crRNAs):    for e_target, target in enumerate(targets):        data_target_crRNA = data_subset[            (data_subset['target'] == target) &             (data_subset['crRNA'] == crRNA)]['timeSeries']        data_target_crRNA_array = np.zeros((len(times), len(data_target_crRNA)))        for e, i in enumerate(data_target_crRNA):            data_target_crRNA_array[:, e] = i        fluor_mat_mean[e_crRNA, e_target, :] = mean_r(data_target_crRNA_array, mean_exp=True)target_groups = [[0],                 [1,],                 [2],                  [3],                 [4],                 [5],                 [12],                 [10],                 ]crRNA_groups = [[1, 2, 4, 6, 8, 9, 11]]ncols = 3nrows = 3fig, axs = plt.subplots(ncols=ncols, nrows=nrows, figsize=(12, 8))blue_colors_index = 0gray_colors_index = 0for e_tg, target_group in enumerate(target_groups):    for e_c, crRNA_group in enumerate(crRNA_groups):        ax_index = e_tg + len(target_groups) * e_c        ax = axs[ax_index%nrows, ax_index//nrows]        for e_target in target_group:            target = targets[e_target]            if 'NTC' not in target:                colors_to_use = colors#blue_colors                color_index = blue_colors_index // len(crRNA_groups)                blue_colors_index += 1            else:                colors_to_use = colors#gray_colors                color_index = gray_colors_index // len(crRNA_groups)                gray_colors_index += 1            for e_e_crRNA, e_crRNA in enumerate(crRNA_group):                crRNA = crRNAs[e_crRNA]                ax.plot(times,                         fluor_mat_mean[e_crRNA, e_target, :],                         color=colors_to_use[e_e_crRNA % len(crRNA_group)],                         linestyle='-',#linestyles[e_crRNA % len(crRNA_group)],                         label=crRNA*((e_tg==0) * (e_c==0))                        )        if ax.get_ylim()[1] > 4000:            ax.set_ylim(bottom=-100)        if (ax_index % nrows == nrows - 1) or (ax_index == 7):            ax.set_xlabel('Time (min)')            ax.set_xticks([0, 120, 240, 360, 480])        else:            ax.set_xticks([0, 120, 240, 360, 480], ['']*5)            if ax_index // nrows == 0:            ax.set_ylabel('Fluorescence (a.u.)')        ax.set_title('Target: ' + ('WT' if 'WT' in target else 'NTC' if 'NTC' in target else target[-1]))ax = axs[-1, -1]for e_e_crRNA, e_crRNA in enumerate(crRNA_group):    crRNA = crRNAs[e_crRNA]    ax.plot([np.inf]*2,             [np.inf]*2,             color=colors[e_e_crRNA % len(crRNA_group)],             linestyle='-',#linestyles[e_crRNA % len(crRNA_group)],             label='WT' if 'WT' in crRNA else crRNA[3]            )ax.legend(loc='lower center',          title='crRNA',           fontsize=12,          ncol=3          )ax.set_axis_off()plt.subplots_adjust(wspace=0.25, hspace=0.35)fig.align_ylabels(axs)plt.show()colors = (['#1E88E5', '#FFC107', '#D81B60', '#004D40', '#501ACA', '#65C598',            '#4C1F49', '#A64ADE', '#339010'] + ['#0B3B65', '#8C6902', '#7D0E36', '#03B99A', '#8F6AE2']) * 10#%% ED Fig. 7Dlinear_cmap = matplotlib.colormaps['BuGn']  #LinearSegmentedColormap.from_list('rg',["w", colors[7], 'k'], N=256) fig, axs = plt.subplots(ncols=3, sharey=True)for e in range(3):    ax = axs[e]    Mg_conc = Mg_concs[e]    dilution = dilutions[0]    data_subset = data[        (data['dilution'] == dilution) &  #  + (target=='NTC') * (1 - dilution)         (data['MgConc'] == Mg_conc)        ]        NTC_data = data[        (data['dilution'] == dilution) &        (data['target'] == 'NTC') &         (data['MgConc'] == Mg_conc)        ]        min_NTC = min([min(i) for i in NTC_data.timeSeries])        fin_fluor_mat_t = np.zeros((len(crRNAs), len(targets), 2))    for e_crRNA, crRNA in enumerate(crRNAs):        for e_target, target in enumerate(targets):            data_target_crRNA = data_subset[                (data_subset['target'] == target) &                 (data_subset['crRNA'] == crRNA)]            if target == 'NTC':  # 8 replicates rather than 2                fin_fluor_mat_t[e_crRNA, e_target, :] = [                    mean_r(np.array(data_target_crRNA[times_str[-1]])[:4], mean_exp=True),                    mean_r(np.array(data_target_crRNA[times_str[-1]])[4:], mean_exp=True)]            else:                fin_fluor_mat_t[e_crRNA, e_target, :] = data_target_crRNA['480']        fin_fluor_mat_mean_t = mean_r(fin_fluor_mat_t, mean_exp=True)        crRNAs_to_use = np.array([1, 2, 4, 6, 8, 9, 11], dtype=int)  # , 0 is NTC    targets_to_use = np.array([0, 1, 2, 3, 4, 5, 12], dtype=int)  # 10 is NTC    fin_fluor_mat_mean_t = fin_fluor_mat_mean_t[crRNAs_to_use, :]    fin_fluor_mat_mean_t = fin_fluor_mat_mean_t[:, targets_to_use]    fin_fluor = fin_fluor_mat_mean_t        # linear_cmap_white_purple = LinearSegmentedColormap.from_list('rg', ['w', '#1E88E5'], N=256)         im = ax.imshow(            (fin_fluor - np.min(fin_fluor, 0)) /    # min_NTC            (np.max(fin_fluor, 0) - np.min(fin_fluor, 0))  # min_NTC        ,        cmap=linear_cmap,#linear_cmap_white_purple,        vmin=0, vmax=1,        )    for i in range(len(fin_fluor_mat_mean_t)):        ax.annotate(r'$\star$', (i-0.38, i+0.23), color='white', fontsize=15)        # plt.imshow(np.log(np.transpose(fin_fluor_mat_mean) / np.mean(fin_fluor_mat_mean, 1)))    ax.set_yticks(range(len(crRNAs_to_use)),                [{'c12AOcc': 'A',                 'c12COcc': 'C',                 'c12DOcc high': 'D',                 'c12ROcc high': 'R',                 'c12SOcc low': 'S',                 'c12VOcc': 'V',                 'cWTOcc high': 'WT',                 'NTC': 'NTC'}                [crRNAs[i]] for i in crRNAs_to_use],                fontsize=11               )    ax.set_xticks(range(len(targets_to_use)),                [targets[i][-1] if targets[i] != 'WT' else 'WT' for i in targets_to_use],               fontsize=11,               # rotation=45               )    if e == 2:        cb_ax = fig.add_axes([.93,.3,.015,.38])        cbar = fig.colorbar(im, orientation='vertical',cax=cb_ax)            # cbar = fig.colorbar(im, ax=ax,        #                     fraction=0.05,        #              )        cbar.set_label(label='Normalized\nfinal fluorescence', fontsize=10)        cbar.ax.tick_params(labelsize=10)    if e == 0:        ax.set_ylabel('crRNA')    ax.set_xlabel('Target')    ax.set_title('   ' * (e==2) + '[Mg' + r'$^{2+}$' + '] = ' + str(Mg_conc) + ' mM', fontsize=14)plt.suptitle('KRAS codon 12 variants', y=0.85)folder_name = '/Users/Ofer/Dropbox/LSI 2021/Cas13/Figures/July24/'plt.savefig(folder_name + 'SVGs/' + 'KRAS_Mg' +            '.svg', bbox_inches='tight', dpi=300)plt.savefig(folder_name + 'PNGs/' + 'KRAS_Mg' +            '.png', bbox_inches='tight', dpi=300)plt.show()#%% ED Fig 1B # Takes ~2 min to run #XXXdef designRandomSeq(len_seq):    seq_in_numbers = np.random.choice(4, size=len_seq)    nts = ['A', 'C', 'G', 'U']    seq = ''    for e in range(len_seq):        seq += nts[seq_in_numbers[e]]    return(seq)def nupack_FE_pred(seq):    nupack_model = nupack.Model(material='rna', #'rna95-nupack3', #'rna' for Nupack4; 'rna95-nupack3' for Nupack3                                kelvin=310.15,                                # ensemble='some-nupack3'                                )    nupack_seqs = [nupack.Strand(seq, name='seq1')]    cset1 = nupack.ComplexSet(strands=nupack_seqs, complexes=nupack.SetSpec(max_size=1))    complex_analysis_result = nupack.complex_analysis(cset1, model=nupack_model,                                             compute=['pfunc', 'mfe'])    # nupack_seq_names = [i.name for i in cset1]    return(complex_analysis_result['(seq1)'].free_energy,            complex_analysis_result['(seq1)'].mfe[0].energy)# num_seqs_to_test_long = 2000# len_seq_long = 961# random_seq_fes_long = np.zeros(num_seqs_to_test_long)# random_seq_mfes_long = np.zeros(num_seqs_to_test_long)# start = time.time()# for e in range(1000, num_seqs_to_test_long):#     if (e+1)%100 == 0:#         print('Starting seq #', e+1, '; Time elapsed =', time.time() - start)#     random_seq_fes_long[e], random_seq_mfes_long[e] = nupack_FE_pred(designRandomSeq(len_seq_long))num_seqs_to_test = 10000len_seq = 35random_seq_fes = np.zeros(num_seqs_to_test)random_seq_mfes = np.zeros(num_seqs_to_test)start = time.time()for e in range(num_seqs_to_test):    if (e+1)%1000 == 0:        print('Starting seq #', e+1, '; Time elapsed =', time.time() - start)    random_seq_fes[e], random_seq_mfes[e] = nupack_FE_pred(designRandomSeq(len_seq))    hinf_targets_final_even_better = 'GACUCACAAUAAAUCUCACCAUUAAUUUCCAUCUCUCUUCUCCAAUAUAUCCUUCAUCCUAAUAUUCAAUUUUCCAUUCUUACAACUAAAACAUUCACACUCAUCUAACAAAUACCUUCAACUACUAUUUCUCCCUUCUAAACAUCUAAAUCUGCUUCCUCUCAUAUAUCACAUUAUUAAUCCUCACCAACCUAAUACUUCAUCACUACAAUCACUUCUACACCAUUUCAUAUCUCUACCUUAUAAUAACCUCACUAUACUCACUUUCACAAACAAUCCUAUACAACAUCAAUCUCUAAACCUCUCCAUCAAAUAUCUCACACGUUGCCAUCAAAGAACUCCCCACACAUGAUCAAAAUUAACCUAUUAUUCAACACCUUUCCUCCUAUAAACCUCAAUUUCCACAUUUCACUACAUUUUCUCAAACCUACUAAUUAUUCUACUAAUCUUUCCAAACACCUAAUCACCUAAAUCACACCUUCUUAUAUCCAACCAAUCAUAAAACAACUCAUACUGUCACCGCCUAGAUCACCCAACCGAAUGUUUCACCAAGUUUACUCUACUCCACACUAUCCUUAAACACAAUUAUCAACUCUCAUUUUCUUCUUUUCCAACAUUCAUACAAUUCAUUCCUUUUAUCCAUUCACCUACACUUAAUACUUACCUCUCUAUUUCAAACCAUACAUAUAACACUCUUUAUUCUCCUUAACUUUUCAACAGCACGCCAAAUCCAGUCACUCCAACUUUCUUAUCCACAAAAUCUUCUUCUAACUACUUAUUCCUCAUUCUUUGACAUAUCCAAUUUAAAACAAGCCCACCUCUCGAGACACACUUACUAACCAUCAACCAAACUAACAUAUCAACACUAAUAACACACUCUUCCAUAUUAACCACAUACUACUCCAUUUACUAUAUUACCAUCCACUCUUAUCAUCUACCUCACACCAUAAUUCCUAUAACA'hinf_targets_final_shuffled = 'GACUCACAAUAAAUCUCACCAUUAAUUUCCAUCUCUCUUCUCCAAUAUAUCCUUCAUCCUAAUAUUCAAUUUUCCAUUCUUACAACUAAAACAUUCACAAUCUCUAAACCUCUCCAUCAAAUAUCUCACACGUUGCCAUCAAAGAACUCCCCACACAUGAUCAAAAUUAACCUAUUAUUCAACACCUUUCCUCCACUCAUCUAACAAAUACCUUCAACUACUAUUUCUCCCUUCUAAACAUCUAAAUCUGCUUCCUCUCAUAUAUCACAUUAUUAAUCCUCACCAACCUAAACACAAUUAUCAACUCUCAUUUUCUUCUUUUCCAACAUUCAUACAAUUCAUUCCUUUUAUCCAUUCACCUACACUUAAUACUUACCUCUCUAUUCUAUAAACCUCAAUUUCCACAUUUCACUACAUUUUCUCAAACCUACUAAUUAUUCUACUAAUCUUUCCAAACACCUAAUCACCUAAAUCACACCUUAAUACUUCAUCACUACAAUCACUUCUACACCAUUUCAUAUCUCUACCUUAUAAUAACCUCACUAUACUCACUUUCACAAACAAUCCUAUACAACAUAACUACUUAUUCCUCAUUCUUUGACAUAUCCAAUUUAAAACAAGCCCACCUCUCGAGACACACUUACUAACCAUCAACCAAACUAACAUAUCAACACUUAUAUCCAACCAAUCAUAAAACAACUCAUACUGUCACCGCCUAGAUCACCCAACCGAAUGUUUCACCAAGUUUACUCUACUCCACACUAUCCUUUCAAACCAUACAUAUAACACUCUUUAUUCUCCUUAACUUUUCAACAGCACGCCAAAUCCAGUCACUCCAACUUUCUUAUCCACAAAAUCUUCUUCUCUAAUAACACACUCUUCCAUAUUAACCACAUACUACUCCAUUUACUAUAUUACCAUCCACUCUUAUCAUCUACCUCACACCAUAAUUCCUAUAACA'print('Our RNA has FE =', nupack_FE_pred(hinf_targets_final_even_better)[0],      'and', nupack_FE_pred(hinf_targets_final_shuffled)[0],      '; random RNA of length', len_seq, 'have FE =', np.mean(random_seq_fes))print('Our RNA has MFE =', nupack_FE_pred(hinf_targets_final_even_better)[1],      'and', nupack_FE_pred(hinf_targets_final_shuffled)[1],      '; random RNA of length', len_seq, 'have MFE =', np.mean(random_seq_mfes))plt.figure()plt.hist(random_seq_mfes, bins=30, color=colors[0], density=True,         label='Random ' + str(len_seq) + ' nt sequences')# plt.hist(random_seq_mfes_long, bins=30, color=colors[1], density=True,#          label='Random ' + str(len_seq_long) + ' nt sequences')ax = plt.gca()ax.annotate('Target\norder 1\n(961 nt)',             xy=(nupack_FE_pred(hinf_targets_final_even_better)[1], 0),             xytext=(min(random_seq_mfes) * 0.7, 0.03),            arrowprops=dict(arrowstyle="->"))ax.annotate('Target\norder 2\n(961 nt)',             xy=(nupack_FE_pred(hinf_targets_final_shuffled)[1], 0),             xytext=(min(random_seq_mfes) * 0.7, 0.08),            arrowprops=dict(arrowstyle="->"))plt.legend()plt.xlabel('Minimum free energy (kcal/mol)')plt.ylabel('Frequency')plt.show()plt.figure()plt.hist(random_seq_fes, bins=30, color=colors[0], density=True,         label='Random ' + str(len_seq) + ' nt sequences')# plt.hist(random_seq_fes_long, bins=30, color=colors[1], density=True,#          label='Random ' + str(len_seq_long) + ' nt sequences')ax = plt.gca()ax.annotate('Target\norder 1\n(961 nt)',             xy=(nupack_FE_pred(hinf_targets_final_even_better)[1], 0),             xytext=(min(random_seq_mfes) * 0.7, 0.03),            arrowprops=dict(arrowstyle="->"))ax.annotate('Target\norder 2\n(961 nt)',             xy=(nupack_FE_pred(hinf_targets_final_shuffled)[1], 0),             xytext=(min(random_seq_mfes) * 0.7, 0.08),            arrowprops=dict(arrowstyle="->"))plt.legend()plt.xlabel('Total free energy (kcal/mol)')plt.ylabel('Frequency')plt.show()